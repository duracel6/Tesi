
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080002d9 	.word	0x080002d9
 8000008:	080002db 	.word	0x080002db
 800000c:	080002db 	.word	0x080002db
 8000010:	080002db 	.word	0x080002db
 8000014:	080002db 	.word	0x080002db
 8000018:	080002db 	.word	0x080002db
 800001c:	080002db 	.word	0x080002db
 8000020:	080002db 	.word	0x080002db
 8000024:	080002db 	.word	0x080002db
 8000028:	080002db 	.word	0x080002db
 800002c:	08004d41 	.word	0x08004d41
 8000030:	080002db 	.word	0x080002db
 8000034:	080002db 	.word	0x080002db
 8000038:	080002db 	.word	0x080002db
 800003c:	080002db 	.word	0x080002db
 8000040:	080002db 	.word	0x080002db
 8000044:	080002db 	.word	0x080002db
 8000048:	080002db 	.word	0x080002db
 800004c:	080002db 	.word	0x080002db
 8000050:	080002db 	.word	0x080002db
 8000054:	080002db 	.word	0x080002db
 8000058:	080002db 	.word	0x080002db
 800005c:	080002db 	.word	0x080002db
 8000060:	080002db 	.word	0x080002db
 8000064:	080002db 	.word	0x080002db
 8000068:	080002db 	.word	0x080002db
 800006c:	08002241 	.word	0x08002241
 8000070:	08002281 	.word	0x08002281
 8000074:	080022d1 	.word	0x080022d1
 8000078:	08002321 	.word	0x08002321
 800007c:	08002371 	.word	0x08002371
 8000080:	080023b1 	.word	0x080023b1
 8000084:	08002401 	.word	0x08002401
 8000088:	080002db 	.word	0x080002db
 800008c:	080002db 	.word	0x080002db
 8000090:	080002db 	.word	0x080002db
 8000094:	080002db 	.word	0x080002db
 8000098:	080002db 	.word	0x080002db
 800009c:	080002db 	.word	0x080002db
 80000a0:	080002db 	.word	0x080002db
 80000a4:	080002db 	.word	0x080002db
 80000a8:	080002db 	.word	0x080002db
 80000ac:	080002db 	.word	0x080002db
 80000b0:	08001f11 	.word	0x08001f11
 80000b4:	080002db 	.word	0x080002db
 80000b8:	080002db 	.word	0x080002db
 80000bc:	080002db 	.word	0x080002db
 80000c0:	080002db 	.word	0x080002db
 80000c4:	080002db 	.word	0x080002db
 80000c8:	080002db 	.word	0x080002db
 80000cc:	080002db 	.word	0x080002db
 80000d0:	080002db 	.word	0x080002db
 80000d4:	08001e21 	.word	0x08001e21
 80000d8:	08001e51 	.word	0x08001e51
 80000dc:	080002db 	.word	0x080002db
 80000e0:	080002db 	.word	0x080002db
 80000e4:	080002db 	.word	0x080002db
 80000e8:	080002db 	.word	0x080002db
 80000ec:	080002db 	.word	0x080002db
 80000f0:	080002db 	.word	0x080002db
 80000f4:	080002db 	.word	0x080002db
 80000f8:	080002db 	.word	0x080002db
 80000fc:	08002451 	.word	0x08002451
 8000100:	080002db 	.word	0x080002db
 8000104:	080002db 	.word	0x080002db
 8000108:	080002db 	.word	0x080002db
 800010c:	080002db 	.word	0x080002db
 8000110:	080002db 	.word	0x080002db
 8000114:	080002db 	.word	0x080002db
 8000118:	080002db 	.word	0x080002db
 800011c:	080002db 	.word	0x080002db
 8000120:	080024a1 	.word	0x080024a1
 8000124:	080024e1 	.word	0x080024e1
 8000128:	08002531 	.word	0x08002531
 800012c:	08002581 	.word	0x08002581
 8000130:	080025d1 	.word	0x080025d1
 8000134:	080002db 	.word	0x080002db
 8000138:	080002db 	.word	0x080002db
 800013c:	080002db 	.word	0x080002db
 8000140:	080002db 	.word	0x080002db
 8000144:	080002db 	.word	0x080002db
 8000148:	080002db 	.word	0x080002db
 800014c:	080002db 	.word	0x080002db
 8000150:	08002611 	.word	0x08002611
 8000154:	08002661 	.word	0x08002661
 8000158:	080026b1 	.word	0x080026b1
 800015c:	080002db 	.word	0x080002db
 8000160:	080002db 	.word	0x080002db
 8000164:	080002db 	.word	0x080002db
 8000168:	080002db 	.word	0x080002db
 800016c:	080002db 	.word	0x080002db
 8000170:	080002db 	.word	0x080002db
 8000174:	080002db 	.word	0x080002db
 8000178:	080002db 	.word	0x080002db
 800017c:	080002db 	.word	0x080002db
 8000180:	080002db 	.word	0x080002db
 8000184:	080002db 	.word	0x080002db
 8000188:	080002db 	.word	0x080002db
 800018c:	080002db 	.word	0x080002db
 8000190:	080002db 	.word	0x080002db
 8000194:	080002db 	.word	0x080002db
 8000198:	080002db 	.word	0x080002db
 800019c:	080002db 	.word	0x080002db
 80001a0:	080002db 	.word	0x080002db
 80001a4:	080002db 	.word	0x080002db
 80001a8:	080002db 	.word	0x080002db
 80001ac:	080002db 	.word	0x080002db
 80001b0:	080002db 	.word	0x080002db
 80001b4:	080002db 	.word	0x080002db
 80001b8:	080002db 	.word	0x080002db
 80001bc:	080002db 	.word	0x080002db
 80001c0:	080002db 	.word	0x080002db
 80001c4:	080002db 	.word	0x080002db
 80001c8:	080002db 	.word	0x080002db
 80001cc:	080002db 	.word	0x080002db
 80001d0:	080002db 	.word	0x080002db
 80001d4:	080002db 	.word	0x080002db
 80001d8:	080002db 	.word	0x080002db
 80001dc:	080002db 	.word	0x080002db

Disassembly of section .text:

08000200 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000200:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 8000202:	4827      	ldr	r0, [pc, #156]	; (80002a0 <endfiniloop+0x4>)
                msr     MSP, r0
 8000204:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000208:	4826      	ldr	r0, [pc, #152]	; (80002a4 <endfiniloop+0x8>)
                msr     PSP, r0
 800020a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 800020e:	4826      	ldr	r0, [pc, #152]	; (80002a8 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
 8000210:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 8000214:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000218:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 800021a:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 800021c:	f380 8814 	msr	CONTROL, r0
                isb
 8000220:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 8000224:	f000 ff14 	bl	8001050 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000228:	f003 fa4a 	bl	80036c0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800022c:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000230:	491e      	ldr	r1, [pc, #120]	; (80002ac <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 8000232:	4a1b      	ldr	r2, [pc, #108]	; (80002a0 <endfiniloop+0x4>)

08000234 <msloop>:
msloop:
                cmp     r1, r2
 8000234:	4291      	cmp	r1, r2
                itt     lo
 8000236:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000238:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 800023c:	e7fa      	bcc.n	8000234 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800023e:	491c      	ldr	r1, [pc, #112]	; (80002b0 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 8000240:	4a18      	ldr	r2, [pc, #96]	; (80002a4 <endfiniloop+0x8>)

08000242 <psloop>:
psloop:
                cmp     r1, r2
 8000242:	4291      	cmp	r1, r2
                itt     lo
 8000244:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000246:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 800024a:	e7fa      	bcc.n	8000242 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =__textdata_base__
 800024c:	4919      	ldr	r1, [pc, #100]	; (80002b4 <endfiniloop+0x18>)
                ldr     r2, =__data_base__
 800024e:	4a1a      	ldr	r2, [pc, #104]	; (80002b8 <endfiniloop+0x1c>)
                ldr     r3, =__data_end__
 8000250:	4b1a      	ldr	r3, [pc, #104]	; (80002bc <endfiniloop+0x20>)

08000252 <dloop>:
dloop:
                cmp     r2, r3
 8000252:	429a      	cmp	r2, r3
                ittt    lo
 8000254:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000256:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800025a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800025e:	e7f8      	bcc.n	8000252 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000260:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 8000262:	4917      	ldr	r1, [pc, #92]	; (80002c0 <endfiniloop+0x24>)
                ldr     r2, =__bss_end__
 8000264:	4a17      	ldr	r2, [pc, #92]	; (80002c4 <endfiniloop+0x28>)

08000266 <bloop>:
bloop:
                cmp     r1, r2
 8000266:	4291      	cmp	r1, r2
                itt     lo
 8000268:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800026a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 800026e:	e7fa      	bcc.n	8000266 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000270:	f000 ff06 	bl	8001080 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000274:	f000 fef4 	bl	8001060 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000278:	4c13      	ldr	r4, [pc, #76]	; (80002c8 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end__
 800027a:	4d14      	ldr	r5, [pc, #80]	; (80002cc <endfiniloop+0x30>)

0800027c <initloop>:
initloop:
                cmp     r4, r5
 800027c:	42ac      	cmp	r4, r5
                bge     endinitloop
 800027e:	da03      	bge.n	8000288 <endinitloop>
                ldr     r1, [r4], #4
 8000280:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000284:	4788      	blx	r1
                b       initloop
 8000286:	e7f9      	b.n	800027c <initloop>

08000288 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000288:	f006 fc3a 	bl	8006b00 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 800028c:	4c10      	ldr	r4, [pc, #64]	; (80002d0 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end__
 800028e:	4d11      	ldr	r5, [pc, #68]	; (80002d4 <endfiniloop+0x38>)

08000290 <finiloop>:
finiloop:
                cmp     r4, r5
 8000290:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000292:	da03      	bge.n	800029c <endfiniloop>
                ldr     r1, [r4], #4
 8000294:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000298:	4788      	blx	r1
                b       finiloop
 800029a:	e7f9      	b.n	8000290 <finiloop>

0800029c <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 800029c:	f000 bee8 	b.w	8001070 <__default_exit>
                ldr     r0, =__main_stack_end__
 80002a0:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 80002a4:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 80002a8:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 80002ac:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 80002b0:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 80002b4:	0800770c 	.word	0x0800770c
                ldr     r2, =__data_base__
 80002b8:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 80002bc:	20000c58 	.word	0x20000c58
                ldr     r1, =__bss_base__
 80002c0:	20000c58 	.word	0x20000c58
                ldr     r2, =__bss_end__
 80002c4:	200016c0 	.word	0x200016c0
                ldr     r4, =__init_array_base__
 80002c8:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end__
 80002cc:	080001e0 	.word	0x080001e0
                ldr     r4, =__fini_array_base__
 80002d0:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end__
 80002d4:	080001e0 	.word	0x080001e0

080002d8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80002d8:	e792      	b.n	8000200 <_crt0_entry>

080002da <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80002da:	f000 f800 	bl	80002de <_unhandled_exception>

080002de <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80002de:	e7fe      	b.n	80002de <_unhandled_exception>

080002e0 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002e4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002e8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002ea:	469d      	mov	sp, r3

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002f0 <__port_thread_start>:
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002f0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002f2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002f6:	4628      	mov	r0, r5
                blx     r4
 80002f8:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002fa:	2000      	movs	r0, #0
                bl      chThdExit
 80002fc:	f004 fa10 	bl	8004720 <chThdExit>

08000300 <.zombies>:
.zombies:       b       .zombies
 8000300:	e7fe      	b.n	8000300 <.zombies>

08000302 <__port_switch_from_isr>:
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
#endif
                bl      chSchDoPreemption
 8000302:	f003 ff6d 	bl	80041e0 <chSchDoPreemption>

08000306 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000306:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000308:	e7fe      	b.n	8000308 <__port_exit_from_isr+0x2>
	...

0800030c <memcpy>:
 800030c:	4684      	mov	ip, r0
 800030e:	ea41 0300 	orr.w	r3, r1, r0
 8000312:	f013 0303 	ands.w	r3, r3, #3
 8000316:	d16d      	bne.n	80003f4 <memcpy+0xe8>
 8000318:	3a40      	subs	r2, #64	; 0x40
 800031a:	d341      	bcc.n	80003a0 <memcpy+0x94>
 800031c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000320:	f840 3b04 	str.w	r3, [r0], #4
 8000324:	f851 3b04 	ldr.w	r3, [r1], #4
 8000328:	f840 3b04 	str.w	r3, [r0], #4
 800032c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000330:	f840 3b04 	str.w	r3, [r0], #4
 8000334:	f851 3b04 	ldr.w	r3, [r1], #4
 8000338:	f840 3b04 	str.w	r3, [r0], #4
 800033c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000340:	f840 3b04 	str.w	r3, [r0], #4
 8000344:	f851 3b04 	ldr.w	r3, [r1], #4
 8000348:	f840 3b04 	str.w	r3, [r0], #4
 800034c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000350:	f840 3b04 	str.w	r3, [r0], #4
 8000354:	f851 3b04 	ldr.w	r3, [r1], #4
 8000358:	f840 3b04 	str.w	r3, [r0], #4
 800035c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000360:	f840 3b04 	str.w	r3, [r0], #4
 8000364:	f851 3b04 	ldr.w	r3, [r1], #4
 8000368:	f840 3b04 	str.w	r3, [r0], #4
 800036c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000370:	f840 3b04 	str.w	r3, [r0], #4
 8000374:	f851 3b04 	ldr.w	r3, [r1], #4
 8000378:	f840 3b04 	str.w	r3, [r0], #4
 800037c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000380:	f840 3b04 	str.w	r3, [r0], #4
 8000384:	f851 3b04 	ldr.w	r3, [r1], #4
 8000388:	f840 3b04 	str.w	r3, [r0], #4
 800038c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000390:	f840 3b04 	str.w	r3, [r0], #4
 8000394:	f851 3b04 	ldr.w	r3, [r1], #4
 8000398:	f840 3b04 	str.w	r3, [r0], #4
 800039c:	3a40      	subs	r2, #64	; 0x40
 800039e:	d2bd      	bcs.n	800031c <memcpy+0x10>
 80003a0:	3230      	adds	r2, #48	; 0x30
 80003a2:	d311      	bcc.n	80003c8 <memcpy+0xbc>
 80003a4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a8:	f840 3b04 	str.w	r3, [r0], #4
 80003ac:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b0:	f840 3b04 	str.w	r3, [r0], #4
 80003b4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b8:	f840 3b04 	str.w	r3, [r0], #4
 80003bc:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c0:	f840 3b04 	str.w	r3, [r0], #4
 80003c4:	3a10      	subs	r2, #16
 80003c6:	d2ed      	bcs.n	80003a4 <memcpy+0x98>
 80003c8:	320c      	adds	r2, #12
 80003ca:	d305      	bcc.n	80003d8 <memcpy+0xcc>
 80003cc:	f851 3b04 	ldr.w	r3, [r1], #4
 80003d0:	f840 3b04 	str.w	r3, [r0], #4
 80003d4:	3a04      	subs	r2, #4
 80003d6:	d2f9      	bcs.n	80003cc <memcpy+0xc0>
 80003d8:	3204      	adds	r2, #4
 80003da:	d008      	beq.n	80003ee <memcpy+0xe2>
 80003dc:	07d2      	lsls	r2, r2, #31
 80003de:	bf1c      	itt	ne
 80003e0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003e4:	f800 3b01 	strbne.w	r3, [r0], #1
 80003e8:	d301      	bcc.n	80003ee <memcpy+0xe2>
 80003ea:	880b      	ldrh	r3, [r1, #0]
 80003ec:	8003      	strh	r3, [r0, #0]
 80003ee:	4660      	mov	r0, ip
 80003f0:	4770      	bx	lr
 80003f2:	bf00      	nop
 80003f4:	2a08      	cmp	r2, #8
 80003f6:	d313      	bcc.n	8000420 <memcpy+0x114>
 80003f8:	078b      	lsls	r3, r1, #30
 80003fa:	d08d      	beq.n	8000318 <memcpy+0xc>
 80003fc:	f010 0303 	ands.w	r3, r0, #3
 8000400:	d08a      	beq.n	8000318 <memcpy+0xc>
 8000402:	f1c3 0304 	rsb	r3, r3, #4
 8000406:	1ad2      	subs	r2, r2, r3
 8000408:	07db      	lsls	r3, r3, #31
 800040a:	bf1c      	itt	ne
 800040c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000410:	f800 3b01 	strbne.w	r3, [r0], #1
 8000414:	d380      	bcc.n	8000318 <memcpy+0xc>
 8000416:	f831 3b02 	ldrh.w	r3, [r1], #2
 800041a:	f820 3b02 	strh.w	r3, [r0], #2
 800041e:	e77b      	b.n	8000318 <memcpy+0xc>
 8000420:	3a04      	subs	r2, #4
 8000422:	d3d9      	bcc.n	80003d8 <memcpy+0xcc>
 8000424:	3a01      	subs	r2, #1
 8000426:	f811 3b01 	ldrb.w	r3, [r1], #1
 800042a:	f800 3b01 	strb.w	r3, [r0], #1
 800042e:	d2f9      	bcs.n	8000424 <memcpy+0x118>
 8000430:	780b      	ldrb	r3, [r1, #0]
 8000432:	7003      	strb	r3, [r0, #0]
 8000434:	784b      	ldrb	r3, [r1, #1]
 8000436:	7043      	strb	r3, [r0, #1]
 8000438:	788b      	ldrb	r3, [r1, #2]
 800043a:	7083      	strb	r3, [r0, #2]
 800043c:	4660      	mov	r0, ip
 800043e:	4770      	bx	lr
 8000440:	eba2 0003 	sub.w	r0, r2, r3
 8000444:	4770      	bx	lr
 8000446:	bf00      	nop

08000448 <strcmp>:
 8000448:	7802      	ldrb	r2, [r0, #0]
 800044a:	780b      	ldrb	r3, [r1, #0]
 800044c:	2a01      	cmp	r2, #1
 800044e:	bf28      	it	cs
 8000450:	429a      	cmpcs	r2, r3
 8000452:	d1f5      	bne.n	8000440 <memcpy+0x134>
 8000454:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8000458:	ea40 0401 	orr.w	r4, r0, r1
 800045c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8000460:	f06f 0c00 	mvn.w	ip, #0
 8000464:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8000468:	b312      	cbz	r2, 80004b0 <strcmp+0x68>
 800046a:	ea80 0401 	eor.w	r4, r0, r1
 800046e:	f014 0f07 	tst.w	r4, #7
 8000472:	d16a      	bne.n	800054a <strcmp+0x102>
 8000474:	f000 0407 	and.w	r4, r0, #7
 8000478:	f020 0007 	bic.w	r0, r0, #7
 800047c:	f004 0503 	and.w	r5, r4, #3
 8000480:	f021 0107 	bic.w	r1, r1, #7
 8000484:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8000488:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 800048c:	f014 0f04 	tst.w	r4, #4
 8000490:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000494:	fa0c f405 	lsl.w	r4, ip, r5
 8000498:	ea62 0204 	orn	r2, r2, r4
 800049c:	ea66 0604 	orn	r6, r6, r4
 80004a0:	d00a      	beq.n	80004b8 <strcmp+0x70>
 80004a2:	ea63 0304 	orn	r3, r3, r4
 80004a6:	4662      	mov	r2, ip
 80004a8:	ea67 0704 	orn	r7, r7, r4
 80004ac:	4666      	mov	r6, ip
 80004ae:	e003      	b.n	80004b8 <strcmp+0x70>
 80004b0:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 80004b4:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 80004b8:	fa82 f54c 	uadd8	r5, r2, ip
 80004bc:	ea82 0406 	eor.w	r4, r2, r6
 80004c0:	faa4 f48c 	sel	r4, r4, ip
 80004c4:	bb6c      	cbnz	r4, 8000522 <strcmp+0xda>
 80004c6:	fa83 f54c 	uadd8	r5, r3, ip
 80004ca:	ea83 0507 	eor.w	r5, r3, r7
 80004ce:	faa5 f58c 	sel	r5, r5, ip
 80004d2:	b995      	cbnz	r5, 80004fa <strcmp+0xb2>
 80004d4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 80004d8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 80004dc:	fa82 f54c 	uadd8	r5, r2, ip
 80004e0:	ea82 0406 	eor.w	r4, r2, r6
 80004e4:	faa4 f48c 	sel	r4, r4, ip
 80004e8:	fa83 f54c 	uadd8	r5, r3, ip
 80004ec:	ea83 0507 	eor.w	r5, r3, r7
 80004f0:	faa5 f58c 	sel	r5, r5, ip
 80004f4:	4325      	orrs	r5, r4
 80004f6:	d0db      	beq.n	80004b0 <strcmp+0x68>
 80004f8:	b99c      	cbnz	r4, 8000522 <strcmp+0xda>
 80004fa:	ba2d      	rev	r5, r5
 80004fc:	fab5 f485 	clz	r4, r5
 8000500:	f024 0407 	bic.w	r4, r4, #7
 8000504:	fa27 f104 	lsr.w	r1, r7, r4
 8000508:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 800050c:	fa23 f304 	lsr.w	r3, r3, r4
 8000510:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8000514:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000518:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800051c:	eba0 0001 	sub.w	r0, r0, r1
 8000520:	4770      	bx	lr
 8000522:	ba24      	rev	r4, r4
 8000524:	fab4 f484 	clz	r4, r4
 8000528:	f024 0407 	bic.w	r4, r4, #7
 800052c:	fa26 f104 	lsr.w	r1, r6, r4
 8000530:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8000534:	fa22 f204 	lsr.w	r2, r2, r4
 8000538:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800053c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000540:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000544:	eba0 0001 	sub.w	r0, r0, r1
 8000548:	4770      	bx	lr
 800054a:	f014 0f03 	tst.w	r4, #3
 800054e:	d13c      	bne.n	80005ca <strcmp+0x182>
 8000550:	f010 0403 	ands.w	r4, r0, #3
 8000554:	d128      	bne.n	80005a8 <strcmp+0x160>
 8000556:	f850 2b08 	ldr.w	r2, [r0], #8
 800055a:	f851 3b08 	ldr.w	r3, [r1], #8
 800055e:	fa82 f54c 	uadd8	r5, r2, ip
 8000562:	ea82 0503 	eor.w	r5, r2, r3
 8000566:	faa5 f58c 	sel	r5, r5, ip
 800056a:	b95d      	cbnz	r5, 8000584 <strcmp+0x13c>
 800056c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8000570:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8000574:	fa82 f54c 	uadd8	r5, r2, ip
 8000578:	ea82 0503 	eor.w	r5, r2, r3
 800057c:	faa5 f58c 	sel	r5, r5, ip
 8000580:	2d00      	cmp	r5, #0
 8000582:	d0e8      	beq.n	8000556 <strcmp+0x10e>
 8000584:	ba2d      	rev	r5, r5
 8000586:	fab5 f485 	clz	r4, r5
 800058a:	f024 0407 	bic.w	r4, r4, #7
 800058e:	fa23 f104 	lsr.w	r1, r3, r4
 8000592:	fa22 f204 	lsr.w	r2, r2, r4
 8000596:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800059a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800059e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80005a2:	eba0 0001 	sub.w	r0, r0, r1
 80005a6:	4770      	bx	lr
 80005a8:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 80005ac:	f020 0003 	bic.w	r0, r0, #3
 80005b0:	f850 2b08 	ldr.w	r2, [r0], #8
 80005b4:	f021 0103 	bic.w	r1, r1, #3
 80005b8:	f851 3b08 	ldr.w	r3, [r1], #8
 80005bc:	fa0c f404 	lsl.w	r4, ip, r4
 80005c0:	ea62 0204 	orn	r2, r2, r4
 80005c4:	ea63 0304 	orn	r3, r3, r4
 80005c8:	e7c9      	b.n	800055e <strcmp+0x116>
 80005ca:	f010 0403 	ands.w	r4, r0, #3
 80005ce:	d01a      	beq.n	8000606 <strcmp+0x1be>
 80005d0:	eba1 0104 	sub.w	r1, r1, r4
 80005d4:	f020 0003 	bic.w	r0, r0, #3
 80005d8:	07e4      	lsls	r4, r4, #31
 80005da:	f850 2b04 	ldr.w	r2, [r0], #4
 80005de:	d006      	beq.n	80005ee <strcmp+0x1a6>
 80005e0:	d20f      	bcs.n	8000602 <strcmp+0x1ba>
 80005e2:	788b      	ldrb	r3, [r1, #2]
 80005e4:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 80005e8:	1ae4      	subs	r4, r4, r3
 80005ea:	d106      	bne.n	80005fa <strcmp+0x1b2>
 80005ec:	b12b      	cbz	r3, 80005fa <strcmp+0x1b2>
 80005ee:	78cb      	ldrb	r3, [r1, #3]
 80005f0:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 80005f4:	1ae4      	subs	r4, r4, r3
 80005f6:	d100      	bne.n	80005fa <strcmp+0x1b2>
 80005f8:	b91b      	cbnz	r3, 8000602 <strcmp+0x1ba>
 80005fa:	4620      	mov	r0, r4
 80005fc:	f85d 4b10 	ldr.w	r4, [sp], #16
 8000600:	4770      	bx	lr
 8000602:	f101 0104 	add.w	r1, r1, #4
 8000606:	f850 2b04 	ldr.w	r2, [r0], #4
 800060a:	07cc      	lsls	r4, r1, #31
 800060c:	f021 0103 	bic.w	r1, r1, #3
 8000610:	f851 3b04 	ldr.w	r3, [r1], #4
 8000614:	d848      	bhi.n	80006a8 <strcmp+0x260>
 8000616:	d224      	bcs.n	8000662 <strcmp+0x21a>
 8000618:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 800061c:	fa82 f54c 	uadd8	r5, r2, ip
 8000620:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8000624:	faa5 f58c 	sel	r5, r5, ip
 8000628:	d10a      	bne.n	8000640 <strcmp+0x1f8>
 800062a:	b965      	cbnz	r5, 8000646 <strcmp+0x1fe>
 800062c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000630:	ea84 0402 	eor.w	r4, r4, r2
 8000634:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 8000638:	d10e      	bne.n	8000658 <strcmp+0x210>
 800063a:	f850 2b04 	ldr.w	r2, [r0], #4
 800063e:	e7eb      	b.n	8000618 <strcmp+0x1d0>
 8000640:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000644:	e055      	b.n	80006f2 <strcmp+0x2aa>
 8000646:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 800064a:	d14d      	bne.n	80006e8 <strcmp+0x2a0>
 800064c:	7808      	ldrb	r0, [r1, #0]
 800064e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000652:	f1c0 0000 	rsb	r0, r0, #0
 8000656:	4770      	bx	lr
 8000658:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800065c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000660:	e047      	b.n	80006f2 <strcmp+0x2aa>
 8000662:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8000666:	fa82 f54c 	uadd8	r5, r2, ip
 800066a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 800066e:	faa5 f58c 	sel	r5, r5, ip
 8000672:	d10a      	bne.n	800068a <strcmp+0x242>
 8000674:	b965      	cbnz	r5, 8000690 <strcmp+0x248>
 8000676:	f851 3b04 	ldr.w	r3, [r1], #4
 800067a:	ea84 0402 	eor.w	r4, r4, r2
 800067e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 8000682:	d10c      	bne.n	800069e <strcmp+0x256>
 8000684:	f850 2b04 	ldr.w	r2, [r0], #4
 8000688:	e7eb      	b.n	8000662 <strcmp+0x21a>
 800068a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800068e:	e030      	b.n	80006f2 <strcmp+0x2aa>
 8000690:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 8000694:	d128      	bne.n	80006e8 <strcmp+0x2a0>
 8000696:	880b      	ldrh	r3, [r1, #0]
 8000698:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800069c:	e029      	b.n	80006f2 <strcmp+0x2aa>
 800069e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80006a2:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 80006a6:	e024      	b.n	80006f2 <strcmp+0x2aa>
 80006a8:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 80006ac:	fa82 f54c 	uadd8	r5, r2, ip
 80006b0:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 80006b4:	faa5 f58c 	sel	r5, r5, ip
 80006b8:	d10a      	bne.n	80006d0 <strcmp+0x288>
 80006ba:	b965      	cbnz	r5, 80006d6 <strcmp+0x28e>
 80006bc:	f851 3b04 	ldr.w	r3, [r1], #4
 80006c0:	ea84 0402 	eor.w	r4, r4, r2
 80006c4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 80006c8:	d109      	bne.n	80006de <strcmp+0x296>
 80006ca:	f850 2b04 	ldr.w	r2, [r0], #4
 80006ce:	e7eb      	b.n	80006a8 <strcmp+0x260>
 80006d0:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80006d4:	e00d      	b.n	80006f2 <strcmp+0x2aa>
 80006d6:	f015 0fff 	tst.w	r5, #255	; 0xff
 80006da:	d105      	bne.n	80006e8 <strcmp+0x2a0>
 80006dc:	680b      	ldr	r3, [r1, #0]
 80006de:	ea4f 2212 	mov.w	r2, r2, lsr #8
 80006e2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80006e6:	e004      	b.n	80006f2 <strcmp+0x2aa>
 80006e8:	f04f 0000 	mov.w	r0, #0
 80006ec:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006f0:	4770      	bx	lr
 80006f2:	ba12      	rev	r2, r2
 80006f4:	ba1b      	rev	r3, r3
 80006f6:	fa82 f44c 	uadd8	r4, r2, ip
 80006fa:	ea82 0403 	eor.w	r4, r2, r3
 80006fe:	faa4 f58c 	sel	r5, r4, ip
 8000702:	fab5 f485 	clz	r4, r5
 8000706:	fa02 f204 	lsl.w	r2, r2, r4
 800070a:	fa03 f304 	lsl.w	r3, r3, r4
 800070e:	ea4f 6012 	mov.w	r0, r2, lsr #24
 8000712:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000716:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 800071a:	4770      	bx	lr
	...

08000740 <strlen>:
 8000740:	f890 f000 	pld	[r0]
 8000744:	e96d 4502 	strd	r4, r5, [sp, #-8]!
 8000748:	f020 0107 	bic.w	r1, r0, #7
 800074c:	f06f 0c00 	mvn.w	ip, #0
 8000750:	f010 0407 	ands.w	r4, r0, #7
 8000754:	f891 f020 	pld	[r1, #32]
 8000758:	f040 8049 	bne.w	80007ee <strlen+0xae>
 800075c:	f04f 0400 	mov.w	r4, #0
 8000760:	f06f 0007 	mvn.w	r0, #7
 8000764:	e9d1 2300 	ldrd	r2, r3, [r1]
 8000768:	f891 f040 	pld	[r1, #64]	; 0x40
 800076c:	f100 0008 	add.w	r0, r0, #8
 8000770:	fa82 f24c 	uadd8	r2, r2, ip
 8000774:	faa4 f28c 	sel	r2, r4, ip
 8000778:	fa83 f34c 	uadd8	r3, r3, ip
 800077c:	faa2 f38c 	sel	r3, r2, ip
 8000780:	bb4b      	cbnz	r3, 80007d6 <strlen+0x96>
 8000782:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
 8000786:	fa82 f24c 	uadd8	r2, r2, ip
 800078a:	f100 0008 	add.w	r0, r0, #8
 800078e:	faa4 f28c 	sel	r2, r4, ip
 8000792:	fa83 f34c 	uadd8	r3, r3, ip
 8000796:	faa2 f38c 	sel	r3, r2, ip
 800079a:	b9e3      	cbnz	r3, 80007d6 <strlen+0x96>
 800079c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
 80007a0:	fa82 f24c 	uadd8	r2, r2, ip
 80007a4:	f100 0008 	add.w	r0, r0, #8
 80007a8:	faa4 f28c 	sel	r2, r4, ip
 80007ac:	fa83 f34c 	uadd8	r3, r3, ip
 80007b0:	faa2 f38c 	sel	r3, r2, ip
 80007b4:	b97b      	cbnz	r3, 80007d6 <strlen+0x96>
 80007b6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
 80007ba:	f101 0120 	add.w	r1, r1, #32
 80007be:	fa82 f24c 	uadd8	r2, r2, ip
 80007c2:	f100 0008 	add.w	r0, r0, #8
 80007c6:	faa4 f28c 	sel	r2, r4, ip
 80007ca:	fa83 f34c 	uadd8	r3, r3, ip
 80007ce:	faa2 f38c 	sel	r3, r2, ip
 80007d2:	2b00      	cmp	r3, #0
 80007d4:	d0c6      	beq.n	8000764 <strlen+0x24>
 80007d6:	2a00      	cmp	r2, #0
 80007d8:	bf04      	itt	eq
 80007da:	3004      	addeq	r0, #4
 80007dc:	461a      	moveq	r2, r3
 80007de:	ba12      	rev	r2, r2
 80007e0:	fab2 f282 	clz	r2, r2
 80007e4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
 80007e8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 80007ec:	4770      	bx	lr
 80007ee:	e9d1 2300 	ldrd	r2, r3, [r1]
 80007f2:	f004 0503 	and.w	r5, r4, #3
 80007f6:	f1c4 0000 	rsb	r0, r4, #0
 80007fa:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 80007fe:	f014 0f04 	tst.w	r4, #4
 8000802:	f891 f040 	pld	[r1, #64]	; 0x40
 8000806:	fa0c f505 	lsl.w	r5, ip, r5
 800080a:	ea62 0205 	orn	r2, r2, r5
 800080e:	bf1c      	itt	ne
 8000810:	ea63 0305 	ornne	r3, r3, r5
 8000814:	4662      	movne	r2, ip
 8000816:	f04f 0400 	mov.w	r4, #0
 800081a:	e7a9      	b.n	8000770 <strlen+0x30>

0800081c <__aeabi_drsub>:
 800081c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000820:	e002      	b.n	8000828 <__adddf3>
 8000822:	bf00      	nop

08000824 <__aeabi_dsub>:
 8000824:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08000828 <__adddf3>:
 8000828:	b530      	push	{r4, r5, lr}
 800082a:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800082e:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000832:	ea94 0f05 	teq	r4, r5
 8000836:	bf08      	it	eq
 8000838:	ea90 0f02 	teqeq	r0, r2
 800083c:	bf1f      	itttt	ne
 800083e:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000842:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000846:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800084a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800084e:	f000 80e2 	beq.w	8000a16 <__adddf3+0x1ee>
 8000852:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000856:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800085a:	bfb8      	it	lt
 800085c:	426d      	neglt	r5, r5
 800085e:	dd0c      	ble.n	800087a <__adddf3+0x52>
 8000860:	442c      	add	r4, r5
 8000862:	ea80 0202 	eor.w	r2, r0, r2
 8000866:	ea81 0303 	eor.w	r3, r1, r3
 800086a:	ea82 0000 	eor.w	r0, r2, r0
 800086e:	ea83 0101 	eor.w	r1, r3, r1
 8000872:	ea80 0202 	eor.w	r2, r0, r2
 8000876:	ea81 0303 	eor.w	r3, r1, r3
 800087a:	2d36      	cmp	r5, #54	; 0x36
 800087c:	bf88      	it	hi
 800087e:	bd30      	pophi	{r4, r5, pc}
 8000880:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000884:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000888:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 800088c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000890:	d002      	beq.n	8000898 <__adddf3+0x70>
 8000892:	4240      	negs	r0, r0
 8000894:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000898:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 800089c:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008a0:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80008a4:	d002      	beq.n	80008ac <__adddf3+0x84>
 80008a6:	4252      	negs	r2, r2
 80008a8:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80008ac:	ea94 0f05 	teq	r4, r5
 80008b0:	f000 80a7 	beq.w	8000a02 <__adddf3+0x1da>
 80008b4:	f1a4 0401 	sub.w	r4, r4, #1
 80008b8:	f1d5 0e20 	rsbs	lr, r5, #32
 80008bc:	db0d      	blt.n	80008da <__adddf3+0xb2>
 80008be:	fa02 fc0e 	lsl.w	ip, r2, lr
 80008c2:	fa22 f205 	lsr.w	r2, r2, r5
 80008c6:	1880      	adds	r0, r0, r2
 80008c8:	f141 0100 	adc.w	r1, r1, #0
 80008cc:	fa03 f20e 	lsl.w	r2, r3, lr
 80008d0:	1880      	adds	r0, r0, r2
 80008d2:	fa43 f305 	asr.w	r3, r3, r5
 80008d6:	4159      	adcs	r1, r3
 80008d8:	e00e      	b.n	80008f8 <__adddf3+0xd0>
 80008da:	f1a5 0520 	sub.w	r5, r5, #32
 80008de:	f10e 0e20 	add.w	lr, lr, #32
 80008e2:	2a01      	cmp	r2, #1
 80008e4:	fa03 fc0e 	lsl.w	ip, r3, lr
 80008e8:	bf28      	it	cs
 80008ea:	f04c 0c02 	orrcs.w	ip, ip, #2
 80008ee:	fa43 f305 	asr.w	r3, r3, r5
 80008f2:	18c0      	adds	r0, r0, r3
 80008f4:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80008f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80008fc:	d507      	bpl.n	800090e <__adddf3+0xe6>
 80008fe:	f04f 0e00 	mov.w	lr, #0
 8000902:	f1dc 0c00 	rsbs	ip, ip, #0
 8000906:	eb7e 0000 	sbcs.w	r0, lr, r0
 800090a:	eb6e 0101 	sbc.w	r1, lr, r1
 800090e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000912:	d31b      	bcc.n	800094c <__adddf3+0x124>
 8000914:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8000918:	d30c      	bcc.n	8000934 <__adddf3+0x10c>
 800091a:	0849      	lsrs	r1, r1, #1
 800091c:	ea5f 0030 	movs.w	r0, r0, rrx
 8000920:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000924:	f104 0401 	add.w	r4, r4, #1
 8000928:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800092c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000930:	f080 809a 	bcs.w	8000a68 <__adddf3+0x240>
 8000934:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000938:	bf08      	it	eq
 800093a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800093e:	f150 0000 	adcs.w	r0, r0, #0
 8000942:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000946:	ea41 0105 	orr.w	r1, r1, r5
 800094a:	bd30      	pop	{r4, r5, pc}
 800094c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000950:	4140      	adcs	r0, r0
 8000952:	eb41 0101 	adc.w	r1, r1, r1
 8000956:	3c01      	subs	r4, #1
 8000958:	bf28      	it	cs
 800095a:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 800095e:	d2e9      	bcs.n	8000934 <__adddf3+0x10c>
 8000960:	f091 0f00 	teq	r1, #0
 8000964:	bf04      	itt	eq
 8000966:	4601      	moveq	r1, r0
 8000968:	2000      	moveq	r0, #0
 800096a:	fab1 f381 	clz	r3, r1
 800096e:	bf08      	it	eq
 8000970:	3320      	addeq	r3, #32
 8000972:	f1a3 030b 	sub.w	r3, r3, #11
 8000976:	f1b3 0220 	subs.w	r2, r3, #32
 800097a:	da0c      	bge.n	8000996 <__adddf3+0x16e>
 800097c:	320c      	adds	r2, #12
 800097e:	dd08      	ble.n	8000992 <__adddf3+0x16a>
 8000980:	f102 0c14 	add.w	ip, r2, #20
 8000984:	f1c2 020c 	rsb	r2, r2, #12
 8000988:	fa01 f00c 	lsl.w	r0, r1, ip
 800098c:	fa21 f102 	lsr.w	r1, r1, r2
 8000990:	e00c      	b.n	80009ac <__adddf3+0x184>
 8000992:	f102 0214 	add.w	r2, r2, #20
 8000996:	bfd8      	it	le
 8000998:	f1c2 0c20 	rsble	ip, r2, #32
 800099c:	fa01 f102 	lsl.w	r1, r1, r2
 80009a0:	fa20 fc0c 	lsr.w	ip, r0, ip
 80009a4:	bfdc      	itt	le
 80009a6:	ea41 010c 	orrle.w	r1, r1, ip
 80009aa:	4090      	lslle	r0, r2
 80009ac:	1ae4      	subs	r4, r4, r3
 80009ae:	bfa2      	ittt	ge
 80009b0:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80009b4:	4329      	orrge	r1, r5
 80009b6:	bd30      	popge	{r4, r5, pc}
 80009b8:	ea6f 0404 	mvn.w	r4, r4
 80009bc:	3c1f      	subs	r4, #31
 80009be:	da1c      	bge.n	80009fa <__adddf3+0x1d2>
 80009c0:	340c      	adds	r4, #12
 80009c2:	dc0e      	bgt.n	80009e2 <__adddf3+0x1ba>
 80009c4:	f104 0414 	add.w	r4, r4, #20
 80009c8:	f1c4 0220 	rsb	r2, r4, #32
 80009cc:	fa20 f004 	lsr.w	r0, r0, r4
 80009d0:	fa01 f302 	lsl.w	r3, r1, r2
 80009d4:	ea40 0003 	orr.w	r0, r0, r3
 80009d8:	fa21 f304 	lsr.w	r3, r1, r4
 80009dc:	ea45 0103 	orr.w	r1, r5, r3
 80009e0:	bd30      	pop	{r4, r5, pc}
 80009e2:	f1c4 040c 	rsb	r4, r4, #12
 80009e6:	f1c4 0220 	rsb	r2, r4, #32
 80009ea:	fa20 f002 	lsr.w	r0, r0, r2
 80009ee:	fa01 f304 	lsl.w	r3, r1, r4
 80009f2:	ea40 0003 	orr.w	r0, r0, r3
 80009f6:	4629      	mov	r1, r5
 80009f8:	bd30      	pop	{r4, r5, pc}
 80009fa:	fa21 f004 	lsr.w	r0, r1, r4
 80009fe:	4629      	mov	r1, r5
 8000a00:	bd30      	pop	{r4, r5, pc}
 8000a02:	f094 0f00 	teq	r4, #0
 8000a06:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 8000a0a:	bf06      	itte	eq
 8000a0c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000a10:	3401      	addeq	r4, #1
 8000a12:	3d01      	subne	r5, #1
 8000a14:	e74e      	b.n	80008b4 <__adddf3+0x8c>
 8000a16:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000a1a:	bf18      	it	ne
 8000a1c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000a20:	d029      	beq.n	8000a76 <__adddf3+0x24e>
 8000a22:	ea94 0f05 	teq	r4, r5
 8000a26:	bf08      	it	eq
 8000a28:	ea90 0f02 	teqeq	r0, r2
 8000a2c:	d005      	beq.n	8000a3a <__adddf3+0x212>
 8000a2e:	ea54 0c00 	orrs.w	ip, r4, r0
 8000a32:	bf04      	itt	eq
 8000a34:	4619      	moveq	r1, r3
 8000a36:	4610      	moveq	r0, r2
 8000a38:	bd30      	pop	{r4, r5, pc}
 8000a3a:	ea91 0f03 	teq	r1, r3
 8000a3e:	bf1e      	ittt	ne
 8000a40:	2100      	movne	r1, #0
 8000a42:	2000      	movne	r0, #0
 8000a44:	bd30      	popne	{r4, r5, pc}
 8000a46:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000a4a:	d105      	bne.n	8000a58 <__adddf3+0x230>
 8000a4c:	0040      	lsls	r0, r0, #1
 8000a4e:	4149      	adcs	r1, r1
 8000a50:	bf28      	it	cs
 8000a52:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8000a56:	bd30      	pop	{r4, r5, pc}
 8000a58:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000a5c:	bf3c      	itt	cc
 8000a5e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000a62:	bd30      	popcc	{r4, r5, pc}
 8000a64:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000a68:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000a6c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000a70:	f04f 0000 	mov.w	r0, #0
 8000a74:	bd30      	pop	{r4, r5, pc}
 8000a76:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000a7a:	bf1a      	itte	ne
 8000a7c:	4619      	movne	r1, r3
 8000a7e:	4610      	movne	r0, r2
 8000a80:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000a84:	bf1c      	itt	ne
 8000a86:	460b      	movne	r3, r1
 8000a88:	4602      	movne	r2, r0
 8000a8a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000a8e:	bf06      	itte	eq
 8000a90:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000a94:	ea91 0f03 	teqeq	r1, r3
 8000a98:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000a9c:	bd30      	pop	{r4, r5, pc}
 8000a9e:	bf00      	nop

08000aa0 <__aeabi_ui2d>:
 8000aa0:	f090 0f00 	teq	r0, #0
 8000aa4:	bf04      	itt	eq
 8000aa6:	2100      	moveq	r1, #0
 8000aa8:	4770      	bxeq	lr
 8000aaa:	b530      	push	{r4, r5, lr}
 8000aac:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000ab0:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000ab4:	f04f 0500 	mov.w	r5, #0
 8000ab8:	f04f 0100 	mov.w	r1, #0
 8000abc:	e750      	b.n	8000960 <__adddf3+0x138>
 8000abe:	bf00      	nop

08000ac0 <__aeabi_i2d>:
 8000ac0:	f090 0f00 	teq	r0, #0
 8000ac4:	bf04      	itt	eq
 8000ac6:	2100      	moveq	r1, #0
 8000ac8:	4770      	bxeq	lr
 8000aca:	b530      	push	{r4, r5, lr}
 8000acc:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000ad0:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000ad4:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8000ad8:	bf48      	it	mi
 8000ada:	4240      	negmi	r0, r0
 8000adc:	f04f 0100 	mov.w	r1, #0
 8000ae0:	e73e      	b.n	8000960 <__adddf3+0x138>
 8000ae2:	bf00      	nop

08000ae4 <__aeabi_f2d>:
 8000ae4:	0042      	lsls	r2, r0, #1
 8000ae6:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8000aea:	ea4f 0131 	mov.w	r1, r1, rrx
 8000aee:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000af2:	bf1f      	itttt	ne
 8000af4:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8000af8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000afc:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000b00:	4770      	bxne	lr
 8000b02:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 8000b06:	bf08      	it	eq
 8000b08:	4770      	bxeq	lr
 8000b0a:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8000b0e:	bf04      	itt	eq
 8000b10:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8000b14:	4770      	bxeq	lr
 8000b16:	b530      	push	{r4, r5, lr}
 8000b18:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000b1c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000b20:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000b24:	e71c      	b.n	8000960 <__adddf3+0x138>
 8000b26:	bf00      	nop

08000b28 <__aeabi_ul2d>:
 8000b28:	ea50 0201 	orrs.w	r2, r0, r1
 8000b2c:	bf08      	it	eq
 8000b2e:	4770      	bxeq	lr
 8000b30:	b530      	push	{r4, r5, lr}
 8000b32:	f04f 0500 	mov.w	r5, #0
 8000b36:	e00a      	b.n	8000b4e <__aeabi_l2d+0x16>

08000b38 <__aeabi_l2d>:
 8000b38:	ea50 0201 	orrs.w	r2, r0, r1
 8000b3c:	bf08      	it	eq
 8000b3e:	4770      	bxeq	lr
 8000b40:	b530      	push	{r4, r5, lr}
 8000b42:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000b46:	d502      	bpl.n	8000b4e <__aeabi_l2d+0x16>
 8000b48:	4240      	negs	r0, r0
 8000b4a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000b4e:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000b52:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000b56:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000b5a:	f43f aed8 	beq.w	800090e <__adddf3+0xe6>
 8000b5e:	f04f 0203 	mov.w	r2, #3
 8000b62:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000b66:	bf18      	it	ne
 8000b68:	3203      	addne	r2, #3
 8000b6a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000b6e:	bf18      	it	ne
 8000b70:	3203      	addne	r2, #3
 8000b72:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000b76:	f1c2 0320 	rsb	r3, r2, #32
 8000b7a:	fa00 fc03 	lsl.w	ip, r0, r3
 8000b7e:	fa20 f002 	lsr.w	r0, r0, r2
 8000b82:	fa01 fe03 	lsl.w	lr, r1, r3
 8000b86:	ea40 000e 	orr.w	r0, r0, lr
 8000b8a:	fa21 f102 	lsr.w	r1, r1, r2
 8000b8e:	4414      	add	r4, r2
 8000b90:	e6bd      	b.n	800090e <__adddf3+0xe6>
 8000b92:	bf00      	nop

08000b94 <__aeabi_frsub>:
 8000b94:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 8000b98:	e002      	b.n	8000ba0 <__addsf3>
 8000b9a:	bf00      	nop

08000b9c <__aeabi_fsub>:
 8000b9c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08000ba0 <__addsf3>:
 8000ba0:	0042      	lsls	r2, r0, #1
 8000ba2:	bf1f      	itttt	ne
 8000ba4:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000ba8:	ea92 0f03 	teqne	r2, r3
 8000bac:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8000bb0:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000bb4:	d06a      	beq.n	8000c8c <__addsf3+0xec>
 8000bb6:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000bba:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 8000bbe:	bfc1      	itttt	gt
 8000bc0:	18d2      	addgt	r2, r2, r3
 8000bc2:	4041      	eorgt	r1, r0
 8000bc4:	4048      	eorgt	r0, r1
 8000bc6:	4041      	eorgt	r1, r0
 8000bc8:	bfb8      	it	lt
 8000bca:	425b      	neglt	r3, r3
 8000bcc:	2b19      	cmp	r3, #25
 8000bce:	bf88      	it	hi
 8000bd0:	4770      	bxhi	lr
 8000bd2:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000bd6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000bda:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8000bde:	bf18      	it	ne
 8000be0:	4240      	negne	r0, r0
 8000be2:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000be6:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8000bea:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8000bee:	bf18      	it	ne
 8000bf0:	4249      	negne	r1, r1
 8000bf2:	ea92 0f03 	teq	r2, r3
 8000bf6:	d03f      	beq.n	8000c78 <__addsf3+0xd8>
 8000bf8:	f1a2 0201 	sub.w	r2, r2, #1
 8000bfc:	fa41 fc03 	asr.w	ip, r1, r3
 8000c00:	eb10 000c 	adds.w	r0, r0, ip
 8000c04:	f1c3 0320 	rsb	r3, r3, #32
 8000c08:	fa01 f103 	lsl.w	r1, r1, r3
 8000c0c:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000c10:	d502      	bpl.n	8000c18 <__addsf3+0x78>
 8000c12:	4249      	negs	r1, r1
 8000c14:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 8000c18:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8000c1c:	d313      	bcc.n	8000c46 <__addsf3+0xa6>
 8000c1e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000c22:	d306      	bcc.n	8000c32 <__addsf3+0x92>
 8000c24:	0840      	lsrs	r0, r0, #1
 8000c26:	ea4f 0131 	mov.w	r1, r1, rrx
 8000c2a:	f102 0201 	add.w	r2, r2, #1
 8000c2e:	2afe      	cmp	r2, #254	; 0xfe
 8000c30:	d251      	bcs.n	8000cd6 <__addsf3+0x136>
 8000c32:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8000c36:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000c3a:	bf08      	it	eq
 8000c3c:	f020 0001 	biceq.w	r0, r0, #1
 8000c40:	ea40 0003 	orr.w	r0, r0, r3
 8000c44:	4770      	bx	lr
 8000c46:	0049      	lsls	r1, r1, #1
 8000c48:	eb40 0000 	adc.w	r0, r0, r0
 8000c4c:	3a01      	subs	r2, #1
 8000c4e:	bf28      	it	cs
 8000c50:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 8000c54:	d2ed      	bcs.n	8000c32 <__addsf3+0x92>
 8000c56:	fab0 fc80 	clz	ip, r0
 8000c5a:	f1ac 0c08 	sub.w	ip, ip, #8
 8000c5e:	ebb2 020c 	subs.w	r2, r2, ip
 8000c62:	fa00 f00c 	lsl.w	r0, r0, ip
 8000c66:	bfaa      	itet	ge
 8000c68:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000c6c:	4252      	neglt	r2, r2
 8000c6e:	4318      	orrge	r0, r3
 8000c70:	bfbc      	itt	lt
 8000c72:	40d0      	lsrlt	r0, r2
 8000c74:	4318      	orrlt	r0, r3
 8000c76:	4770      	bx	lr
 8000c78:	f092 0f00 	teq	r2, #0
 8000c7c:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8000c80:	bf06      	itte	eq
 8000c82:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 8000c86:	3201      	addeq	r2, #1
 8000c88:	3b01      	subne	r3, #1
 8000c8a:	e7b5      	b.n	8000bf8 <__addsf3+0x58>
 8000c8c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000c90:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000c94:	bf18      	it	ne
 8000c96:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000c9a:	d021      	beq.n	8000ce0 <__addsf3+0x140>
 8000c9c:	ea92 0f03 	teq	r2, r3
 8000ca0:	d004      	beq.n	8000cac <__addsf3+0x10c>
 8000ca2:	f092 0f00 	teq	r2, #0
 8000ca6:	bf08      	it	eq
 8000ca8:	4608      	moveq	r0, r1
 8000caa:	4770      	bx	lr
 8000cac:	ea90 0f01 	teq	r0, r1
 8000cb0:	bf1c      	itt	ne
 8000cb2:	2000      	movne	r0, #0
 8000cb4:	4770      	bxne	lr
 8000cb6:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 8000cba:	d104      	bne.n	8000cc6 <__addsf3+0x126>
 8000cbc:	0040      	lsls	r0, r0, #1
 8000cbe:	bf28      	it	cs
 8000cc0:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 8000cc4:	4770      	bx	lr
 8000cc6:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 8000cca:	bf3c      	itt	cc
 8000ccc:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8000cd0:	4770      	bxcc	lr
 8000cd2:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000cd6:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8000cda:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000cde:	4770      	bx	lr
 8000ce0:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000ce4:	bf16      	itet	ne
 8000ce6:	4608      	movne	r0, r1
 8000ce8:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000cec:	4601      	movne	r1, r0
 8000cee:	0242      	lsls	r2, r0, #9
 8000cf0:	bf06      	itte	eq
 8000cf2:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8000cf6:	ea90 0f01 	teqeq	r0, r1
 8000cfa:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8000cfe:	4770      	bx	lr

08000d00 <__aeabi_ui2f>:
 8000d00:	f04f 0300 	mov.w	r3, #0
 8000d04:	e004      	b.n	8000d10 <__aeabi_i2f+0x8>
 8000d06:	bf00      	nop

08000d08 <__aeabi_i2f>:
 8000d08:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8000d0c:	bf48      	it	mi
 8000d0e:	4240      	negmi	r0, r0
 8000d10:	ea5f 0c00 	movs.w	ip, r0
 8000d14:	bf08      	it	eq
 8000d16:	4770      	bxeq	lr
 8000d18:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8000d1c:	4601      	mov	r1, r0
 8000d1e:	f04f 0000 	mov.w	r0, #0
 8000d22:	e01c      	b.n	8000d5e <__aeabi_l2f+0x2a>

08000d24 <__aeabi_ul2f>:
 8000d24:	ea50 0201 	orrs.w	r2, r0, r1
 8000d28:	bf08      	it	eq
 8000d2a:	4770      	bxeq	lr
 8000d2c:	f04f 0300 	mov.w	r3, #0
 8000d30:	e00a      	b.n	8000d48 <__aeabi_l2f+0x14>
 8000d32:	bf00      	nop

08000d34 <__aeabi_l2f>:
 8000d34:	ea50 0201 	orrs.w	r2, r0, r1
 8000d38:	bf08      	it	eq
 8000d3a:	4770      	bxeq	lr
 8000d3c:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8000d40:	d502      	bpl.n	8000d48 <__aeabi_l2f+0x14>
 8000d42:	4240      	negs	r0, r0
 8000d44:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000d48:	ea5f 0c01 	movs.w	ip, r1
 8000d4c:	bf02      	ittt	eq
 8000d4e:	4684      	moveq	ip, r0
 8000d50:	4601      	moveq	r1, r0
 8000d52:	2000      	moveq	r0, #0
 8000d54:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8000d58:	bf08      	it	eq
 8000d5a:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8000d5e:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8000d62:	fabc f28c 	clz	r2, ip
 8000d66:	3a08      	subs	r2, #8
 8000d68:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000d6c:	db10      	blt.n	8000d90 <__aeabi_l2f+0x5c>
 8000d6e:	fa01 fc02 	lsl.w	ip, r1, r2
 8000d72:	4463      	add	r3, ip
 8000d74:	fa00 fc02 	lsl.w	ip, r0, r2
 8000d78:	f1c2 0220 	rsb	r2, r2, #32
 8000d7c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000d80:	fa20 f202 	lsr.w	r2, r0, r2
 8000d84:	eb43 0002 	adc.w	r0, r3, r2
 8000d88:	bf08      	it	eq
 8000d8a:	f020 0001 	biceq.w	r0, r0, #1
 8000d8e:	4770      	bx	lr
 8000d90:	f102 0220 	add.w	r2, r2, #32
 8000d94:	fa01 fc02 	lsl.w	ip, r1, r2
 8000d98:	f1c2 0220 	rsb	r2, r2, #32
 8000d9c:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8000da0:	fa21 f202 	lsr.w	r2, r1, r2
 8000da4:	eb43 0002 	adc.w	r0, r3, r2
 8000da8:	bf08      	it	eq
 8000daa:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000dae:	4770      	bx	lr

08000db0 <__aeabi_fmul>:
 8000db0:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000db4:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000db8:	bf1e      	ittt	ne
 8000dba:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000dbe:	ea92 0f0c 	teqne	r2, ip
 8000dc2:	ea93 0f0c 	teqne	r3, ip
 8000dc6:	d06f      	beq.n	8000ea8 <__aeabi_fmul+0xf8>
 8000dc8:	441a      	add	r2, r3
 8000dca:	ea80 0c01 	eor.w	ip, r0, r1
 8000dce:	0240      	lsls	r0, r0, #9
 8000dd0:	bf18      	it	ne
 8000dd2:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8000dd6:	d01e      	beq.n	8000e16 <__aeabi_fmul+0x66>
 8000dd8:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000ddc:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8000de0:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8000de4:	fba0 3101 	umull	r3, r1, r0, r1
 8000de8:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000dec:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8000df0:	bf3e      	ittt	cc
 8000df2:	0049      	lslcc	r1, r1, #1
 8000df4:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8000df8:	005b      	lslcc	r3, r3, #1
 8000dfa:	ea40 0001 	orr.w	r0, r0, r1
 8000dfe:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8000e02:	2afd      	cmp	r2, #253	; 0xfd
 8000e04:	d81d      	bhi.n	8000e42 <__aeabi_fmul+0x92>
 8000e06:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8000e0a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000e0e:	bf08      	it	eq
 8000e10:	f020 0001 	biceq.w	r0, r0, #1
 8000e14:	4770      	bx	lr
 8000e16:	f090 0f00 	teq	r0, #0
 8000e1a:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000e1e:	bf08      	it	eq
 8000e20:	0249      	lsleq	r1, r1, #9
 8000e22:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000e26:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 8000e2a:	3a7f      	subs	r2, #127	; 0x7f
 8000e2c:	bfc2      	ittt	gt
 8000e2e:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000e32:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000e36:	4770      	bxgt	lr
 8000e38:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000e3c:	f04f 0300 	mov.w	r3, #0
 8000e40:	3a01      	subs	r2, #1
 8000e42:	dc5d      	bgt.n	8000f00 <__aeabi_fmul+0x150>
 8000e44:	f112 0f19 	cmn.w	r2, #25
 8000e48:	bfdc      	itt	le
 8000e4a:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8000e4e:	4770      	bxle	lr
 8000e50:	f1c2 0200 	rsb	r2, r2, #0
 8000e54:	0041      	lsls	r1, r0, #1
 8000e56:	fa21 f102 	lsr.w	r1, r1, r2
 8000e5a:	f1c2 0220 	rsb	r2, r2, #32
 8000e5e:	fa00 fc02 	lsl.w	ip, r0, r2
 8000e62:	ea5f 0031 	movs.w	r0, r1, rrx
 8000e66:	f140 0000 	adc.w	r0, r0, #0
 8000e6a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8000e6e:	bf08      	it	eq
 8000e70:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000e74:	4770      	bx	lr
 8000e76:	f092 0f00 	teq	r2, #0
 8000e7a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000e7e:	bf02      	ittt	eq
 8000e80:	0040      	lsleq	r0, r0, #1
 8000e82:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000e86:	3a01      	subeq	r2, #1
 8000e88:	d0f9      	beq.n	8000e7e <__aeabi_fmul+0xce>
 8000e8a:	ea40 000c 	orr.w	r0, r0, ip
 8000e8e:	f093 0f00 	teq	r3, #0
 8000e92:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000e96:	bf02      	ittt	eq
 8000e98:	0049      	lsleq	r1, r1, #1
 8000e9a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000e9e:	3b01      	subeq	r3, #1
 8000ea0:	d0f9      	beq.n	8000e96 <__aeabi_fmul+0xe6>
 8000ea2:	ea41 010c 	orr.w	r1, r1, ip
 8000ea6:	e78f      	b.n	8000dc8 <__aeabi_fmul+0x18>
 8000ea8:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000eac:	ea92 0f0c 	teq	r2, ip
 8000eb0:	bf18      	it	ne
 8000eb2:	ea93 0f0c 	teqne	r3, ip
 8000eb6:	d00a      	beq.n	8000ece <__aeabi_fmul+0x11e>
 8000eb8:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000ebc:	bf18      	it	ne
 8000ebe:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8000ec2:	d1d8      	bne.n	8000e76 <__aeabi_fmul+0xc6>
 8000ec4:	ea80 0001 	eor.w	r0, r0, r1
 8000ec8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000ecc:	4770      	bx	lr
 8000ece:	f090 0f00 	teq	r0, #0
 8000ed2:	bf17      	itett	ne
 8000ed4:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8000ed8:	4608      	moveq	r0, r1
 8000eda:	f091 0f00 	teqne	r1, #0
 8000ede:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8000ee2:	d014      	beq.n	8000f0e <__aeabi_fmul+0x15e>
 8000ee4:	ea92 0f0c 	teq	r2, ip
 8000ee8:	d101      	bne.n	8000eee <__aeabi_fmul+0x13e>
 8000eea:	0242      	lsls	r2, r0, #9
 8000eec:	d10f      	bne.n	8000f0e <__aeabi_fmul+0x15e>
 8000eee:	ea93 0f0c 	teq	r3, ip
 8000ef2:	d103      	bne.n	8000efc <__aeabi_fmul+0x14c>
 8000ef4:	024b      	lsls	r3, r1, #9
 8000ef6:	bf18      	it	ne
 8000ef8:	4608      	movne	r0, r1
 8000efa:	d108      	bne.n	8000f0e <__aeabi_fmul+0x15e>
 8000efc:	ea80 0001 	eor.w	r0, r0, r1
 8000f00:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000f04:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000f08:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000f0c:	4770      	bx	lr
 8000f0e:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000f12:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8000f16:	4770      	bx	lr

08000f18 <__aeabi_fdiv>:
 8000f18:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000f1c:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000f20:	bf1e      	ittt	ne
 8000f22:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000f26:	ea92 0f0c 	teqne	r2, ip
 8000f2a:	ea93 0f0c 	teqne	r3, ip
 8000f2e:	d069      	beq.n	8001004 <__aeabi_fdiv+0xec>
 8000f30:	eba2 0203 	sub.w	r2, r2, r3
 8000f34:	ea80 0c01 	eor.w	ip, r0, r1
 8000f38:	0249      	lsls	r1, r1, #9
 8000f3a:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8000f3e:	d037      	beq.n	8000fb0 <__aeabi_fdiv+0x98>
 8000f40:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8000f44:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8000f48:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8000f4c:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000f50:	428b      	cmp	r3, r1
 8000f52:	bf38      	it	cc
 8000f54:	005b      	lslcc	r3, r3, #1
 8000f56:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 8000f5a:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8000f5e:	428b      	cmp	r3, r1
 8000f60:	bf24      	itt	cs
 8000f62:	1a5b      	subcs	r3, r3, r1
 8000f64:	ea40 000c 	orrcs.w	r0, r0, ip
 8000f68:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8000f6c:	bf24      	itt	cs
 8000f6e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8000f72:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000f76:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8000f7a:	bf24      	itt	cs
 8000f7c:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8000f80:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000f84:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8000f88:	bf24      	itt	cs
 8000f8a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8000f8e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000f92:	011b      	lsls	r3, r3, #4
 8000f94:	bf18      	it	ne
 8000f96:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 8000f9a:	d1e0      	bne.n	8000f5e <__aeabi_fdiv+0x46>
 8000f9c:	2afd      	cmp	r2, #253	; 0xfd
 8000f9e:	f63f af50 	bhi.w	8000e42 <__aeabi_fmul+0x92>
 8000fa2:	428b      	cmp	r3, r1
 8000fa4:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000fa8:	bf08      	it	eq
 8000faa:	f020 0001 	biceq.w	r0, r0, #1
 8000fae:	4770      	bx	lr
 8000fb0:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000fb4:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000fb8:	327f      	adds	r2, #127	; 0x7f
 8000fba:	bfc2      	ittt	gt
 8000fbc:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000fc0:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000fc4:	4770      	bxgt	lr
 8000fc6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000fca:	f04f 0300 	mov.w	r3, #0
 8000fce:	3a01      	subs	r2, #1
 8000fd0:	e737      	b.n	8000e42 <__aeabi_fmul+0x92>
 8000fd2:	f092 0f00 	teq	r2, #0
 8000fd6:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000fda:	bf02      	ittt	eq
 8000fdc:	0040      	lsleq	r0, r0, #1
 8000fde:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000fe2:	3a01      	subeq	r2, #1
 8000fe4:	d0f9      	beq.n	8000fda <__aeabi_fdiv+0xc2>
 8000fe6:	ea40 000c 	orr.w	r0, r0, ip
 8000fea:	f093 0f00 	teq	r3, #0
 8000fee:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000ff2:	bf02      	ittt	eq
 8000ff4:	0049      	lsleq	r1, r1, #1
 8000ff6:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000ffa:	3b01      	subeq	r3, #1
 8000ffc:	d0f9      	beq.n	8000ff2 <__aeabi_fdiv+0xda>
 8000ffe:	ea41 010c 	orr.w	r1, r1, ip
 8001002:	e795      	b.n	8000f30 <__aeabi_fdiv+0x18>
 8001004:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8001008:	ea92 0f0c 	teq	r2, ip
 800100c:	d108      	bne.n	8001020 <__aeabi_fdiv+0x108>
 800100e:	0242      	lsls	r2, r0, #9
 8001010:	f47f af7d 	bne.w	8000f0e <__aeabi_fmul+0x15e>
 8001014:	ea93 0f0c 	teq	r3, ip
 8001018:	f47f af70 	bne.w	8000efc <__aeabi_fmul+0x14c>
 800101c:	4608      	mov	r0, r1
 800101e:	e776      	b.n	8000f0e <__aeabi_fmul+0x15e>
 8001020:	ea93 0f0c 	teq	r3, ip
 8001024:	d104      	bne.n	8001030 <__aeabi_fdiv+0x118>
 8001026:	024b      	lsls	r3, r1, #9
 8001028:	f43f af4c 	beq.w	8000ec4 <__aeabi_fmul+0x114>
 800102c:	4608      	mov	r0, r1
 800102e:	e76e      	b.n	8000f0e <__aeabi_fmul+0x15e>
 8001030:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8001034:	bf18      	it	ne
 8001036:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 800103a:	d1ca      	bne.n	8000fd2 <__aeabi_fdiv+0xba>
 800103c:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8001040:	f47f af5c 	bne.w	8000efc <__aeabi_fmul+0x14c>
 8001044:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 8001048:	f47f af3c 	bne.w	8000ec4 <__aeabi_fmul+0x114>
 800104c:	e75f      	b.n	8000f0e <__aeabi_fmul+0x15e>
 800104e:	bf00      	nop

08001050 <__cpu_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8001050:	bf00      	nop
 8001052:	4770      	bx	lr
	...

08001060 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8001060:	bf00      	nop
 8001062:	4770      	bx	lr
	...

08001070 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
 8001070:	e7fe      	b.n	8001070 <__default_exit>
 8001072:	bf00      	nop
	...

08001080 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001080:	b084      	sub	sp, #16
#if CRT0_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8001082:	4b17      	ldr	r3, [pc, #92]	; (80010e0 <__init_ram_areas+0x60>)
 8001084:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8001086:	9b03      	ldr	r3, [sp, #12]
 8001088:	681b      	ldr	r3, [r3, #0]
 800108a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800108c:	9b03      	ldr	r3, [sp, #12]
 800108e:	685b      	ldr	r3, [r3, #4]
 8001090:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001092:	e009      	b.n	80010a8 <__init_ram_areas+0x28>
      *p = *tp;
 8001094:	9b02      	ldr	r3, [sp, #8]
 8001096:	681a      	ldr	r2, [r3, #0]
 8001098:	9b01      	ldr	r3, [sp, #4]
 800109a:	601a      	str	r2, [r3, #0]
      p++;
 800109c:	9b01      	ldr	r3, [sp, #4]
 800109e:	3304      	adds	r3, #4
 80010a0:	9301      	str	r3, [sp, #4]
      tp++;
 80010a2:	9b02      	ldr	r3, [sp, #8]
 80010a4:	3304      	adds	r3, #4
 80010a6:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 80010a8:	9b03      	ldr	r3, [sp, #12]
 80010aa:	689b      	ldr	r3, [r3, #8]
 80010ac:	9a01      	ldr	r2, [sp, #4]
 80010ae:	429a      	cmp	r2, r3
 80010b0:	d3f0      	bcc.n	8001094 <__init_ram_areas+0x14>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80010b2:	e005      	b.n	80010c0 <__init_ram_areas+0x40>
      *p = 0;
 80010b4:	9b01      	ldr	r3, [sp, #4]
 80010b6:	2200      	movs	r2, #0
 80010b8:	601a      	str	r2, [r3, #0]
      p++;
 80010ba:	9b01      	ldr	r3, [sp, #4]
 80010bc:	3304      	adds	r3, #4
 80010be:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 80010c0:	9b03      	ldr	r3, [sp, #12]
 80010c2:	68db      	ldr	r3, [r3, #12]
 80010c4:	9a01      	ldr	r2, [sp, #4]
 80010c6:	429a      	cmp	r2, r3
 80010c8:	d3f4      	bcc.n	80010b4 <__init_ram_areas+0x34>
    }
    rap++;
 80010ca:	9b03      	ldr	r3, [sp, #12]
 80010cc:	3310      	adds	r3, #16
 80010ce:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 80010d0:	9b03      	ldr	r3, [sp, #12]
 80010d2:	4a04      	ldr	r2, [pc, #16]	; (80010e4 <__init_ram_areas+0x64>)
 80010d4:	4293      	cmp	r3, r2
 80010d6:	d3d6      	bcc.n	8001086 <__init_ram_areas+0x6>
#endif
}
 80010d8:	bf00      	nop
 80010da:	bf00      	nop
 80010dc:	b004      	add	sp, #16
 80010de:	4770      	bx	lr
 80010e0:	08006d24 	.word	0x08006d24
 80010e4:	08006da4 	.word	0x08006da4
	...

080010f0 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 80010f0:	bf00      	nop
 80010f2:	4770      	bx	lr
	...

08001100 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8001100:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8001102:	f7ff fff5 	bl	80010f0 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8001106:	f000 ffa3 	bl	8002050 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 800110a:	f001 fc11 	bl	8002930 <_pal_lld_init>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 800110e:	f000 fcb7 	bl	8001a80 <sdInit>
#endif
#if (HAL_USE_TRNG == TRUE) || defined(__DOXYGEN__)
  trngInit();
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
 8001112:	f000 fd5d 	bl	8001bd0 <uartInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8001116:	f002 fadb 	bl	80036d0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 800111a:	f000 f841 	bl	80011a0 <stInit>
#endif
}
 800111e:	bf00      	nop
 8001120:	bd08      	pop	{r3, pc}
 8001122:	bf00      	nop
	...

08001130 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001130:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001134:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8001136:	4618      	mov	r0, r3
 8001138:	4770      	bx	lr
 800113a:	bf00      	nop
 800113c:	0000      	movs	r0, r0
	...

08001140 <st_lld_start_alarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {
 8001140:	b082      	sub	sp, #8
 8001142:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8001144:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001148:	9b01      	ldr	r3, [sp, #4]
 800114a:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800114c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001150:	2200      	movs	r2, #0
 8001152:	611a      	str	r2, [r3, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001154:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001158:	2202      	movs	r2, #2
 800115a:	60da      	str	r2, [r3, #12]
#else
  STM32_ST_TIM->DIER  |= STM32_TIM_DIER_CC1IE;
#endif
}
 800115c:	bf00      	nop
 800115e:	b002      	add	sp, #8
 8001160:	4770      	bx	lr
 8001162:	bf00      	nop
	...

08001170 <st_lld_stop_alarm>:
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 8001170:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001174:	2200      	movs	r2, #0
 8001176:	60da      	str	r2, [r3, #12]
#else
 STM32_ST_TIM->DIER &= ~STM32_TIM_DIER_CC1IE;
#endif
}
 8001178:	bf00      	nop
 800117a:	4770      	bx	lr
 800117c:	0000      	movs	r0, r0
	...

08001180 <st_lld_set_alarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {
 8001180:	b082      	sub	sp, #8
 8001182:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8001184:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001188:	9b01      	ldr	r3, [sp, #4]
 800118a:	6353      	str	r3, [r2, #52]	; 0x34
}
 800118c:	bf00      	nop
 800118e:	b002      	add	sp, #8
 8001190:	4770      	bx	lr
 8001192:	bf00      	nop
	...

080011a0 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 80011a0:	b508      	push	{r3, lr}

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
 80011a2:	f001 fcbd 	bl	8002b20 <st_lld_init>
}
 80011a6:	bf00      	nop
 80011a8:	bd08      	pop	{r3, pc}
 80011aa:	bf00      	nop
 80011ac:	0000      	movs	r0, r0
	...

080011b0 <stGetCounter>:
 *
 * @return              The counter value.
 *
 * @api
 */
systime_t stGetCounter(void) {
 80011b0:	b508      	push	{r3, lr}

  return st_lld_get_counter();
 80011b2:	f7ff ffbd 	bl	8001130 <st_lld_get_counter>
 80011b6:	4603      	mov	r3, r0
}
 80011b8:	4618      	mov	r0, r3
 80011ba:	bd08      	pop	{r3, pc}
 80011bc:	0000      	movs	r0, r0
	...

080011c0 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 80011c0:	b500      	push	{lr}
 80011c2:	b083      	sub	sp, #12
 80011c4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 80011c6:	9801      	ldr	r0, [sp, #4]
 80011c8:	f7ff ffba 	bl	8001140 <st_lld_start_alarm>
}
 80011cc:	bf00      	nop
 80011ce:	b003      	add	sp, #12
 80011d0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080011e0 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 80011e0:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 80011e2:	f7ff ffc5 	bl	8001170 <st_lld_stop_alarm>
}
 80011e6:	bf00      	nop
 80011e8:	bd08      	pop	{r3, pc}
 80011ea:	bf00      	nop
 80011ec:	0000      	movs	r0, r0
	...

080011f0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 80011f0:	b500      	push	{lr}
 80011f2:	b083      	sub	sp, #12
 80011f4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 80011f6:	9801      	ldr	r0, [sp, #4]
 80011f8:	f7ff ffc2 	bl	8001180 <st_lld_set_alarm>
}
 80011fc:	bf00      	nop
 80011fe:	b003      	add	sp, #12
 8001200:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001210 <ch_queue_init.lto_priv.1>:
 *
 * @param[out] qp       pointer to the queue header
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {
 8001210:	b082      	sub	sp, #8
 8001212:	9001      	str	r0, [sp, #4]

  qp->next = qp;
 8001214:	9b01      	ldr	r3, [sp, #4]
 8001216:	9a01      	ldr	r2, [sp, #4]
 8001218:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800121a:	9b01      	ldr	r3, [sp, #4]
 800121c:	9a01      	ldr	r2, [sp, #4]
 800121e:	605a      	str	r2, [r3, #4]
}
 8001220:	bf00      	nop
 8001222:	b002      	add	sp, #8
 8001224:	4770      	bx	lr
 8001226:	bf00      	nop
	...

08001230 <chSysLock.lto_priv.1>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to disabling interrupts.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001230:	b082      	sub	sp, #8
 8001232:	2320      	movs	r3, #32
 8001234:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001236:	9b01      	ldr	r3, [sp, #4]
 8001238:	f383 8811 	msr	BASEPRI, r3
}
 800123c:	bf00      	nop
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800123e:	bf00      	nop

  port_lock();
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
}
 8001240:	bf00      	nop
 8001242:	b002      	add	sp, #8
 8001244:	4770      	bx	lr
 8001246:	bf00      	nop
	...

08001250 <chSysUnlock.lto_priv.1>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to enabling interrupts.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001250:	b082      	sub	sp, #8
 8001252:	2300      	movs	r3, #0
 8001254:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001256:	9b01      	ldr	r3, [sp, #4]
 8001258:	f383 8811 	msr	BASEPRI, r3
}
 800125c:	bf00      	nop
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800125e:	bf00      	nop
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
              (currcore->rlist.current->hdr.pqueue.prio >= currcore->rlist.pqueue.next->prio),
              "priority order violation");

  port_unlock();
}
 8001260:	bf00      	nop
 8001262:	b002      	add	sp, #8
 8001264:	4770      	bx	lr
 8001266:	bf00      	nop
	...

08001270 <chThdQueueObjectInit.lto_priv.1>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8001270:	b500      	push	{lr}
 8001272:	b083      	sub	sp, #12
 8001274:	9001      	str	r0, [sp, #4]

  ch_queue_init(&tqp->queue);
 8001276:	9b01      	ldr	r3, [sp, #4]
 8001278:	4618      	mov	r0, r3
 800127a:	f7ff ffc9 	bl	8001210 <ch_queue_init.lto_priv.1>
}
 800127e:	bf00      	nop
 8001280:	b003      	add	sp, #12
 8001282:	f85d fb04 	ldr.w	pc, [sp], #4
 8001286:	bf00      	nop
	...

08001290 <osalSysLock.lto_priv.1>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8001290:	b508      	push	{r3, lr}

  chSysLock();
 8001292:	f7ff ffcd 	bl	8001230 <chSysLock.lto_priv.1>
}
 8001296:	bf00      	nop
 8001298:	bd08      	pop	{r3, pc}
 800129a:	bf00      	nop
 800129c:	0000      	movs	r0, r0
	...

080012a0 <osalSysUnlock.lto_priv.1>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80012a0:	b508      	push	{r3, lr}

  chSysUnlock();
 80012a2:	f7ff ffd5 	bl	8001250 <chSysUnlock.lto_priv.1>
}
 80012a6:	bf00      	nop
 80012a8:	bd08      	pop	{r3, pc}
 80012aa:	bf00      	nop
 80012ac:	0000      	movs	r0, r0
	...

080012b0 <osalThreadQueueObjectInit.lto_priv.1>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 80012b0:	b500      	push	{lr}
 80012b2:	b083      	sub	sp, #12
 80012b4:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 80012b6:	9801      	ldr	r0, [sp, #4]
 80012b8:	f7ff ffda 	bl	8001270 <chThdQueueObjectInit.lto_priv.1>
}
 80012bc:	bf00      	nop
 80012be:	b003      	add	sp, #12
 80012c0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080012d0 <osalThreadEnqueueTimeoutS.lto_priv.1>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {
 80012d0:	b500      	push	{lr}
 80012d2:	b083      	sub	sp, #12
 80012d4:	9001      	str	r0, [sp, #4]
 80012d6:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, timeout);
 80012d8:	9900      	ldr	r1, [sp, #0]
 80012da:	9801      	ldr	r0, [sp, #4]
 80012dc:	f003 fab0 	bl	8004840 <chThdEnqueueTimeoutS>
 80012e0:	4603      	mov	r3, r0
}
 80012e2:	4618      	mov	r0, r3
 80012e4:	b003      	add	sp, #12
 80012e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80012ea:	bf00      	nop
 80012ec:	0000      	movs	r0, r0
	...

080012f0 <osalThreadDequeueNextI.lto_priv.1>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80012f0:	b500      	push	{lr}
 80012f2:	b083      	sub	sp, #12
 80012f4:	9001      	str	r0, [sp, #4]
 80012f6:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 80012f8:	9900      	ldr	r1, [sp, #0]
 80012fa:	9801      	ldr	r0, [sp, #4]
 80012fc:	f003 fac0 	bl	8004880 <chThdDequeueNextI>
}
 8001300:	bf00      	nop
 8001302:	b003      	add	sp, #12
 8001304:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001310 <iq_read>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 8001310:	b500      	push	{lr}
 8001312:	b087      	sub	sp, #28
 8001314:	9003      	str	r0, [sp, #12]
 8001316:	9102      	str	r1, [sp, #8]
 8001318:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > iqGetFullI(iqp)) {
 800131a:	9b03      	ldr	r3, [sp, #12]
 800131c:	689b      	ldr	r3, [r3, #8]
 800131e:	9a01      	ldr	r2, [sp, #4]
 8001320:	429a      	cmp	r2, r3
 8001322:	d902      	bls.n	800132a <iq_read+0x1a>
    n = iqGetFullI(iqp);
 8001324:	9b03      	ldr	r3, [sp, #12]
 8001326:	689b      	ldr	r3, [r3, #8]
 8001328:	9301      	str	r3, [sp, #4]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 800132a:	9b03      	ldr	r3, [sp, #12]
 800132c:	691a      	ldr	r2, [r3, #16]
 800132e:	9b03      	ldr	r3, [sp, #12]
 8001330:	699b      	ldr	r3, [r3, #24]
 8001332:	1ad3      	subs	r3, r2, r3
 8001334:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  if (n < s1) {
 8001336:	9a01      	ldr	r2, [sp, #4]
 8001338:	9b05      	ldr	r3, [sp, #20]
 800133a:	429a      	cmp	r2, r3
 800133c:	d20d      	bcs.n	800135a <iq_read+0x4a>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 800133e:	9b03      	ldr	r3, [sp, #12]
 8001340:	699b      	ldr	r3, [r3, #24]
 8001342:	9a01      	ldr	r2, [sp, #4]
 8001344:	4619      	mov	r1, r3
 8001346:	9802      	ldr	r0, [sp, #8]
 8001348:	f7fe ffe0 	bl	800030c <memcpy>
    iqp->q_rdptr += n;
 800134c:	9b03      	ldr	r3, [sp, #12]
 800134e:	699a      	ldr	r2, [r3, #24]
 8001350:	9b01      	ldr	r3, [sp, #4]
 8001352:	441a      	add	r2, r3
 8001354:	9b03      	ldr	r3, [sp, #12]
 8001356:	619a      	str	r2, [r3, #24]
 8001358:	e02b      	b.n	80013b2 <iq_read+0xa2>
  }
  else if (n > s1) {
 800135a:	9a01      	ldr	r2, [sp, #4]
 800135c:	9b05      	ldr	r3, [sp, #20]
 800135e:	429a      	cmp	r2, r3
 8001360:	d91c      	bls.n	800139c <iq_read+0x8c>
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8001362:	9b03      	ldr	r3, [sp, #12]
 8001364:	699b      	ldr	r3, [r3, #24]
 8001366:	9a05      	ldr	r2, [sp, #20]
 8001368:	4619      	mov	r1, r3
 800136a:	9802      	ldr	r0, [sp, #8]
 800136c:	f7fe ffce 	bl	800030c <memcpy>
    bp += s1;
 8001370:	9a02      	ldr	r2, [sp, #8]
 8001372:	9b05      	ldr	r3, [sp, #20]
 8001374:	4413      	add	r3, r2
 8001376:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
 8001378:	9a01      	ldr	r2, [sp, #4]
 800137a:	9b05      	ldr	r3, [sp, #20]
 800137c:	1ad3      	subs	r3, r2, r3
 800137e:	9304      	str	r3, [sp, #16]
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8001380:	9b03      	ldr	r3, [sp, #12]
 8001382:	68db      	ldr	r3, [r3, #12]
 8001384:	9a04      	ldr	r2, [sp, #16]
 8001386:	4619      	mov	r1, r3
 8001388:	9802      	ldr	r0, [sp, #8]
 800138a:	f7fe ffbf 	bl	800030c <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 800138e:	9b03      	ldr	r3, [sp, #12]
 8001390:	68da      	ldr	r2, [r3, #12]
 8001392:	9b04      	ldr	r3, [sp, #16]
 8001394:	441a      	add	r2, r3
 8001396:	9b03      	ldr	r3, [sp, #12]
 8001398:	619a      	str	r2, [r3, #24]
 800139a:	e00a      	b.n	80013b2 <iq_read+0xa2>
  }
  else {
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 800139c:	9b03      	ldr	r3, [sp, #12]
 800139e:	699b      	ldr	r3, [r3, #24]
 80013a0:	9a01      	ldr	r2, [sp, #4]
 80013a2:	4619      	mov	r1, r3
 80013a4:	9802      	ldr	r0, [sp, #8]
 80013a6:	f7fe ffb1 	bl	800030c <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 80013aa:	9b03      	ldr	r3, [sp, #12]
 80013ac:	68da      	ldr	r2, [r3, #12]
 80013ae:	9b03      	ldr	r3, [sp, #12]
 80013b0:	619a      	str	r2, [r3, #24]
  }

  iqp->q_counter -= n;
 80013b2:	9b03      	ldr	r3, [sp, #12]
 80013b4:	689a      	ldr	r2, [r3, #8]
 80013b6:	9b01      	ldr	r3, [sp, #4]
 80013b8:	1ad2      	subs	r2, r2, r3
 80013ba:	9b03      	ldr	r3, [sp, #12]
 80013bc:	609a      	str	r2, [r3, #8]
  return n;
 80013be:	9b01      	ldr	r3, [sp, #4]
}
 80013c0:	4618      	mov	r0, r3
 80013c2:	b007      	add	sp, #28
 80013c4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080013d0 <oq_write>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 80013d0:	b500      	push	{lr}
 80013d2:	b087      	sub	sp, #28
 80013d4:	9003      	str	r0, [sp, #12]
 80013d6:	9102      	str	r1, [sp, #8]
 80013d8:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be written in a single atomic operation.*/
  if (n > oqGetEmptyI(oqp)) {
 80013da:	9b03      	ldr	r3, [sp, #12]
 80013dc:	689b      	ldr	r3, [r3, #8]
 80013de:	9a01      	ldr	r2, [sp, #4]
 80013e0:	429a      	cmp	r2, r3
 80013e2:	d902      	bls.n	80013ea <oq_write+0x1a>
    n = oqGetEmptyI(oqp);
 80013e4:	9b03      	ldr	r3, [sp, #12]
 80013e6:	689b      	ldr	r3, [r3, #8]
 80013e8:	9301      	str	r3, [sp, #4]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 80013ea:	9b03      	ldr	r3, [sp, #12]
 80013ec:	691a      	ldr	r2, [r3, #16]
 80013ee:	9b03      	ldr	r3, [sp, #12]
 80013f0:	695b      	ldr	r3, [r3, #20]
 80013f2:	1ad3      	subs	r3, r2, r3
 80013f4:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  if (n < s1) {
 80013f6:	9a01      	ldr	r2, [sp, #4]
 80013f8:	9b05      	ldr	r3, [sp, #20]
 80013fa:	429a      	cmp	r2, r3
 80013fc:	d20d      	bcs.n	800141a <oq_write+0x4a>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 80013fe:	9b03      	ldr	r3, [sp, #12]
 8001400:	695b      	ldr	r3, [r3, #20]
 8001402:	9a01      	ldr	r2, [sp, #4]
 8001404:	9902      	ldr	r1, [sp, #8]
 8001406:	4618      	mov	r0, r3
 8001408:	f7fe ff80 	bl	800030c <memcpy>
    oqp->q_wrptr += n;
 800140c:	9b03      	ldr	r3, [sp, #12]
 800140e:	695a      	ldr	r2, [r3, #20]
 8001410:	9b01      	ldr	r3, [sp, #4]
 8001412:	441a      	add	r2, r3
 8001414:	9b03      	ldr	r3, [sp, #12]
 8001416:	615a      	str	r2, [r3, #20]
 8001418:	e02b      	b.n	8001472 <oq_write+0xa2>
  }
  else if (n > s1) {
 800141a:	9a01      	ldr	r2, [sp, #4]
 800141c:	9b05      	ldr	r3, [sp, #20]
 800141e:	429a      	cmp	r2, r3
 8001420:	d91c      	bls.n	800145c <oq_write+0x8c>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8001422:	9b03      	ldr	r3, [sp, #12]
 8001424:	695b      	ldr	r3, [r3, #20]
 8001426:	9a05      	ldr	r2, [sp, #20]
 8001428:	9902      	ldr	r1, [sp, #8]
 800142a:	4618      	mov	r0, r3
 800142c:	f7fe ff6e 	bl	800030c <memcpy>
    bp += s1;
 8001430:	9a02      	ldr	r2, [sp, #8]
 8001432:	9b05      	ldr	r3, [sp, #20]
 8001434:	4413      	add	r3, r2
 8001436:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
 8001438:	9a01      	ldr	r2, [sp, #4]
 800143a:	9b05      	ldr	r3, [sp, #20]
 800143c:	1ad3      	subs	r3, r2, r3
 800143e:	9304      	str	r3, [sp, #16]
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8001440:	9b03      	ldr	r3, [sp, #12]
 8001442:	68db      	ldr	r3, [r3, #12]
 8001444:	9a04      	ldr	r2, [sp, #16]
 8001446:	9902      	ldr	r1, [sp, #8]
 8001448:	4618      	mov	r0, r3
 800144a:	f7fe ff5f 	bl	800030c <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 800144e:	9b03      	ldr	r3, [sp, #12]
 8001450:	68da      	ldr	r2, [r3, #12]
 8001452:	9b04      	ldr	r3, [sp, #16]
 8001454:	441a      	add	r2, r3
 8001456:	9b03      	ldr	r3, [sp, #12]
 8001458:	615a      	str	r2, [r3, #20]
 800145a:	e00a      	b.n	8001472 <oq_write+0xa2>
  }
  else {
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 800145c:	9b03      	ldr	r3, [sp, #12]
 800145e:	695b      	ldr	r3, [r3, #20]
 8001460:	9a01      	ldr	r2, [sp, #4]
 8001462:	9902      	ldr	r1, [sp, #8]
 8001464:	4618      	mov	r0, r3
 8001466:	f7fe ff51 	bl	800030c <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 800146a:	9b03      	ldr	r3, [sp, #12]
 800146c:	68da      	ldr	r2, [r3, #12]
 800146e:	9b03      	ldr	r3, [sp, #12]
 8001470:	615a      	str	r2, [r3, #20]
  }

  oqp->q_counter -= n;
 8001472:	9b03      	ldr	r3, [sp, #12]
 8001474:	689a      	ldr	r2, [r3, #8]
 8001476:	9b01      	ldr	r3, [sp, #4]
 8001478:	1ad2      	subs	r2, r2, r3
 800147a:	9b03      	ldr	r3, [sp, #12]
 800147c:	609a      	str	r2, [r3, #8]
  return n;
 800147e:	9b01      	ldr	r3, [sp, #4]
}
 8001480:	4618      	mov	r0, r3
 8001482:	b007      	add	sp, #28
 8001484:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001490 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 8001490:	b500      	push	{lr}
 8001492:	b085      	sub	sp, #20
 8001494:	9003      	str	r0, [sp, #12]
 8001496:	9102      	str	r1, [sp, #8]
 8001498:	9201      	str	r2, [sp, #4]
 800149a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
 800149c:	9b03      	ldr	r3, [sp, #12]
 800149e:	4618      	mov	r0, r3
 80014a0:	f7ff ff06 	bl	80012b0 <osalThreadQueueObjectInit.lto_priv.1>
  iqp->q_counter = 0;
 80014a4:	9b03      	ldr	r3, [sp, #12]
 80014a6:	2200      	movs	r2, #0
 80014a8:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 80014aa:	9b03      	ldr	r3, [sp, #12]
 80014ac:	9a02      	ldr	r2, [sp, #8]
 80014ae:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 80014b0:	9b03      	ldr	r3, [sp, #12]
 80014b2:	9a02      	ldr	r2, [sp, #8]
 80014b4:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 80014b6:	9b03      	ldr	r3, [sp, #12]
 80014b8:	9a02      	ldr	r2, [sp, #8]
 80014ba:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 80014bc:	9a02      	ldr	r2, [sp, #8]
 80014be:	9b01      	ldr	r3, [sp, #4]
 80014c0:	441a      	add	r2, r3
 80014c2:	9b03      	ldr	r3, [sp, #12]
 80014c4:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 80014c6:	9b03      	ldr	r3, [sp, #12]
 80014c8:	9a00      	ldr	r2, [sp, #0]
 80014ca:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 80014cc:	9b03      	ldr	r3, [sp, #12]
 80014ce:	9a06      	ldr	r2, [sp, #24]
 80014d0:	621a      	str	r2, [r3, #32]
}
 80014d2:	bf00      	nop
 80014d4:	b005      	add	sp, #20
 80014d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80014da:	bf00      	nop
 80014dc:	0000      	movs	r0, r0
	...

080014e0 <iqPutI>:
 * @retval MSG_OK       if the operation has been completed with success.
 * @retval MSG_TIMEOUT  if the queue is full.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 80014e0:	b500      	push	{lr}
 80014e2:	b083      	sub	sp, #12
 80014e4:	9001      	str	r0, [sp, #4]
 80014e6:	460b      	mov	r3, r1
 80014e8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();

  /* Queue space check.*/
  if (!iqIsFullI(iqp)) {
 80014ec:	9b01      	ldr	r3, [sp, #4]
 80014ee:	695a      	ldr	r2, [r3, #20]
 80014f0:	9b01      	ldr	r3, [sp, #4]
 80014f2:	699b      	ldr	r3, [r3, #24]
 80014f4:	429a      	cmp	r2, r3
 80014f6:	d105      	bne.n	8001504 <iqPutI+0x24>
 80014f8:	9b01      	ldr	r3, [sp, #4]
 80014fa:	689b      	ldr	r3, [r3, #8]
 80014fc:	2b00      	cmp	r3, #0
 80014fe:	d001      	beq.n	8001504 <iqPutI+0x24>
 8001500:	2301      	movs	r3, #1
 8001502:	e000      	b.n	8001506 <iqPutI+0x26>
 8001504:	2300      	movs	r3, #0
 8001506:	f003 0301 	and.w	r3, r3, #1
 800150a:	b2db      	uxtb	r3, r3
 800150c:	f083 0301 	eor.w	r3, r3, #1
 8001510:	b2db      	uxtb	r3, r3
 8001512:	2b00      	cmp	r3, #0
 8001514:	d01d      	beq.n	8001552 <iqPutI+0x72>
    iqp->q_counter++;
 8001516:	9b01      	ldr	r3, [sp, #4]
 8001518:	689b      	ldr	r3, [r3, #8]
 800151a:	1c5a      	adds	r2, r3, #1
 800151c:	9b01      	ldr	r3, [sp, #4]
 800151e:	609a      	str	r2, [r3, #8]
    *iqp->q_wrptr++ = b;
 8001520:	9b01      	ldr	r3, [sp, #4]
 8001522:	695b      	ldr	r3, [r3, #20]
 8001524:	1c59      	adds	r1, r3, #1
 8001526:	9a01      	ldr	r2, [sp, #4]
 8001528:	6151      	str	r1, [r2, #20]
 800152a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800152e:	701a      	strb	r2, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8001530:	9b01      	ldr	r3, [sp, #4]
 8001532:	695a      	ldr	r2, [r3, #20]
 8001534:	9b01      	ldr	r3, [sp, #4]
 8001536:	691b      	ldr	r3, [r3, #16]
 8001538:	429a      	cmp	r2, r3
 800153a:	d303      	bcc.n	8001544 <iqPutI+0x64>
      iqp->q_wrptr = iqp->q_buffer;
 800153c:	9b01      	ldr	r3, [sp, #4]
 800153e:	68da      	ldr	r2, [r3, #12]
 8001540:	9b01      	ldr	r3, [sp, #4]
 8001542:	615a      	str	r2, [r3, #20]
    }

    osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8001544:	9b01      	ldr	r3, [sp, #4]
 8001546:	2100      	movs	r1, #0
 8001548:	4618      	mov	r0, r3
 800154a:	f7ff fed1 	bl	80012f0 <osalThreadDequeueNextI.lto_priv.1>

    return MSG_OK;
 800154e:	2300      	movs	r3, #0
 8001550:	e001      	b.n	8001556 <iqPutI+0x76>
  }

  return MSG_TIMEOUT;
 8001552:	f04f 33ff 	mov.w	r3, #4294967295
}
 8001556:	4618      	mov	r0, r3
 8001558:	b003      	add	sp, #12
 800155a:	f85d fb04 	ldr.w	pc, [sp], #4
 800155e:	bf00      	nop

08001560 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8001560:	b500      	push	{lr}
 8001562:	b085      	sub	sp, #20
 8001564:	9001      	str	r0, [sp, #4]
 8001566:	9100      	str	r1, [sp, #0]
  uint8_t b;

  osalSysLock();
 8001568:	f7ff fe92 	bl	8001290 <osalSysLock.lto_priv.1>

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 800156c:	e00c      	b.n	8001588 <iqGetTimeout+0x28>
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800156e:	9b01      	ldr	r3, [sp, #4]
 8001570:	9900      	ldr	r1, [sp, #0]
 8001572:	4618      	mov	r0, r3
 8001574:	f7ff feac 	bl	80012d0 <osalThreadEnqueueTimeoutS.lto_priv.1>
 8001578:	9002      	str	r0, [sp, #8]
    if (msg < MSG_OK) {
 800157a:	9b02      	ldr	r3, [sp, #8]
 800157c:	2b00      	cmp	r3, #0
 800157e:	da03      	bge.n	8001588 <iqGetTimeout+0x28>
      osalSysUnlock();
 8001580:	f7ff fe8e 	bl	80012a0 <osalSysUnlock.lto_priv.1>
      return msg;
 8001584:	9b02      	ldr	r3, [sp, #8]
 8001586:	e026      	b.n	80015d6 <iqGetTimeout+0x76>
  while (iqIsEmptyI(iqp)) {
 8001588:	9b01      	ldr	r3, [sp, #4]
 800158a:	689b      	ldr	r3, [r3, #8]
 800158c:	2b00      	cmp	r3, #0
 800158e:	d0ee      	beq.n	800156e <iqGetTimeout+0xe>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8001590:	9b01      	ldr	r3, [sp, #4]
 8001592:	689b      	ldr	r3, [r3, #8]
 8001594:	1e5a      	subs	r2, r3, #1
 8001596:	9b01      	ldr	r3, [sp, #4]
 8001598:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 800159a:	9b01      	ldr	r3, [sp, #4]
 800159c:	699b      	ldr	r3, [r3, #24]
 800159e:	1c59      	adds	r1, r3, #1
 80015a0:	9a01      	ldr	r2, [sp, #4]
 80015a2:	6191      	str	r1, [r2, #24]
 80015a4:	781b      	ldrb	r3, [r3, #0]
 80015a6:	f88d 300f 	strb.w	r3, [sp, #15]
  if (iqp->q_rdptr >= iqp->q_top) {
 80015aa:	9b01      	ldr	r3, [sp, #4]
 80015ac:	699a      	ldr	r2, [r3, #24]
 80015ae:	9b01      	ldr	r3, [sp, #4]
 80015b0:	691b      	ldr	r3, [r3, #16]
 80015b2:	429a      	cmp	r2, r3
 80015b4:	d303      	bcc.n	80015be <iqGetTimeout+0x5e>
    iqp->q_rdptr = iqp->q_buffer;
 80015b6:	9b01      	ldr	r3, [sp, #4]
 80015b8:	68da      	ldr	r2, [r3, #12]
 80015ba:	9b01      	ldr	r3, [sp, #4]
 80015bc:	619a      	str	r2, [r3, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 80015be:	9b01      	ldr	r3, [sp, #4]
 80015c0:	69db      	ldr	r3, [r3, #28]
 80015c2:	2b00      	cmp	r3, #0
 80015c4:	d003      	beq.n	80015ce <iqGetTimeout+0x6e>
    iqp->q_notify(iqp);
 80015c6:	9b01      	ldr	r3, [sp, #4]
 80015c8:	69db      	ldr	r3, [r3, #28]
 80015ca:	9801      	ldr	r0, [sp, #4]
 80015cc:	4798      	blx	r3
  }

  osalSysUnlock();
 80015ce:	f7ff fe67 	bl	80012a0 <osalSysUnlock.lto_priv.1>

  return (msg_t)b;
 80015d2:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 80015d6:	4618      	mov	r0, r3
 80015d8:	b005      	add	sp, #20
 80015da:	f85d fb04 	ldr.w	pc, [sp], #4
 80015de:	bf00      	nop

080015e0 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, sysinterval_t timeout) {
 80015e0:	b500      	push	{lr}
 80015e2:	b089      	sub	sp, #36	; 0x24
 80015e4:	9003      	str	r0, [sp, #12]
 80015e6:	9102      	str	r1, [sp, #8]
 80015e8:	9201      	str	r2, [sp, #4]
 80015ea:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 80015ec:	9b03      	ldr	r3, [sp, #12]
 80015ee:	69db      	ldr	r3, [r3, #28]
 80015f0:	9307      	str	r3, [sp, #28]
  size_t max = n;
 80015f2:	9b01      	ldr	r3, [sp, #4]
 80015f4:	9306      	str	r3, [sp, #24]

  osalDbgCheck(n > 0U);

  osalSysLock();
 80015f6:	f7ff fe4b 	bl	8001290 <osalSysLock.lto_priv.1>

  while (n > 0U) {
 80015fa:	e024      	b.n	8001646 <iqReadTimeout+0x66>
    size_t done;

    done = iq_read(iqp, bp, n);
 80015fc:	9a01      	ldr	r2, [sp, #4]
 80015fe:	9902      	ldr	r1, [sp, #8]
 8001600:	9803      	ldr	r0, [sp, #12]
 8001602:	f7ff fe85 	bl	8001310 <iq_read>
 8001606:	9005      	str	r0, [sp, #20]
    if (done == (size_t)0) {
 8001608:	9b05      	ldr	r3, [sp, #20]
 800160a:	2b00      	cmp	r3, #0
 800160c:	d109      	bne.n	8001622 <iqReadTimeout+0x42>
      msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800160e:	9b03      	ldr	r3, [sp, #12]
 8001610:	9900      	ldr	r1, [sp, #0]
 8001612:	4618      	mov	r0, r3
 8001614:	f7ff fe5c 	bl	80012d0 <osalThreadEnqueueTimeoutS.lto_priv.1>
 8001618:	9004      	str	r0, [sp, #16]

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 800161a:	9b04      	ldr	r3, [sp, #16]
 800161c:	2b00      	cmp	r3, #0
 800161e:	d012      	beq.n	8001646 <iqReadTimeout+0x66>
        break;
 8001620:	e014      	b.n	800164c <iqReadTimeout+0x6c>
      }
    }
    else {
      /* Inform the low side that the queue has at least one empty slot
         available.*/
      if (nfy != NULL) {
 8001622:	9b07      	ldr	r3, [sp, #28]
 8001624:	2b00      	cmp	r3, #0
 8001626:	d002      	beq.n	800162e <iqReadTimeout+0x4e>
        nfy(iqp);
 8001628:	9b07      	ldr	r3, [sp, #28]
 800162a:	9803      	ldr	r0, [sp, #12]
 800162c:	4798      	blx	r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();
 800162e:	f7ff fe37 	bl	80012a0 <osalSysUnlock.lto_priv.1>

      n  -= done;
 8001632:	9a01      	ldr	r2, [sp, #4]
 8001634:	9b05      	ldr	r3, [sp, #20]
 8001636:	1ad3      	subs	r3, r2, r3
 8001638:	9301      	str	r3, [sp, #4]
      bp += done;
 800163a:	9a02      	ldr	r2, [sp, #8]
 800163c:	9b05      	ldr	r3, [sp, #20]
 800163e:	4413      	add	r3, r2
 8001640:	9302      	str	r3, [sp, #8]

      osalSysLock();
 8001642:	f7ff fe25 	bl	8001290 <osalSysLock.lto_priv.1>
  while (n > 0U) {
 8001646:	9b01      	ldr	r3, [sp, #4]
 8001648:	2b00      	cmp	r3, #0
 800164a:	d1d7      	bne.n	80015fc <iqReadTimeout+0x1c>
    }
  }

  osalSysUnlock();
 800164c:	f7ff fe28 	bl	80012a0 <osalSysUnlock.lto_priv.1>
  return max - n;
 8001650:	9a06      	ldr	r2, [sp, #24]
 8001652:	9b01      	ldr	r3, [sp, #4]
 8001654:	1ad3      	subs	r3, r2, r3
}
 8001656:	4618      	mov	r0, r3
 8001658:	b009      	add	sp, #36	; 0x24
 800165a:	f85d fb04 	ldr.w	pc, [sp], #4
 800165e:	bf00      	nop

08001660 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 8001660:	b500      	push	{lr}
 8001662:	b085      	sub	sp, #20
 8001664:	9003      	str	r0, [sp, #12]
 8001666:	9102      	str	r1, [sp, #8]
 8001668:	9201      	str	r2, [sp, #4]
 800166a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
 800166c:	9b03      	ldr	r3, [sp, #12]
 800166e:	4618      	mov	r0, r3
 8001670:	f7ff fe1e 	bl	80012b0 <osalThreadQueueObjectInit.lto_priv.1>
  oqp->q_counter = size;
 8001674:	9b03      	ldr	r3, [sp, #12]
 8001676:	9a01      	ldr	r2, [sp, #4]
 8001678:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 800167a:	9b03      	ldr	r3, [sp, #12]
 800167c:	9a02      	ldr	r2, [sp, #8]
 800167e:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8001680:	9b03      	ldr	r3, [sp, #12]
 8001682:	9a02      	ldr	r2, [sp, #8]
 8001684:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8001686:	9b03      	ldr	r3, [sp, #12]
 8001688:	9a02      	ldr	r2, [sp, #8]
 800168a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 800168c:	9a02      	ldr	r2, [sp, #8]
 800168e:	9b01      	ldr	r3, [sp, #4]
 8001690:	441a      	add	r2, r3
 8001692:	9b03      	ldr	r3, [sp, #12]
 8001694:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8001696:	9b03      	ldr	r3, [sp, #12]
 8001698:	9a00      	ldr	r2, [sp, #0]
 800169a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 800169c:	9b03      	ldr	r3, [sp, #12]
 800169e:	9a06      	ldr	r2, [sp, #24]
 80016a0:	621a      	str	r2, [r3, #32]
}
 80016a2:	bf00      	nop
 80016a4:	b005      	add	sp, #20
 80016a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80016aa:	bf00      	nop
 80016ac:	0000      	movs	r0, r0
	...

080016b0 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 80016b0:	b500      	push	{lr}
 80016b2:	b087      	sub	sp, #28
 80016b4:	9003      	str	r0, [sp, #12]
 80016b6:	460b      	mov	r3, r1
 80016b8:	9201      	str	r2, [sp, #4]
 80016ba:	f88d 300b 	strb.w	r3, [sp, #11]

  osalSysLock();
 80016be:	f7ff fde7 	bl	8001290 <osalSysLock.lto_priv.1>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 80016c2:	e00c      	b.n	80016de <oqPutTimeout+0x2e>
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 80016c4:	9b03      	ldr	r3, [sp, #12]
 80016c6:	9901      	ldr	r1, [sp, #4]
 80016c8:	4618      	mov	r0, r3
 80016ca:	f7ff fe01 	bl	80012d0 <osalThreadEnqueueTimeoutS.lto_priv.1>
 80016ce:	9005      	str	r0, [sp, #20]
    if (msg < MSG_OK) {
 80016d0:	9b05      	ldr	r3, [sp, #20]
 80016d2:	2b00      	cmp	r3, #0
 80016d4:	da03      	bge.n	80016de <oqPutTimeout+0x2e>
      osalSysUnlock();
 80016d6:	f7ff fde3 	bl	80012a0 <osalSysUnlock.lto_priv.1>
      return msg;
 80016da:	9b05      	ldr	r3, [sp, #20]
 80016dc:	e025      	b.n	800172a <oqPutTimeout+0x7a>
  while (oqIsFullI(oqp)) {
 80016de:	9b03      	ldr	r3, [sp, #12]
 80016e0:	689b      	ldr	r3, [r3, #8]
 80016e2:	2b00      	cmp	r3, #0
 80016e4:	d0ee      	beq.n	80016c4 <oqPutTimeout+0x14>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 80016e6:	9b03      	ldr	r3, [sp, #12]
 80016e8:	689b      	ldr	r3, [r3, #8]
 80016ea:	1e5a      	subs	r2, r3, #1
 80016ec:	9b03      	ldr	r3, [sp, #12]
 80016ee:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 80016f0:	9b03      	ldr	r3, [sp, #12]
 80016f2:	695b      	ldr	r3, [r3, #20]
 80016f4:	1c59      	adds	r1, r3, #1
 80016f6:	9a03      	ldr	r2, [sp, #12]
 80016f8:	6151      	str	r1, [r2, #20]
 80016fa:	f89d 200b 	ldrb.w	r2, [sp, #11]
 80016fe:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8001700:	9b03      	ldr	r3, [sp, #12]
 8001702:	695a      	ldr	r2, [r3, #20]
 8001704:	9b03      	ldr	r3, [sp, #12]
 8001706:	691b      	ldr	r3, [r3, #16]
 8001708:	429a      	cmp	r2, r3
 800170a:	d303      	bcc.n	8001714 <oqPutTimeout+0x64>
    oqp->q_wrptr = oqp->q_buffer;
 800170c:	9b03      	ldr	r3, [sp, #12]
 800170e:	68da      	ldr	r2, [r3, #12]
 8001710:	9b03      	ldr	r3, [sp, #12]
 8001712:	615a      	str	r2, [r3, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8001714:	9b03      	ldr	r3, [sp, #12]
 8001716:	69db      	ldr	r3, [r3, #28]
 8001718:	2b00      	cmp	r3, #0
 800171a:	d003      	beq.n	8001724 <oqPutTimeout+0x74>
    oqp->q_notify(oqp);
 800171c:	9b03      	ldr	r3, [sp, #12]
 800171e:	69db      	ldr	r3, [r3, #28]
 8001720:	9803      	ldr	r0, [sp, #12]
 8001722:	4798      	blx	r3
  }

  osalSysUnlock();
 8001724:	f7ff fdbc 	bl	80012a0 <osalSysUnlock.lto_priv.1>

  return MSG_OK;
 8001728:	2300      	movs	r3, #0
}
 800172a:	4618      	mov	r0, r3
 800172c:	b007      	add	sp, #28
 800172e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001732:	bf00      	nop
	...

08001740 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 8001740:	b500      	push	{lr}
 8001742:	b085      	sub	sp, #20
 8001744:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 8001746:	9b01      	ldr	r3, [sp, #4]
 8001748:	695a      	ldr	r2, [r3, #20]
 800174a:	9b01      	ldr	r3, [sp, #4]
 800174c:	699b      	ldr	r3, [r3, #24]
 800174e:	429a      	cmp	r2, r3
 8001750:	d105      	bne.n	800175e <oqGetI+0x1e>
 8001752:	9b01      	ldr	r3, [sp, #4]
 8001754:	689b      	ldr	r3, [r3, #8]
 8001756:	2b00      	cmp	r3, #0
 8001758:	d001      	beq.n	800175e <oqGetI+0x1e>
 800175a:	2301      	movs	r3, #1
 800175c:	e000      	b.n	8001760 <oqGetI+0x20>
 800175e:	2300      	movs	r3, #0
 8001760:	f003 0301 	and.w	r3, r3, #1
 8001764:	b2db      	uxtb	r3, r3
 8001766:	f083 0301 	eor.w	r3, r3, #1
 800176a:	b2db      	uxtb	r3, r3
 800176c:	2b00      	cmp	r3, #0
 800176e:	d01e      	beq.n	80017ae <oqGetI+0x6e>
    uint8_t b;

    oqp->q_counter++;
 8001770:	9b01      	ldr	r3, [sp, #4]
 8001772:	689b      	ldr	r3, [r3, #8]
 8001774:	1c5a      	adds	r2, r3, #1
 8001776:	9b01      	ldr	r3, [sp, #4]
 8001778:	609a      	str	r2, [r3, #8]
    b = *oqp->q_rdptr++;
 800177a:	9b01      	ldr	r3, [sp, #4]
 800177c:	699b      	ldr	r3, [r3, #24]
 800177e:	1c59      	adds	r1, r3, #1
 8001780:	9a01      	ldr	r2, [sp, #4]
 8001782:	6191      	str	r1, [r2, #24]
 8001784:	781b      	ldrb	r3, [r3, #0]
 8001786:	f88d 300f 	strb.w	r3, [sp, #15]
    if (oqp->q_rdptr >= oqp->q_top) {
 800178a:	9b01      	ldr	r3, [sp, #4]
 800178c:	699a      	ldr	r2, [r3, #24]
 800178e:	9b01      	ldr	r3, [sp, #4]
 8001790:	691b      	ldr	r3, [r3, #16]
 8001792:	429a      	cmp	r2, r3
 8001794:	d303      	bcc.n	800179e <oqGetI+0x5e>
      oqp->q_rdptr = oqp->q_buffer;
 8001796:	9b01      	ldr	r3, [sp, #4]
 8001798:	68da      	ldr	r2, [r3, #12]
 800179a:	9b01      	ldr	r3, [sp, #4]
 800179c:	619a      	str	r2, [r3, #24]
    }

    osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 800179e:	9b01      	ldr	r3, [sp, #4]
 80017a0:	2100      	movs	r1, #0
 80017a2:	4618      	mov	r0, r3
 80017a4:	f7ff fda4 	bl	80012f0 <osalThreadDequeueNextI.lto_priv.1>

    return (msg_t)b;
 80017a8:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80017ac:	e001      	b.n	80017b2 <oqGetI+0x72>
  }

  return MSG_TIMEOUT;
 80017ae:	f04f 33ff 	mov.w	r3, #4294967295
}
 80017b2:	4618      	mov	r0, r3
 80017b4:	b005      	add	sp, #20
 80017b6:	f85d fb04 	ldr.w	pc, [sp], #4
 80017ba:	bf00      	nop
 80017bc:	0000      	movs	r0, r0
	...

080017c0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 80017c0:	b500      	push	{lr}
 80017c2:	b089      	sub	sp, #36	; 0x24
 80017c4:	9003      	str	r0, [sp, #12]
 80017c6:	9102      	str	r1, [sp, #8]
 80017c8:	9201      	str	r2, [sp, #4]
 80017ca:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 80017cc:	9b03      	ldr	r3, [sp, #12]
 80017ce:	69db      	ldr	r3, [r3, #28]
 80017d0:	9307      	str	r3, [sp, #28]
  size_t max = n;
 80017d2:	9b01      	ldr	r3, [sp, #4]
 80017d4:	9306      	str	r3, [sp, #24]

  osalDbgCheck(n > 0U);

  osalSysLock();
 80017d6:	f7ff fd5b 	bl	8001290 <osalSysLock.lto_priv.1>

  while (n > 0U) {
 80017da:	e024      	b.n	8001826 <oqWriteTimeout+0x66>
    size_t done;

    done = oq_write(oqp, bp, n);
 80017dc:	9a01      	ldr	r2, [sp, #4]
 80017de:	9902      	ldr	r1, [sp, #8]
 80017e0:	9803      	ldr	r0, [sp, #12]
 80017e2:	f7ff fdf5 	bl	80013d0 <oq_write>
 80017e6:	9005      	str	r0, [sp, #20]
    if (done == (size_t)0) {
 80017e8:	9b05      	ldr	r3, [sp, #20]
 80017ea:	2b00      	cmp	r3, #0
 80017ec:	d109      	bne.n	8001802 <oqWriteTimeout+0x42>
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 80017ee:	9b03      	ldr	r3, [sp, #12]
 80017f0:	9900      	ldr	r1, [sp, #0]
 80017f2:	4618      	mov	r0, r3
 80017f4:	f7ff fd6c 	bl	80012d0 <osalThreadEnqueueTimeoutS.lto_priv.1>
 80017f8:	9004      	str	r0, [sp, #16]

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 80017fa:	9b04      	ldr	r3, [sp, #16]
 80017fc:	2b00      	cmp	r3, #0
 80017fe:	d012      	beq.n	8001826 <oqWriteTimeout+0x66>
        break;
 8001800:	e014      	b.n	800182c <oqWriteTimeout+0x6c>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 8001802:	9b07      	ldr	r3, [sp, #28]
 8001804:	2b00      	cmp	r3, #0
 8001806:	d002      	beq.n	800180e <oqWriteTimeout+0x4e>
        nfy(oqp);
 8001808:	9b07      	ldr	r3, [sp, #28]
 800180a:	9803      	ldr	r0, [sp, #12]
 800180c:	4798      	blx	r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();
 800180e:	f7ff fd47 	bl	80012a0 <osalSysUnlock.lto_priv.1>

      n  -= done;
 8001812:	9a01      	ldr	r2, [sp, #4]
 8001814:	9b05      	ldr	r3, [sp, #20]
 8001816:	1ad3      	subs	r3, r2, r3
 8001818:	9301      	str	r3, [sp, #4]
      bp += done;
 800181a:	9a02      	ldr	r2, [sp, #8]
 800181c:	9b05      	ldr	r3, [sp, #20]
 800181e:	4413      	add	r3, r2
 8001820:	9302      	str	r3, [sp, #8]

      osalSysLock();
 8001822:	f7ff fd35 	bl	8001290 <osalSysLock.lto_priv.1>
  while (n > 0U) {
 8001826:	9b01      	ldr	r3, [sp, #4]
 8001828:	2b00      	cmp	r3, #0
 800182a:	d1d7      	bne.n	80017dc <oqWriteTimeout+0x1c>
    }
  }

  osalSysUnlock();
 800182c:	f7ff fd38 	bl	80012a0 <osalSysUnlock.lto_priv.1>
  return max - n;
 8001830:	9a06      	ldr	r2, [sp, #24]
 8001832:	9b01      	ldr	r3, [sp, #4]
 8001834:	1ad3      	subs	r3, r2, r3
}
 8001836:	4618      	mov	r0, r3
 8001838:	b009      	add	sp, #36	; 0x24
 800183a:	f85d fb04 	ldr.w	pc, [sp], #4
 800183e:	bf00      	nop

08001840 <chSysLock.lto_priv.2>:
static inline void chSysLock(void) {
 8001840:	b082      	sub	sp, #8
 8001842:	2320      	movs	r3, #32
 8001844:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001846:	9b01      	ldr	r3, [sp, #4]
 8001848:	f383 8811 	msr	BASEPRI, r3
}
 800184c:	bf00      	nop
}
 800184e:	bf00      	nop
}
 8001850:	bf00      	nop
 8001852:	b002      	add	sp, #8
 8001854:	4770      	bx	lr
 8001856:	bf00      	nop
	...

08001860 <chSysUnlock.lto_priv.2>:
static inline void chSysUnlock(void) {
 8001860:	b082      	sub	sp, #8
 8001862:	2300      	movs	r3, #0
 8001864:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001866:	9b01      	ldr	r3, [sp, #4]
 8001868:	f383 8811 	msr	BASEPRI, r3
}
 800186c:	bf00      	nop
}
 800186e:	bf00      	nop
}
 8001870:	bf00      	nop
 8001872:	b002      	add	sp, #8
 8001874:	4770      	bx	lr
 8001876:	bf00      	nop
	...

08001880 <chEvtObjectInit.lto_priv.0>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8001880:	b082      	sub	sp, #8
 8001882:	9001      	str	r0, [sp, #4]

  esp->next = (event_listener_t *)esp;
 8001884:	9b01      	ldr	r3, [sp, #4]
 8001886:	9a01      	ldr	r2, [sp, #4]
 8001888:	601a      	str	r2, [r3, #0]
}
 800188a:	bf00      	nop
 800188c:	b002      	add	sp, #8
 800188e:	4770      	bx	lr

08001890 <osalSysLock.lto_priv.2>:
static inline void osalSysLock(void) {
 8001890:	b508      	push	{r3, lr}
  chSysLock();
 8001892:	f7ff ffd5 	bl	8001840 <chSysLock.lto_priv.2>
}
 8001896:	bf00      	nop
 8001898:	bd08      	pop	{r3, pc}
 800189a:	bf00      	nop
 800189c:	0000      	movs	r0, r0
	...

080018a0 <osalSysUnlock.lto_priv.2>:
static inline void osalSysUnlock(void) {
 80018a0:	b508      	push	{r3, lr}
  chSysUnlock();
 80018a2:	f7ff ffdd 	bl	8001860 <chSysUnlock.lto_priv.2>
}
 80018a6:	bf00      	nop
 80018a8:	bd08      	pop	{r3, pc}
 80018aa:	bf00      	nop
 80018ac:	0000      	movs	r0, r0
	...

080018b0 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event source object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 80018b0:	b500      	push	{lr}
 80018b2:	b083      	sub	sp, #12
 80018b4:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 80018b6:	9801      	ldr	r0, [sp, #4]
 80018b8:	f7ff ffe2 	bl	8001880 <chEvtObjectInit.lto_priv.0>
}
 80018bc:	bf00      	nop
 80018be:	b003      	add	sp, #12
 80018c0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080018d0 <osalEventBroadcastFlagsI.lto_priv.0>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 80018d0:	b500      	push	{lr}
 80018d2:	b083      	sub	sp, #12
 80018d4:	9001      	str	r0, [sp, #4]
 80018d6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 80018d8:	9900      	ldr	r1, [sp, #0]
 80018da:	9801      	ldr	r0, [sp, #4]
 80018dc:	f003 f8b8 	bl	8004a50 <chEvtBroadcastFlagsI>
}
 80018e0:	bf00      	nop
 80018e2:	b003      	add	sp, #12
 80018e4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080018f0 <_write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 80018f0:	b500      	push	{lr}
 80018f2:	b085      	sub	sp, #20
 80018f4:	9003      	str	r0, [sp, #12]
 80018f6:	9102      	str	r1, [sp, #8]
 80018f8:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80018fa:	9b03      	ldr	r3, [sp, #12]
 80018fc:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8001900:	f04f 33ff 	mov.w	r3, #4294967295
 8001904:	9a01      	ldr	r2, [sp, #4]
 8001906:	9902      	ldr	r1, [sp, #8]
 8001908:	f7ff ff5a 	bl	80017c0 <oqWriteTimeout>
 800190c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 800190e:	4618      	mov	r0, r3
 8001910:	b005      	add	sp, #20
 8001912:	f85d fb04 	ldr.w	pc, [sp], #4
 8001916:	bf00      	nop
	...

08001920 <_read>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8001920:	b500      	push	{lr}
 8001922:	b085      	sub	sp, #20
 8001924:	9003      	str	r0, [sp, #12]
 8001926:	9102      	str	r1, [sp, #8]
 8001928:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800192a:	9b03      	ldr	r3, [sp, #12]
 800192c:	f103 000c 	add.w	r0, r3, #12
 8001930:	f04f 33ff 	mov.w	r3, #4294967295
 8001934:	9a01      	ldr	r2, [sp, #4]
 8001936:	9902      	ldr	r1, [sp, #8]
 8001938:	f7ff fe52 	bl	80015e0 <iqReadTimeout>
 800193c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 800193e:	4618      	mov	r0, r3
 8001940:	b005      	add	sp, #20
 8001942:	f85d fb04 	ldr.w	pc, [sp], #4
 8001946:	bf00      	nop
	...

08001950 <_put.lto_priv.0>:

static msg_t _put(void *ip, uint8_t b) {
 8001950:	b500      	push	{lr}
 8001952:	b083      	sub	sp, #12
 8001954:	9001      	str	r0, [sp, #4]
 8001956:	460b      	mov	r3, r1
 8001958:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 800195c:	9b01      	ldr	r3, [sp, #4]
 800195e:	3330      	adds	r3, #48	; 0x30
 8001960:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8001964:	f04f 32ff 	mov.w	r2, #4294967295
 8001968:	4618      	mov	r0, r3
 800196a:	f7ff fea1 	bl	80016b0 <oqPutTimeout>
 800196e:	4603      	mov	r3, r0
}
 8001970:	4618      	mov	r0, r3
 8001972:	b003      	add	sp, #12
 8001974:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001980 <_get.lto_priv.0>:

static msg_t _get(void *ip) {
 8001980:	b500      	push	{lr}
 8001982:	b083      	sub	sp, #12
 8001984:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001986:	9b01      	ldr	r3, [sp, #4]
 8001988:	330c      	adds	r3, #12
 800198a:	f04f 31ff 	mov.w	r1, #4294967295
 800198e:	4618      	mov	r0, r3
 8001990:	f7ff fde6 	bl	8001560 <iqGetTimeout>
 8001994:	4603      	mov	r3, r0
}
 8001996:	4618      	mov	r0, r3
 8001998:	b003      	add	sp, #12
 800199a:	f85d fb04 	ldr.w	pc, [sp], #4
 800199e:	bf00      	nop

080019a0 <_putt>:

static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 80019a0:	b500      	push	{lr}
 80019a2:	b085      	sub	sp, #20
 80019a4:	9003      	str	r0, [sp, #12]
 80019a6:	460b      	mov	r3, r1
 80019a8:	9201      	str	r2, [sp, #4]
 80019aa:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80019ae:	9b03      	ldr	r3, [sp, #12]
 80019b0:	3330      	adds	r3, #48	; 0x30
 80019b2:	f89d 100b 	ldrb.w	r1, [sp, #11]
 80019b6:	9a01      	ldr	r2, [sp, #4]
 80019b8:	4618      	mov	r0, r3
 80019ba:	f7ff fe79 	bl	80016b0 <oqPutTimeout>
 80019be:	4603      	mov	r3, r0
}
 80019c0:	4618      	mov	r0, r3
 80019c2:	b005      	add	sp, #20
 80019c4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080019d0 <_gett>:

static msg_t _gett(void *ip, sysinterval_t timeout) {
 80019d0:	b500      	push	{lr}
 80019d2:	b083      	sub	sp, #12
 80019d4:	9001      	str	r0, [sp, #4]
 80019d6:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80019d8:	9b01      	ldr	r3, [sp, #4]
 80019da:	330c      	adds	r3, #12
 80019dc:	9900      	ldr	r1, [sp, #0]
 80019de:	4618      	mov	r0, r3
 80019e0:	f7ff fdbe 	bl	8001560 <iqGetTimeout>
 80019e4:	4603      	mov	r3, r0
}
 80019e6:	4618      	mov	r0, r3
 80019e8:	b003      	add	sp, #12
 80019ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80019ee:	bf00      	nop

080019f0 <_writet>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n,
                      sysinterval_t timeout) {
 80019f0:	b500      	push	{lr}
 80019f2:	b085      	sub	sp, #20
 80019f4:	9003      	str	r0, [sp, #12]
 80019f6:	9102      	str	r1, [sp, #8]
 80019f8:	9201      	str	r2, [sp, #4]
 80019fa:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 80019fc:	9b03      	ldr	r3, [sp, #12]
 80019fe:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8001a02:	9b00      	ldr	r3, [sp, #0]
 8001a04:	9a01      	ldr	r2, [sp, #4]
 8001a06:	9902      	ldr	r1, [sp, #8]
 8001a08:	f7ff feda 	bl	80017c0 <oqWriteTimeout>
 8001a0c:	4603      	mov	r3, r0
}
 8001a0e:	4618      	mov	r0, r3
 8001a10:	b005      	add	sp, #20
 8001a12:	f85d fb04 	ldr.w	pc, [sp], #4
 8001a16:	bf00      	nop
	...

08001a20 <_readt>:

static size_t _readt(void *ip, uint8_t *bp, size_t n,
                     sysinterval_t timeout) {
 8001a20:	b500      	push	{lr}
 8001a22:	b085      	sub	sp, #20
 8001a24:	9003      	str	r0, [sp, #12]
 8001a26:	9102      	str	r1, [sp, #8]
 8001a28:	9201      	str	r2, [sp, #4]
 8001a2a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8001a2c:	9b03      	ldr	r3, [sp, #12]
 8001a2e:	f103 000c 	add.w	r0, r3, #12
 8001a32:	9b00      	ldr	r3, [sp, #0]
 8001a34:	9a01      	ldr	r2, [sp, #4]
 8001a36:	9902      	ldr	r1, [sp, #8]
 8001a38:	f7ff fdd2 	bl	80015e0 <iqReadTimeout>
 8001a3c:	4603      	mov	r3, r0
}
 8001a3e:	4618      	mov	r0, r3
 8001a40:	b005      	add	sp, #20
 8001a42:	f85d fb04 	ldr.w	pc, [sp], #4
 8001a46:	bf00      	nop
	...

08001a50 <_ctl>:

static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
 8001a50:	b086      	sub	sp, #24
 8001a52:	9003      	str	r0, [sp, #12]
 8001a54:	9102      	str	r1, [sp, #8]
 8001a56:	9201      	str	r2, [sp, #4]
  SerialDriver *sdp = (SerialDriver *)ip;
 8001a58:	9b03      	ldr	r3, [sp, #12]
 8001a5a:	9305      	str	r3, [sp, #20]

  osalDbgCheck(sdp != NULL);

  switch (operation) {
 8001a5c:	9b02      	ldr	r3, [sp, #8]
 8001a5e:	2b00      	cmp	r3, #0
 8001a60:	d002      	beq.n	8001a68 <_ctl+0x18>
 8001a62:	9b02      	ldr	r3, [sp, #8]
 8001a64:	2b01      	cmp	r3, #1
  default:
#if defined(SD_LLD_IMPLEMENTS_CTL)
    /* Delegating to the LLD if supported.*/
    return sd_lld_control(sdp, operation, arg);
#else
    break;
 8001a66:	e000      	b.n	8001a6a <_ctl+0x1a>
    break;
 8001a68:	bf00      	nop
#endif
  }
  return MSG_OK;
 8001a6a:	2300      	movs	r3, #0
}
 8001a6c:	4618      	mov	r0, r3
 8001a6e:	b006      	add	sp, #24
 8001a70:	4770      	bx	lr
 8001a72:	bf00      	nop
	...

08001a80 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 8001a80:	b508      	push	{r3, lr}

  sd_lld_init();
 8001a82:	f001 f99d 	bl	8002dc0 <sd_lld_init>
}
 8001a86:	bf00      	nop
 8001a88:	bd08      	pop	{r3, pc}
 8001a8a:	bf00      	nop
 8001a8c:	0000      	movs	r0, r0
	...

08001a90 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8001a90:	b500      	push	{lr}
 8001a92:	b087      	sub	sp, #28
 8001a94:	9005      	str	r0, [sp, #20]
 8001a96:	9104      	str	r1, [sp, #16]
 8001a98:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 8001a9a:	9b05      	ldr	r3, [sp, #20]
 8001a9c:	4a12      	ldr	r2, [pc, #72]	; (8001ae8 <sdObjectInit+0x58>)
 8001a9e:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 8001aa0:	9b05      	ldr	r3, [sp, #20]
 8001aa2:	3304      	adds	r3, #4
 8001aa4:	4618      	mov	r0, r3
 8001aa6:	f7ff ff03 	bl	80018b0 <osalEventObjectInit>
  sdp->state = SD_STOP;
 8001aaa:	9b05      	ldr	r3, [sp, #20]
 8001aac:	2201      	movs	r2, #1
 8001aae:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8001ab0:	9b05      	ldr	r3, [sp, #20]
 8001ab2:	f103 000c 	add.w	r0, r3, #12
 8001ab6:	9b05      	ldr	r3, [sp, #20]
 8001ab8:	f103 0154 	add.w	r1, r3, #84	; 0x54
 8001abc:	9b05      	ldr	r3, [sp, #20]
 8001abe:	9300      	str	r3, [sp, #0]
 8001ac0:	9b04      	ldr	r3, [sp, #16]
 8001ac2:	2210      	movs	r2, #16
 8001ac4:	f7ff fce4 	bl	8001490 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8001ac8:	9b05      	ldr	r3, [sp, #20]
 8001aca:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8001ace:	9b05      	ldr	r3, [sp, #20]
 8001ad0:	f103 0164 	add.w	r1, r3, #100	; 0x64
 8001ad4:	9b05      	ldr	r3, [sp, #20]
 8001ad6:	9300      	str	r3, [sp, #0]
 8001ad8:	9b03      	ldr	r3, [sp, #12]
 8001ada:	2210      	movs	r2, #16
 8001adc:	f7ff fdc0 	bl	8001660 <oqObjectInit>
}
 8001ae0:	bf00      	nop
 8001ae2:	b007      	add	sp, #28
 8001ae4:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ae8:	08006da4 	.word	0x08006da4
 8001aec:	00000000 	.word	0x00000000

08001af0 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8001af0:	b500      	push	{lr}
 8001af2:	b083      	sub	sp, #12
 8001af4:	9001      	str	r0, [sp, #4]
 8001af6:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8001af8:	f7ff feca 	bl	8001890 <osalSysLock.lto_priv.2>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 8001afc:	9900      	ldr	r1, [sp, #0]
 8001afe:	9801      	ldr	r0, [sp, #4]
 8001b00:	f001 f976 	bl	8002df0 <sd_lld_start>
  sdp->state = SD_READY;
 8001b04:	9b01      	ldr	r3, [sp, #4]
 8001b06:	2202      	movs	r2, #2
 8001b08:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 8001b0a:	f7ff fec9 	bl	80018a0 <osalSysUnlock.lto_priv.2>
}
 8001b0e:	bf00      	nop
 8001b10:	b003      	add	sp, #12
 8001b12:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b16:	bf00      	nop
	...

08001b20 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8001b20:	b500      	push	{lr}
 8001b22:	b083      	sub	sp, #12
 8001b24:	9001      	str	r0, [sp, #4]
 8001b26:	460b      	mov	r3, r1
 8001b28:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8001b2c:	9b01      	ldr	r3, [sp, #4]
 8001b2e:	695b      	ldr	r3, [r3, #20]
 8001b30:	2b00      	cmp	r3, #0
 8001b32:	d105      	bne.n	8001b40 <sdIncomingDataI+0x20>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8001b34:	9b01      	ldr	r3, [sp, #4]
 8001b36:	3304      	adds	r3, #4
 8001b38:	2104      	movs	r1, #4
 8001b3a:	4618      	mov	r0, r3
 8001b3c:	f7ff fec8 	bl	80018d0 <osalEventBroadcastFlagsI.lto_priv.0>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8001b40:	9b01      	ldr	r3, [sp, #4]
 8001b42:	330c      	adds	r3, #12
 8001b44:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8001b48:	4611      	mov	r1, r2
 8001b4a:	4618      	mov	r0, r3
 8001b4c:	f7ff fcc8 	bl	80014e0 <iqPutI>
 8001b50:	4603      	mov	r3, r0
 8001b52:	2b00      	cmp	r3, #0
 8001b54:	da06      	bge.n	8001b64 <sdIncomingDataI+0x44>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
 8001b56:	9b01      	ldr	r3, [sp, #4]
 8001b58:	3304      	adds	r3, #4
 8001b5a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001b5e:	4618      	mov	r0, r3
 8001b60:	f7ff feb6 	bl	80018d0 <osalEventBroadcastFlagsI.lto_priv.0>
}
 8001b64:	bf00      	nop
 8001b66:	b003      	add	sp, #12
 8001b68:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b6c:	0000      	movs	r0, r0
	...

08001b70 <chSysLock.lto_priv.3>:
static inline void chSysLock(void) {
 8001b70:	b082      	sub	sp, #8
 8001b72:	2320      	movs	r3, #32
 8001b74:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001b76:	9b01      	ldr	r3, [sp, #4]
 8001b78:	f383 8811 	msr	BASEPRI, r3
}
 8001b7c:	bf00      	nop
}
 8001b7e:	bf00      	nop
}
 8001b80:	bf00      	nop
 8001b82:	b002      	add	sp, #8
 8001b84:	4770      	bx	lr
 8001b86:	bf00      	nop
	...

08001b90 <chSysUnlock.lto_priv.3>:
static inline void chSysUnlock(void) {
 8001b90:	b082      	sub	sp, #8
 8001b92:	2300      	movs	r3, #0
 8001b94:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001b96:	9b01      	ldr	r3, [sp, #4]
 8001b98:	f383 8811 	msr	BASEPRI, r3
}
 8001b9c:	bf00      	nop
}
 8001b9e:	bf00      	nop
}
 8001ba0:	bf00      	nop
 8001ba2:	b002      	add	sp, #8
 8001ba4:	4770      	bx	lr
 8001ba6:	bf00      	nop
	...

08001bb0 <osalSysLock.lto_priv.3>:
static inline void osalSysLock(void) {
 8001bb0:	b508      	push	{r3, lr}
  chSysLock();
 8001bb2:	f7ff ffdd 	bl	8001b70 <chSysLock.lto_priv.3>
}
 8001bb6:	bf00      	nop
 8001bb8:	bd08      	pop	{r3, pc}
 8001bba:	bf00      	nop
 8001bbc:	0000      	movs	r0, r0
	...

08001bc0 <osalSysUnlock.lto_priv.3>:
static inline void osalSysUnlock(void) {
 8001bc0:	b508      	push	{r3, lr}
  chSysUnlock();
 8001bc2:	f7ff ffe5 	bl	8001b90 <chSysUnlock.lto_priv.3>
}
 8001bc6:	bf00      	nop
 8001bc8:	bd08      	pop	{r3, pc}
 8001bca:	bf00      	nop
 8001bcc:	0000      	movs	r0, r0
	...

08001bd0 <uartInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void uartInit(void) {
 8001bd0:	b508      	push	{r3, lr}

  uart_lld_init();
 8001bd2:	f001 fbbd 	bl	8003350 <uart_lld_init>
}
 8001bd6:	bf00      	nop
 8001bd8:	bd08      	pop	{r3, pc}
 8001bda:	bf00      	nop
 8001bdc:	0000      	movs	r0, r0
	...

08001be0 <uartObjectInit>:
 *
 * @param[out] uartp    pointer to the @p UARTDriver object
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {
 8001be0:	b082      	sub	sp, #8
 8001be2:	9001      	str	r0, [sp, #4]

  uartp->state      = UART_STOP;
 8001be4:	9b01      	ldr	r3, [sp, #4]
 8001be6:	2201      	movs	r2, #1
 8001be8:	701a      	strb	r2, [r3, #0]
  uartp->txstate    = UART_TX_IDLE;
 8001bea:	9b01      	ldr	r3, [sp, #4]
 8001bec:	2200      	movs	r2, #0
 8001bee:	705a      	strb	r2, [r3, #1]
  uartp->rxstate    = UART_RX_IDLE;
 8001bf0:	9b01      	ldr	r3, [sp, #4]
 8001bf2:	2200      	movs	r2, #0
 8001bf4:	709a      	strb	r2, [r3, #2]
  uartp->config     = NULL;
 8001bf6:	9b01      	ldr	r3, [sp, #4]
 8001bf8:	2200      	movs	r2, #0
 8001bfa:	605a      	str	r2, [r3, #4]

  /* Optional, user-defined initializer.*/
#if defined(UART_DRIVER_EXT_INIT_HOOK)
  UART_DRIVER_EXT_INIT_HOOK(uartp);
#endif
}
 8001bfc:	bf00      	nop
 8001bfe:	b002      	add	sp, #8
 8001c00:	4770      	bx	lr
 8001c02:	bf00      	nop
	...

08001c10 <uartStart>:
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] config    pointer to the @p UARTConfig object
 *
 * @api
 */
void uartStart(UARTDriver *uartp, const UARTConfig *config) {
 8001c10:	b500      	push	{lr}
 8001c12:	b083      	sub	sp, #12
 8001c14:	9001      	str	r0, [sp, #4]
 8001c16:	9100      	str	r1, [sp, #0]

  osalDbgCheck((uartp != NULL) && (config != NULL));

  osalSysLock();
 8001c18:	f7ff ffca 	bl	8001bb0 <osalSysLock.lto_priv.3>
  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
                "invalid state");

  uartp->config = config;
 8001c1c:	9b01      	ldr	r3, [sp, #4]
 8001c1e:	9a00      	ldr	r2, [sp, #0]
 8001c20:	605a      	str	r2, [r3, #4]
  uart_lld_start(uartp);
 8001c22:	9801      	ldr	r0, [sp, #4]
 8001c24:	f001 fbb4 	bl	8003390 <uart_lld_start>
  uartp->state = UART_READY;
 8001c28:	9b01      	ldr	r3, [sp, #4]
 8001c2a:	2202      	movs	r2, #2
 8001c2c:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8001c2e:	f7ff ffc7 	bl	8001bc0 <osalSysUnlock.lto_priv.3>
}
 8001c32:	bf00      	nop
 8001c34:	b003      	add	sp, #12
 8001c36:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c3a:	bf00      	nop
 8001c3c:	0000      	movs	r0, r0
	...

08001c40 <uartStop>:
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 *
 * @api
 */
void uartStop(UARTDriver *uartp) {
 8001c40:	b500      	push	{lr}
 8001c42:	b083      	sub	sp, #12
 8001c44:	9001      	str	r0, [sp, #4]

  osalDbgCheck(uartp != NULL);

  osalSysLock();
 8001c46:	f7ff ffb3 	bl	8001bb0 <osalSysLock.lto_priv.3>

  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
                "invalid state");

  uart_lld_stop(uartp);
 8001c4a:	9801      	ldr	r0, [sp, #4]
 8001c4c:	f001 fc18 	bl	8003480 <uart_lld_stop>
  uartp->config  = NULL;
 8001c50:	9b01      	ldr	r3, [sp, #4]
 8001c52:	2200      	movs	r2, #0
 8001c54:	605a      	str	r2, [r3, #4]
  uartp->state   = UART_STOP;
 8001c56:	9b01      	ldr	r3, [sp, #4]
 8001c58:	2201      	movs	r2, #1
 8001c5a:	701a      	strb	r2, [r3, #0]
  uartp->txstate = UART_TX_IDLE;
 8001c5c:	9b01      	ldr	r3, [sp, #4]
 8001c5e:	2200      	movs	r2, #0
 8001c60:	705a      	strb	r2, [r3, #1]
  uartp->rxstate = UART_RX_IDLE;
 8001c62:	9b01      	ldr	r3, [sp, #4]
 8001c64:	2200      	movs	r2, #0
 8001c66:	709a      	strb	r2, [r3, #2]

  osalSysUnlock();
 8001c68:	f7ff ffaa 	bl	8001bc0 <osalSysUnlock.lto_priv.3>
}
 8001c6c:	bf00      	nop
 8001c6e:	b003      	add	sp, #12
 8001c70:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001c80 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8001c80:	b082      	sub	sp, #8
 8001c82:	9001      	str	r0, [sp, #4]
 8001c84:	9100      	str	r1, [sp, #0]
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8001c86:	9b00      	ldr	r3, [sp, #0]
 8001c88:	b2db      	uxtb	r3, r3
 8001c8a:	4a11      	ldr	r2, [pc, #68]	; (8001cd0 <nvicEnableVector+0x50>)
 8001c8c:	011b      	lsls	r3, r3, #4
 8001c8e:	b2d9      	uxtb	r1, r3
 8001c90:	9b01      	ldr	r3, [sp, #4]
 8001c92:	4413      	add	r3, r2
 8001c94:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8001c98:	460a      	mov	r2, r1
 8001c9a:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001c9c:	9b01      	ldr	r3, [sp, #4]
 8001c9e:	f003 021f 	and.w	r2, r3, #31
 8001ca2:	490b      	ldr	r1, [pc, #44]	; (8001cd0 <nvicEnableVector+0x50>)
 8001ca4:	9b01      	ldr	r3, [sp, #4]
 8001ca6:	095b      	lsrs	r3, r3, #5
 8001ca8:	2001      	movs	r0, #1
 8001caa:	fa00 f202 	lsl.w	r2, r0, r2
 8001cae:	3360      	adds	r3, #96	; 0x60
 8001cb0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001cb4:	9b01      	ldr	r3, [sp, #4]
 8001cb6:	f003 021f 	and.w	r2, r3, #31
 8001cba:	4905      	ldr	r1, [pc, #20]	; (8001cd0 <nvicEnableVector+0x50>)
 8001cbc:	9b01      	ldr	r3, [sp, #4]
 8001cbe:	095b      	lsrs	r3, r3, #5
 8001cc0:	2001      	movs	r0, #1
 8001cc2:	fa00 f202 	lsl.w	r2, r0, r2
 8001cc6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
 8001cca:	bf00      	nop
 8001ccc:	b002      	add	sp, #8
 8001cce:	4770      	bx	lr
 8001cd0:	e000e100 	.word	0xe000e100
	...

08001ce0 <nvicDisableVector>:
/**
 * @brief   Disables an interrupt handler.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
 8001ce0:	b082      	sub	sp, #8
 8001ce2:	9001      	str	r0, [sp, #4]

  NVIC->__ICER[n >> 5U] = 1U << (n & 0x1FU);
 8001ce4:	9b01      	ldr	r3, [sp, #4]
 8001ce6:	f003 021f 	and.w	r2, r3, #31
 8001cea:	490f      	ldr	r1, [pc, #60]	; (8001d28 <nvicDisableVector+0x48>)
 8001cec:	9b01      	ldr	r3, [sp, #4]
 8001cee:	095b      	lsrs	r3, r3, #5
 8001cf0:	2001      	movs	r0, #1
 8001cf2:	fa00 f202 	lsl.w	r2, r0, r2
 8001cf6:	3320      	adds	r3, #32
 8001cf8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001cfc:	9b01      	ldr	r3, [sp, #4]
 8001cfe:	f003 021f 	and.w	r2, r3, #31
 8001d02:	4909      	ldr	r1, [pc, #36]	; (8001d28 <nvicDisableVector+0x48>)
 8001d04:	9b01      	ldr	r3, [sp, #4]
 8001d06:	095b      	lsrs	r3, r3, #5
 8001d08:	2001      	movs	r0, #1
 8001d0a:	fa00 f202 	lsl.w	r2, r0, r2
 8001d0e:	3360      	adds	r3, #96	; 0x60
 8001d10:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = 0U;
 8001d14:	4a04      	ldr	r2, [pc, #16]	; (8001d28 <nvicDisableVector+0x48>)
 8001d16:	9b01      	ldr	r3, [sp, #4]
 8001d18:	4413      	add	r3, r2
 8001d1a:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8001d1e:	2200      	movs	r2, #0
 8001d20:	701a      	strb	r2, [r3, #0]
#endif
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* Marked as not secure again.*/
  NVIC->__ITNS[n >> 5U] |= 1U << (n & 0x1FU);
#endif
}
 8001d22:	bf00      	nop
 8001d24:	b002      	add	sp, #8
 8001d26:	4770      	bx	lr
 8001d28:	e000e100 	.word	0xe000e100
 8001d2c:	00000000 	.word	0x00000000

08001d30 <exti0_irq_init>:

static inline void exti0_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI0_NUMBER, STM32_IRQ_EXTI0_PRIORITY);
#endif
}
 8001d30:	bf00      	nop
 8001d32:	4770      	bx	lr
	...

08001d40 <exti1_irq_init>:

static inline void exti1_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI1_NUMBER, STM32_IRQ_EXTI1_PRIORITY);
#endif
}
 8001d40:	bf00      	nop
 8001d42:	4770      	bx	lr
	...

08001d50 <exti2_irq_init>:

static inline void exti2_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI2_NUMBER, STM32_IRQ_EXTI2_PRIORITY);
#endif
}
 8001d50:	bf00      	nop
 8001d52:	4770      	bx	lr
	...

08001d60 <exti3_irq_init>:

static inline void exti3_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI3_NUMBER, STM32_IRQ_EXTI3_PRIORITY);
#endif
}
 8001d60:	bf00      	nop
 8001d62:	4770      	bx	lr
	...

08001d70 <exti4_irq_init>:

static inline void exti4_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI4_NUMBER, STM32_IRQ_EXTI4_PRIORITY);
#endif
}
 8001d70:	bf00      	nop
 8001d72:	4770      	bx	lr
	...

08001d80 <exti5_9_irq_init>:

static inline void exti5_9_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI5_9_NUMBER, STM32_IRQ_EXTI5_9_PRIORITY);
#endif
}
 8001d80:	bf00      	nop
 8001d82:	4770      	bx	lr
	...

08001d90 <exti10_15_irq_init>:

static inline void exti10_15_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI10_15_NUMBER, STM32_IRQ_EXTI10_15_PRIORITY);
#endif
}
 8001d90:	bf00      	nop
 8001d92:	4770      	bx	lr
	...

08001da0 <exti16_irq_init>:

static inline void exti16_irq_init(void) {
#if defined(STM32_EXTI16_IS_USED)
  nvicEnableVector(STM32_EXTI16_NUMBER, STM32_IRQ_EXTI16_PRIORITY);
#endif
}
 8001da0:	bf00      	nop
 8001da2:	4770      	bx	lr
	...

08001db0 <exti17_irq_init>:

static inline void exti17_irq_init(void) {
#if defined(STM32_EXTI17_IS_USED)
  nvicEnableVector(STM32_EXTI17_NUMBER, STM32_IRQ_EXTI17_PRIORITY);
#endif
}
 8001db0:	bf00      	nop
 8001db2:	4770      	bx	lr
	...

08001dc0 <exti18_irq_init>:

static inline void exti18_irq_init(void) {
#if defined(STM32_EXTI18_IS_USED)
  nvicEnableVector(STM32_EXTI18_NUMBER, STM32_IRQ_EXTI18_PRIORITY);
#endif
}
 8001dc0:	bf00      	nop
 8001dc2:	4770      	bx	lr
	...

08001dd0 <exti19_irq_init>:

static inline void exti19_irq_init(void) {
#if defined(STM32_EXTI19_IS_USED)
  nvicEnableVector(STM32_EXTI19_NUMBER, STM32_IRQ_EXTI19_PRIORITY);
#endif
}
 8001dd0:	bf00      	nop
 8001dd2:	4770      	bx	lr
	...

08001de0 <exti20_irq_init>:

static inline void exti20_irq_init(void) {
#if defined(STM32_EXTI20_IS_USED)
  nvicEnableVector(STM32_EXTI20_NUMBER, STM32_IRQ_EXTI20_PRIORITY);
#endif
}
 8001de0:	bf00      	nop
 8001de2:	4770      	bx	lr
	...

08001df0 <exti21_irq_init>:

static inline void exti21_irq_init(void) {
#if defined(STM32_EXTI21_IS_USED)
  nvicEnableVector(STM32_EXTI21_NUMBER, STM32_IRQ_EXTI21_PRIORITY);
#endif
}
 8001df0:	bf00      	nop
 8001df2:	4770      	bx	lr
	...

08001e00 <exti22_irq_init>:

static inline void exti22_irq_init(void) {
#if defined(STM32_EXTI22_IS_USED)
  nvicEnableVector(STM32_EXTI22_NUMBER, STM32_IRQ_EXTI22_PRIORITY);
#endif
}
 8001e00:	bf00      	nop
 8001e02:	4770      	bx	lr
	...

08001e10 <usart1_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void usart1_irq_init(void) {
 8001e10:	b508      	push	{r3, lr}
#if defined(STM32_USART1_IS_USED)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_IRQ_USART1_PRIORITY);
 8001e12:	210c      	movs	r1, #12
 8001e14:	2025      	movs	r0, #37	; 0x25
 8001e16:	f7ff ff33 	bl	8001c80 <nvicEnableVector>
#endif
}
 8001e1a:	bf00      	nop
 8001e1c:	bd08      	pop	{r3, pc}
 8001e1e:	bf00      	nop

08001e20 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8001e20:	b508      	push	{r3, lr}
#endif
#endif

#if HAL_USE_UART
#if STM32_UART_USE_USART1
  uart_lld_serve_interrupt(&UARTD1);
 8001e22:	4803      	ldr	r0, [pc, #12]	; (8001e30 <VectorD4+0x10>)
 8001e24:	f001 fb64 	bl	80034f0 <uart_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8001e28:	f002 ffda 	bl	8004de0 <__port_irq_epilogue>
}
 8001e2c:	bf00      	nop
 8001e2e:	bd08      	pop	{r3, pc}
 8001e30:	20000d5c 	.word	0x20000d5c
	...

08001e40 <usart2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void usart2_irq_init(void) {
 8001e40:	b508      	push	{r3, lr}
#if defined(STM32_USART2_IS_USED)
  nvicEnableVector(STM32_USART2_NUMBER, STM32_IRQ_USART2_PRIORITY);
 8001e42:	210c      	movs	r1, #12
 8001e44:	2026      	movs	r0, #38	; 0x26
 8001e46:	f7ff ff1b 	bl	8001c80 <nvicEnableVector>
#endif
}
 8001e4a:	bf00      	nop
 8001e4c:	bd08      	pop	{r3, pc}
 8001e4e:	bf00      	nop

08001e50 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8001e50:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

#if HAL_USE_SERIAL
#if STM32_SERIAL_USE_USART2
  sd_lld_serve_interrupt(&SD2);
 8001e52:	4803      	ldr	r0, [pc, #12]	; (8001e60 <VectorD8+0x10>)
 8001e54:	f000 fffc 	bl	8002e50 <sd_lld_serve_interrupt>
#if STM32_UART_USE_USART2
  uart_lld_serve_interrupt(&UARTD2);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8001e58:	f002 ffc2 	bl	8004de0 <__port_irq_epilogue>
}
 8001e5c:	bf00      	nop
 8001e5e:	bd08      	pop	{r3, pc}
 8001e60:	20000cdc 	.word	0x20000cdc
	...

08001e70 <usart3_irq_init>:

static inline void usart3_irq_init(void) {
#if defined(STM32_USART3_IS_USED)
  nvicEnableVector(STM32_USART3_NUMBER, STM32_IRQ_USART3_PRIORITY);
#endif
}
 8001e70:	bf00      	nop
 8001e72:	4770      	bx	lr
	...

08001e80 <uart4_irq_init>:

static inline void uart4_irq_init(void) {
#if defined(STM32_UART4_IS_USED)
  nvicEnableVector(STM32_UART4_NUMBER, STM32_IRQ_UART4_PRIORITY);
#endif
}
 8001e80:	bf00      	nop
 8001e82:	4770      	bx	lr
	...

08001e90 <uart5_irq_init>:

static inline void uart5_irq_init(void) {
#if defined(STM32_UART5_IS_USED)
  nvicEnableVector(STM32_UART5_NUMBER, STM32_IRQ_UART5_PRIORITY);
#endif
}
 8001e90:	bf00      	nop
 8001e92:	4770      	bx	lr
	...

08001ea0 <usart6_irq_init>:

static inline void usart6_irq_init(void) {
#if defined(STM32_USART6_IS_USED)
  nvicEnableVector(STM32_USART6_NUMBER, STM32_IRQ_USART6_PRIORITY);
#endif
}
 8001ea0:	bf00      	nop
 8001ea2:	4770      	bx	lr
	...

08001eb0 <uart7_irq_init>:

static inline void uart7_irq_init(void) {
#if defined(STM32_UART7_IS_USED)
  nvicEnableVector(STM32_UART7_NUMBER, STM32_IRQ_UART7_PRIORITY);
#endif
}
 8001eb0:	bf00      	nop
 8001eb2:	4770      	bx	lr
	...

08001ec0 <uart8_irq_init>:

static inline void uart8_irq_init(void) {
#if defined(STM32_UART8_IS_USED)
  nvicEnableVector(STM32_UART8_NUMBER, STM32_IRQ_UART8_PRIORITY);
#endif
}
 8001ec0:	bf00      	nop
 8001ec2:	4770      	bx	lr
	...

08001ed0 <uart9_irq_init>:

static inline void uart9_irq_init(void) {
#if defined(STM32_UART9_IS_USED)
  nvicEnableVector(STM32_UART9_NUMBER, STM32_IRQ_UART9_PRIORITY);
#endif
}
 8001ed0:	bf00      	nop
 8001ed2:	4770      	bx	lr
	...

08001ee0 <uart10_irq_init>:

static inline void uart10_irq_init(void) {
#if defined(STM32_UART10_IS_USED)
  nvicEnableVector(STM32_UART10_NUMBER, STM32_IRQ_UART10_PRIORITY);
#endif
}
 8001ee0:	bf00      	nop
 8001ee2:	4770      	bx	lr
	...

08001ef0 <tim1_tim9_tim10_tim11_irq_init>:
#endif
#if defined(STM32_TIM1_IS_USED)
  nvicEnableVector(STM32_TIM1_CC_NUMBER,
                   STM32_IRQ_TIM1_CC_PRIORITY);
#endif
}
 8001ef0:	bf00      	nop
 8001ef2:	4770      	bx	lr
	...

08001f00 <tim2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim2_irq_init(void) {
 8001f00:	b508      	push	{r3, lr}
#if defined(STM32_TIM2_IS_USED)
  nvicEnableVector(STM32_TIM2_NUMBER, STM32_IRQ_TIM2_PRIORITY);
 8001f02:	2107      	movs	r1, #7
 8001f04:	201c      	movs	r0, #28
 8001f06:	f7ff febb 	bl	8001c80 <nvicEnableVector>
#endif
}
 8001f0a:	bf00      	nop
 8001f0c:	bd08      	pop	{r3, pc}
 8001f0e:	bf00      	nop

08001f10 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8001f10:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD2);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
 8001f12:	f000 fe45 	bl	8002ba0 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8001f16:	f002 ff63 	bl	8004de0 <__port_irq_epilogue>
}
 8001f1a:	bf00      	nop
 8001f1c:	bd08      	pop	{r3, pc}
 8001f1e:	bf00      	nop

08001f20 <tim3_irq_init>:

static inline void tim3_irq_init(void) {
#if defined(STM32_TIM3_IS_USED)
  nvicEnableVector(STM32_TIM3_NUMBER, STM32_IRQ_TIM3_PRIORITY);
#endif
}
 8001f20:	bf00      	nop
 8001f22:	4770      	bx	lr
	...

08001f30 <tim4_irq_init>:

static inline void tim4_irq_init(void) {
#if defined(STM32_TIM4_IS_USED)
  nvicEnableVector(STM32_TIM4_NUMBER, STM32_IRQ_TIM4_PRIORITY);
#endif
}
 8001f30:	bf00      	nop
 8001f32:	4770      	bx	lr
	...

08001f40 <tim5_irq_init>:

static inline void tim5_irq_init(void) {
#if defined(STM32_TIM5_IS_USED)
  nvicEnableVector(STM32_TIM5_NUMBER, STM32_IRQ_TIM5_PRIORITY);
#endif
}
 8001f40:	bf00      	nop
 8001f42:	4770      	bx	lr
	...

08001f50 <tim6_irq_init>:

static inline void tim6_irq_init(void) {
#if defined(STM32_TIM6_IS_USED)
  nvicEnableVector(STM32_TIM6_NUMBER, STM32_IRQ_TIM6_PRIORITY);
#endif
}
 8001f50:	bf00      	nop
 8001f52:	4770      	bx	lr
	...

08001f60 <tim7_irq_init>:

static inline void tim7_irq_init(void) {
#if defined(STM32_TIM7_IS_USED)
  nvicEnableVector(STM32_TIM7_NUMBER, STM32_IRQ_TIM7_PRIORITY);
#endif
}
 8001f60:	bf00      	nop
 8001f62:	4770      	bx	lr
	...

08001f70 <tim8_tim12_tim13_tim14_irq_init>:
#endif
#if defined(STM32_TIM8_IS_USED)
  nvicEnableVector(STM32_TIM8_CC_NUMBER,
                   STM32_IRQ_TIM8_CC_PRIORITY);
#endif
}
 8001f70:	bf00      	nop
 8001f72:	4770      	bx	lr
	...

08001f80 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8001f80:	b508      	push	{r3, lr}

  exti0_irq_init();
 8001f82:	f7ff fed5 	bl	8001d30 <exti0_irq_init>
  exti1_irq_init();
 8001f86:	f7ff fedb 	bl	8001d40 <exti1_irq_init>
  exti2_irq_init();
 8001f8a:	f7ff fee1 	bl	8001d50 <exti2_irq_init>
  exti3_irq_init();
 8001f8e:	f7ff fee7 	bl	8001d60 <exti3_irq_init>
  exti4_irq_init();
 8001f92:	f7ff feed 	bl	8001d70 <exti4_irq_init>
  exti5_9_irq_init();
 8001f96:	f7ff fef3 	bl	8001d80 <exti5_9_irq_init>
  exti10_15_irq_init();
 8001f9a:	f7ff fef9 	bl	8001d90 <exti10_15_irq_init>
  exti16_irq_init();
 8001f9e:	f7ff feff 	bl	8001da0 <exti16_irq_init>
  exti17_irq_init();
 8001fa2:	f7ff ff05 	bl	8001db0 <exti17_irq_init>
  exti18_irq_init();
 8001fa6:	f7ff ff0b 	bl	8001dc0 <exti18_irq_init>
  exti19_irq_init();
 8001faa:	f7ff ff11 	bl	8001dd0 <exti19_irq_init>
  exti20_irq_init();
 8001fae:	f7ff ff17 	bl	8001de0 <exti20_irq_init>
  exti21_irq_init();
 8001fb2:	f7ff ff1d 	bl	8001df0 <exti21_irq_init>
  exti22_irq_init();
 8001fb6:	f7ff ff23 	bl	8001e00 <exti22_irq_init>

  tim1_tim9_tim10_tim11_irq_init();
 8001fba:	f7ff ff99 	bl	8001ef0 <tim1_tim9_tim10_tim11_irq_init>
  tim2_irq_init();
 8001fbe:	f7ff ff9f 	bl	8001f00 <tim2_irq_init>
  tim3_irq_init();
 8001fc2:	f7ff ffad 	bl	8001f20 <tim3_irq_init>
  tim4_irq_init();
 8001fc6:	f7ff ffb3 	bl	8001f30 <tim4_irq_init>
  tim5_irq_init();
 8001fca:	f7ff ffb9 	bl	8001f40 <tim5_irq_init>
  tim6_irq_init();
 8001fce:	f7ff ffbf 	bl	8001f50 <tim6_irq_init>
  tim7_irq_init();
 8001fd2:	f7ff ffc5 	bl	8001f60 <tim7_irq_init>
  tim8_tim12_tim13_tim14_irq_init();
 8001fd6:	f7ff ffcb 	bl	8001f70 <tim8_tim12_tim13_tim14_irq_init>

  usart1_irq_init();
 8001fda:	f7ff ff19 	bl	8001e10 <usart1_irq_init>
  usart2_irq_init();
 8001fde:	f7ff ff2f 	bl	8001e40 <usart2_irq_init>
  usart3_irq_init();
 8001fe2:	f7ff ff45 	bl	8001e70 <usart3_irq_init>
  uart4_irq_init();
 8001fe6:	f7ff ff4b 	bl	8001e80 <uart4_irq_init>
  uart5_irq_init();
 8001fea:	f7ff ff51 	bl	8001e90 <uart5_irq_init>
  usart6_irq_init();
 8001fee:	f7ff ff57 	bl	8001ea0 <usart6_irq_init>
  uart7_irq_init();
 8001ff2:	f7ff ff5d 	bl	8001eb0 <uart7_irq_init>
  uart8_irq_init();
 8001ff6:	f7ff ff63 	bl	8001ec0 <uart8_irq_init>
  uart9_irq_init();
 8001ffa:	f7ff ff69 	bl	8001ed0 <uart9_irq_init>
  uart10_irq_init();
 8001ffe:	f7ff ff6f 	bl	8001ee0 <uart10_irq_init>
}
 8002002:	bf00      	nop
 8002004:	bd08      	pop	{r3, pc}
 8002006:	bf00      	nop
	...

08002010 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002010:	4b0d      	ldr	r3, [pc, #52]	; (8002048 <hal_lld_backup_domain_init+0x38>)
 8002012:	681b      	ldr	r3, [r3, #0]
 8002014:	4a0c      	ldr	r2, [pc, #48]	; (8002048 <hal_lld_backup_domain_init+0x38>)
 8002016:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800201a:	6013      	str	r3, [r2, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800201c:	4b0b      	ldr	r3, [pc, #44]	; (800204c <hal_lld_backup_domain_init+0x3c>)
 800201e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8002020:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8002024:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8002028:	d006      	beq.n	8002038 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 800202a:	4b08      	ldr	r3, [pc, #32]	; (800204c <hal_lld_backup_domain_init+0x3c>)
 800202c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8002030:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8002032:	4b06      	ldr	r3, [pc, #24]	; (800204c <hal_lld_backup_domain_init+0x3c>)
 8002034:	2200      	movs	r2, #0
 8002036:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8002038:	4b03      	ldr	r3, [pc, #12]	; (8002048 <hal_lld_backup_domain_init+0x38>)
 800203a:	685b      	ldr	r3, [r3, #4]
 800203c:	4a02      	ldr	r2, [pc, #8]	; (8002048 <hal_lld_backup_domain_init+0x38>)
 800203e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8002042:	6053      	str	r3, [r2, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
 8002044:	bf00      	nop
 8002046:	4770      	bx	lr
 8002048:	40007000 	.word	0x40007000
 800204c:	40023800 	.word	0x40023800

08002050 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8002050:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8002052:	4b26      	ldr	r3, [pc, #152]	; (80020ec <hal_lld_init+0x9c>)
 8002054:	691b      	ldr	r3, [r3, #16]
 8002056:	4a25      	ldr	r2, [pc, #148]	; (80020ec <hal_lld_init+0x9c>)
 8002058:	f063 031f 	orn	r3, r3, #31
 800205c:	6113      	str	r3, [r2, #16]
 800205e:	4b23      	ldr	r3, [pc, #140]	; (80020ec <hal_lld_init+0x9c>)
 8002060:	691b      	ldr	r3, [r3, #16]
 8002062:	4a22      	ldr	r2, [pc, #136]	; (80020ec <hal_lld_init+0x9c>)
 8002064:	f003 031f 	and.w	r3, r3, #31
 8002068:	6113      	str	r3, [r2, #16]
 800206a:	4b20      	ldr	r3, [pc, #128]	; (80020ec <hal_lld_init+0x9c>)
 800206c:	691b      	ldr	r3, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 800206e:	4b1f      	ldr	r3, [pc, #124]	; (80020ec <hal_lld_init+0x9c>)
 8002070:	695b      	ldr	r3, [r3, #20]
 8002072:	4b1e      	ldr	r3, [pc, #120]	; (80020ec <hal_lld_init+0x9c>)
 8002074:	f04f 32ff 	mov.w	r2, #4294967295
 8002078:	615a      	str	r2, [r3, #20]
 800207a:	4b1c      	ldr	r3, [pc, #112]	; (80020ec <hal_lld_init+0x9c>)
 800207c:	695b      	ldr	r3, [r3, #20]
 800207e:	4b1b      	ldr	r3, [pc, #108]	; (80020ec <hal_lld_init+0x9c>)
 8002080:	2200      	movs	r2, #0
 8002082:	615a      	str	r2, [r3, #20]
 8002084:	4b19      	ldr	r3, [pc, #100]	; (80020ec <hal_lld_init+0x9c>)
 8002086:	695b      	ldr	r3, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8002088:	4b18      	ldr	r3, [pc, #96]	; (80020ec <hal_lld_init+0x9c>)
 800208a:	6a1b      	ldr	r3, [r3, #32]
 800208c:	4a17      	ldr	r2, [pc, #92]	; (80020ec <hal_lld_init+0x9c>)
 800208e:	f063 5380 	orn	r3, r3, #268435456	; 0x10000000
 8002092:	6213      	str	r3, [r2, #32]
 8002094:	4b15      	ldr	r3, [pc, #84]	; (80020ec <hal_lld_init+0x9c>)
 8002096:	6a1b      	ldr	r3, [r3, #32]
 8002098:	4a14      	ldr	r2, [pc, #80]	; (80020ec <hal_lld_init+0x9c>)
 800209a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800209e:	6213      	str	r3, [r2, #32]
 80020a0:	4b12      	ldr	r3, [pc, #72]	; (80020ec <hal_lld_init+0x9c>)
 80020a2:	6a1b      	ldr	r3, [r3, #32]
  rccResetAPB2(~0);
 80020a4:	4b11      	ldr	r3, [pc, #68]	; (80020ec <hal_lld_init+0x9c>)
 80020a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80020a8:	4b10      	ldr	r3, [pc, #64]	; (80020ec <hal_lld_init+0x9c>)
 80020aa:	f04f 32ff 	mov.w	r2, #4294967295
 80020ae:	625a      	str	r2, [r3, #36]	; 0x24
 80020b0:	4b0e      	ldr	r3, [pc, #56]	; (80020ec <hal_lld_init+0x9c>)
 80020b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80020b4:	4b0d      	ldr	r3, [pc, #52]	; (80020ec <hal_lld_init+0x9c>)
 80020b6:	2200      	movs	r2, #0
 80020b8:	625a      	str	r2, [r3, #36]	; 0x24
 80020ba:	4b0c      	ldr	r3, [pc, #48]	; (80020ec <hal_lld_init+0x9c>)
 80020bc:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 80020be:	4b0b      	ldr	r3, [pc, #44]	; (80020ec <hal_lld_init+0x9c>)
 80020c0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80020c2:	4a0a      	ldr	r2, [pc, #40]	; (80020ec <hal_lld_init+0x9c>)
 80020c4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80020c8:	6413      	str	r3, [r2, #64]	; 0x40
 80020ca:	4b08      	ldr	r3, [pc, #32]	; (80020ec <hal_lld_init+0x9c>)
 80020cc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80020ce:	4a07      	ldr	r2, [pc, #28]	; (80020ec <hal_lld_init+0x9c>)
 80020d0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80020d4:	6613      	str	r3, [r2, #96]	; 0x60
 80020d6:	4b05      	ldr	r3, [pc, #20]	; (80020ec <hal_lld_init+0x9c>)
 80020d8:	6e1b      	ldr	r3, [r3, #96]	; 0x60

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 80020da:	f7ff ff99 	bl	8002010 <hal_lld_backup_domain_init>

  /* DMA subsystems initialization.*/
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 80020de:	f000 fb0f 	bl	8002700 <dmaInit>
#endif

  /* IRQ subsystem initialization.*/
  irqInit();
 80020e2:	f7ff ff4d 	bl	8001f80 <irqInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 80020e6:	bf00      	nop
 80020e8:	bd08      	pop	{r3, pc}
 80020ea:	bf00      	nop
 80020ec:	40023800 	.word	0x40023800

080020f0 <stm32_clock_init>:
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void stm32_clock_init(void) {
 80020f0:	b082      	sub	sp, #8
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 80020f2:	4b49      	ldr	r3, [pc, #292]	; (8002218 <stm32_clock_init+0x128>)
 80020f4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80020f8:	641a      	str	r2, [r3, #64]	; 0x40
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 80020fa:	4b48      	ldr	r3, [pc, #288]	; (800221c <stm32_clock_init+0x12c>)
 80020fc:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8002100:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8002102:	4b45      	ldr	r3, [pc, #276]	; (8002218 <stm32_clock_init+0x128>)
 8002104:	681b      	ldr	r3, [r3, #0]
 8002106:	4a44      	ldr	r2, [pc, #272]	; (8002218 <stm32_clock_init+0x128>)
 8002108:	f043 0301 	orr.w	r3, r3, #1
 800210c:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800210e:	bf00      	nop
 8002110:	4b41      	ldr	r3, [pc, #260]	; (8002218 <stm32_clock_init+0x128>)
 8002112:	681b      	ldr	r3, [r3, #0]
 8002114:	f003 0302 	and.w	r3, r3, #2
 8002118:	2b00      	cmp	r3, #0
 800211a:	d0f9      	beq.n	8002110 <stm32_clock_init+0x20>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 800211c:	4b3e      	ldr	r3, [pc, #248]	; (8002218 <stm32_clock_init+0x128>)
 800211e:	689b      	ldr	r3, [r3, #8]
 8002120:	4a3d      	ldr	r2, [pc, #244]	; (8002218 <stm32_clock_init+0x128>)
 8002122:	f023 0303 	bic.w	r3, r3, #3
 8002126:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8002128:	bf00      	nop
 800212a:	4b3b      	ldr	r3, [pc, #236]	; (8002218 <stm32_clock_init+0x128>)
 800212c:	689b      	ldr	r3, [r3, #8]
 800212e:	f003 030c 	and.w	r3, r3, #12
 8002132:	2b00      	cmp	r3, #0
 8002134:	d1f9      	bne.n	800212a <stm32_clock_init+0x3a>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8002136:	4b38      	ldr	r3, [pc, #224]	; (8002218 <stm32_clock_init+0x128>)
 8002138:	681b      	ldr	r3, [r3, #0]
 800213a:	4a37      	ldr	r2, [pc, #220]	; (8002218 <stm32_clock_init+0x128>)
 800213c:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 8002140:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8002142:	4b35      	ldr	r3, [pc, #212]	; (8002218 <stm32_clock_init+0x128>)
 8002144:	2200      	movs	r2, #0
 8002146:	609a      	str	r2, [r3, #8]
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8002148:	4b33      	ldr	r3, [pc, #204]	; (8002218 <stm32_clock_init+0x128>)
 800214a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800214c:	4a32      	ldr	r2, [pc, #200]	; (8002218 <stm32_clock_init+0x128>)
 800214e:	f043 0301 	orr.w	r3, r3, #1
 8002152:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8002154:	bf00      	nop
 8002156:	4b30      	ldr	r3, [pc, #192]	; (8002218 <stm32_clock_init+0x128>)
 8002158:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800215a:	f003 0302 	and.w	r3, r3, #2
 800215e:	2b00      	cmp	r3, #0
 8002160:	d0f9      	beq.n	8002156 <stm32_clock_init+0x66>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8002162:	4b2d      	ldr	r3, [pc, #180]	; (8002218 <stm32_clock_init+0x128>)
 8002164:	4a2e      	ldr	r2, [pc, #184]	; (8002220 <stm32_clock_init+0x130>)
 8002166:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8002168:	4b2b      	ldr	r3, [pc, #172]	; (8002218 <stm32_clock_init+0x128>)
 800216a:	681b      	ldr	r3, [r3, #0]
 800216c:	4a2a      	ldr	r2, [pc, #168]	; (8002218 <stm32_clock_init+0x128>)
 800216e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002172:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8002174:	bf00      	nop
 8002176:	4b29      	ldr	r3, [pc, #164]	; (800221c <stm32_clock_init+0x12c>)
 8002178:	685b      	ldr	r3, [r3, #4]
 800217a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800217e:	2b00      	cmp	r3, #0
 8002180:	d0f9      	beq.n	8002176 <stm32_clock_init+0x86>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8002182:	bf00      	nop
 8002184:	4b24      	ldr	r3, [pc, #144]	; (8002218 <stm32_clock_init+0x128>)
 8002186:	681b      	ldr	r3, [r3, #0]
 8002188:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800218c:	2b00      	cmp	r3, #0
 800218e:	d0f9      	beq.n	8002184 <stm32_clock_init+0x94>
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
#if !defined(STM32F413xx)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8002190:	4b21      	ldr	r3, [pc, #132]	; (8002218 <stm32_clock_init+0x128>)
 8002192:	4a24      	ldr	r2, [pc, #144]	; (8002224 <stm32_clock_init+0x134>)
 8002194:	609a      	str	r2, [r3, #8]

#if STM32_HAS_RCC_DCKCFGR
  /* DCKCFGR register initialization, note, must take care of the _OFF
   pseudo settings.*/
  {
    uint32_t dckcfgr = 0;
 8002196:	2300      	movs	r3, #0
 8002198:	9301      	str	r3, [sp, #4]
  /* Special case, in those devices STM32_CK48MSEL is located in the
     DCKCFGR register.*/
    dckcfgr |= STM32_CK48MSEL;
#endif
#if !defined(STM32F413xx)
    RCC->DCKCFGR = dckcfgr |
 800219a:	4a1f      	ldr	r2, [pc, #124]	; (8002218 <stm32_clock_init+0x128>)
                   STM32_TIMPRE | STM32_PLLSAIDIVQ | STM32_PLLI2SDIVQ;
 800219c:	9b01      	ldr	r3, [sp, #4]
 800219e:	f043 0303 	orr.w	r3, r3, #3
    RCC->DCKCFGR = dckcfgr |
 80021a2:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80021a6:	4b20      	ldr	r3, [pc, #128]	; (8002228 <stm32_clock_init+0x138>)
 80021a8:	681b      	ldr	r3, [r3, #0]
 80021aa:	4a20      	ldr	r2, [pc, #128]	; (800222c <stm32_clock_init+0x13c>)
 80021ac:	4293      	cmp	r3, r2
 80021ae:	d109      	bne.n	80021c4 <stm32_clock_init+0xd4>
 80021b0:	4b1f      	ldr	r3, [pc, #124]	; (8002230 <stm32_clock_init+0x140>)
 80021b2:	681b      	ldr	r3, [r3, #0]
 80021b4:	4a1f      	ldr	r2, [pc, #124]	; (8002234 <stm32_clock_init+0x144>)
 80021b6:	4293      	cmp	r3, r2
 80021b8:	d104      	bne.n	80021c4 <stm32_clock_init+0xd4>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 80021ba:	4b1f      	ldr	r3, [pc, #124]	; (8002238 <stm32_clock_init+0x148>)
 80021bc:	f44f 7281 	mov.w	r2, #258	; 0x102
 80021c0:	601a      	str	r2, [r3, #0]
 80021c2:	e003      	b.n	80021cc <stm32_clock_init+0xdc>
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80021c4:	4b1c      	ldr	r3, [pc, #112]	; (8002238 <stm32_clock_init+0x148>)
 80021c6:	f240 7202 	movw	r2, #1794	; 0x702
 80021ca:	601a      	str	r2, [r3, #0]
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 80021cc:	bf00      	nop
 80021ce:	4b1a      	ldr	r3, [pc, #104]	; (8002238 <stm32_clock_init+0x148>)
 80021d0:	681b      	ldr	r3, [r3, #0]
 80021d2:	f003 030f 	and.w	r3, r3, #15
 80021d6:	2b02      	cmp	r3, #2
 80021d8:	d1f9      	bne.n	80021ce <stm32_clock_init+0xde>
         (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80021da:	4b0f      	ldr	r3, [pc, #60]	; (8002218 <stm32_clock_init+0x128>)
 80021dc:	689b      	ldr	r3, [r3, #8]
 80021de:	4a0e      	ldr	r2, [pc, #56]	; (8002218 <stm32_clock_init+0x128>)
 80021e0:	f043 0302 	orr.w	r3, r3, #2
 80021e4:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80021e6:	bf00      	nop
 80021e8:	4b0b      	ldr	r3, [pc, #44]	; (8002218 <stm32_clock_init+0x128>)
 80021ea:	689b      	ldr	r3, [r3, #8]
 80021ec:	f003 030c 	and.w	r3, r3, #12
 80021f0:	2b08      	cmp	r3, #8
 80021f2:	d1f9      	bne.n	80021e8 <stm32_clock_init+0xf8>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 80021f4:	4b08      	ldr	r3, [pc, #32]	; (8002218 <stm32_clock_init+0x128>)
 80021f6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80021f8:	4a07      	ldr	r2, [pc, #28]	; (8002218 <stm32_clock_init+0x128>)
 80021fa:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80021fe:	6453      	str	r3, [r2, #68]	; 0x44
 8002200:	4b05      	ldr	r3, [pc, #20]	; (8002218 <stm32_clock_init+0x128>)
 8002202:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8002204:	4a04      	ldr	r2, [pc, #16]	; (8002218 <stm32_clock_init+0x128>)
 8002206:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800220a:	6653      	str	r3, [r2, #100]	; 0x64
 800220c:	4b02      	ldr	r3, [pc, #8]	; (8002218 <stm32_clock_init+0x128>)
 800220e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
}
 8002210:	bf00      	nop
 8002212:	b002      	add	sp, #8
 8002214:	4770      	bx	lr
 8002216:	bf00      	nop
 8002218:	40023800 	.word	0x40023800
 800221c:	40007000 	.word	0x40007000
 8002220:	07015410 	.word	0x07015410
 8002224:	38881000 	.word	0x38881000
 8002228:	e0042000 	.word	0xe0042000
 800222c:	20006411 	.word	0x20006411
 8002230:	e000ed00 	.word	0xe000ed00
 8002234:	410fc241 	.word	0x410fc241
 8002238:	40023c00 	.word	0x40023c00
 800223c:	00000000 	.word	0x00000000

08002240 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8002240:	b500      	push	{lr}
 8002242:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002244:	4b0c      	ldr	r3, [pc, #48]	; (8002278 <Vector6C+0x38>)
 8002246:	681b      	ldr	r3, [r3, #0]
 8002248:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800224c:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0U;
 800224e:	4a0a      	ldr	r2, [pc, #40]	; (8002278 <Vector6C+0x38>)
 8002250:	9b01      	ldr	r3, [sp, #4]
 8002252:	6093      	str	r3, [r2, #8]
  if (dma.streams[0].func)
 8002254:	4b09      	ldr	r3, [pc, #36]	; (800227c <Vector6C+0x3c>)
 8002256:	685b      	ldr	r3, [r3, #4]
 8002258:	2b00      	cmp	r3, #0
 800225a:	d006      	beq.n	800226a <Vector6C+0x2a>
    dma.streams[0].func(dma.streams[0].param, flags);
 800225c:	4b07      	ldr	r3, [pc, #28]	; (800227c <Vector6C+0x3c>)
 800225e:	685b      	ldr	r3, [r3, #4]
 8002260:	4a06      	ldr	r2, [pc, #24]	; (800227c <Vector6C+0x3c>)
 8002262:	6892      	ldr	r2, [r2, #8]
 8002264:	9901      	ldr	r1, [sp, #4]
 8002266:	4610      	mov	r0, r2
 8002268:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800226a:	f002 fdb9 	bl	8004de0 <__port_irq_epilogue>
}
 800226e:	bf00      	nop
 8002270:	b003      	add	sp, #12
 8002272:	f85d fb04 	ldr.w	pc, [sp], #4
 8002276:	bf00      	nop
 8002278:	40026000 	.word	0x40026000
 800227c:	20000c58 	.word	0x20000c58

08002280 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8002280:	b500      	push	{lr}
 8002282:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002284:	4b0d      	ldr	r3, [pc, #52]	; (80022bc <Vector70+0x3c>)
 8002286:	681b      	ldr	r3, [r3, #0]
 8002288:	099b      	lsrs	r3, r3, #6
 800228a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800228e:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6U;
 8002290:	4a0a      	ldr	r2, [pc, #40]	; (80022bc <Vector70+0x3c>)
 8002292:	9b01      	ldr	r3, [sp, #4]
 8002294:	019b      	lsls	r3, r3, #6
 8002296:	6093      	str	r3, [r2, #8]
  if (dma.streams[1].func)
 8002298:	4b09      	ldr	r3, [pc, #36]	; (80022c0 <Vector70+0x40>)
 800229a:	68db      	ldr	r3, [r3, #12]
 800229c:	2b00      	cmp	r3, #0
 800229e:	d006      	beq.n	80022ae <Vector70+0x2e>
    dma.streams[1].func(dma.streams[1].param, flags);
 80022a0:	4b07      	ldr	r3, [pc, #28]	; (80022c0 <Vector70+0x40>)
 80022a2:	68db      	ldr	r3, [r3, #12]
 80022a4:	4a06      	ldr	r2, [pc, #24]	; (80022c0 <Vector70+0x40>)
 80022a6:	6912      	ldr	r2, [r2, #16]
 80022a8:	9901      	ldr	r1, [sp, #4]
 80022aa:	4610      	mov	r0, r2
 80022ac:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80022ae:	f002 fd97 	bl	8004de0 <__port_irq_epilogue>
}
 80022b2:	bf00      	nop
 80022b4:	b003      	add	sp, #12
 80022b6:	f85d fb04 	ldr.w	pc, [sp], #4
 80022ba:	bf00      	nop
 80022bc:	40026000 	.word	0x40026000
 80022c0:	20000c58 	.word	0x20000c58
	...

080022d0 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 80022d0:	b500      	push	{lr}
 80022d2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80022d4:	4b0d      	ldr	r3, [pc, #52]	; (800230c <Vector74+0x3c>)
 80022d6:	681b      	ldr	r3, [r3, #0]
 80022d8:	0c1b      	lsrs	r3, r3, #16
 80022da:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80022de:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16U;
 80022e0:	4a0a      	ldr	r2, [pc, #40]	; (800230c <Vector74+0x3c>)
 80022e2:	9b01      	ldr	r3, [sp, #4]
 80022e4:	041b      	lsls	r3, r3, #16
 80022e6:	6093      	str	r3, [r2, #8]
  if (dma.streams[2].func)
 80022e8:	4b09      	ldr	r3, [pc, #36]	; (8002310 <Vector74+0x40>)
 80022ea:	695b      	ldr	r3, [r3, #20]
 80022ec:	2b00      	cmp	r3, #0
 80022ee:	d006      	beq.n	80022fe <Vector74+0x2e>
    dma.streams[2].func(dma.streams[2].param, flags);
 80022f0:	4b07      	ldr	r3, [pc, #28]	; (8002310 <Vector74+0x40>)
 80022f2:	695b      	ldr	r3, [r3, #20]
 80022f4:	4a06      	ldr	r2, [pc, #24]	; (8002310 <Vector74+0x40>)
 80022f6:	6992      	ldr	r2, [r2, #24]
 80022f8:	9901      	ldr	r1, [sp, #4]
 80022fa:	4610      	mov	r0, r2
 80022fc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80022fe:	f002 fd6f 	bl	8004de0 <__port_irq_epilogue>
}
 8002302:	bf00      	nop
 8002304:	b003      	add	sp, #12
 8002306:	f85d fb04 	ldr.w	pc, [sp], #4
 800230a:	bf00      	nop
 800230c:	40026000 	.word	0x40026000
 8002310:	20000c58 	.word	0x20000c58
	...

08002320 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8002320:	b500      	push	{lr}
 8002322:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002324:	4b0d      	ldr	r3, [pc, #52]	; (800235c <Vector78+0x3c>)
 8002326:	681b      	ldr	r3, [r3, #0]
 8002328:	0d9b      	lsrs	r3, r3, #22
 800232a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800232e:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22U;
 8002330:	4a0a      	ldr	r2, [pc, #40]	; (800235c <Vector78+0x3c>)
 8002332:	9b01      	ldr	r3, [sp, #4]
 8002334:	059b      	lsls	r3, r3, #22
 8002336:	6093      	str	r3, [r2, #8]
  if (dma.streams[3].func)
 8002338:	4b09      	ldr	r3, [pc, #36]	; (8002360 <Vector78+0x40>)
 800233a:	69db      	ldr	r3, [r3, #28]
 800233c:	2b00      	cmp	r3, #0
 800233e:	d006      	beq.n	800234e <Vector78+0x2e>
    dma.streams[3].func(dma.streams[3].param, flags);
 8002340:	4b07      	ldr	r3, [pc, #28]	; (8002360 <Vector78+0x40>)
 8002342:	69db      	ldr	r3, [r3, #28]
 8002344:	4a06      	ldr	r2, [pc, #24]	; (8002360 <Vector78+0x40>)
 8002346:	6a12      	ldr	r2, [r2, #32]
 8002348:	9901      	ldr	r1, [sp, #4]
 800234a:	4610      	mov	r0, r2
 800234c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800234e:	f002 fd47 	bl	8004de0 <__port_irq_epilogue>
}
 8002352:	bf00      	nop
 8002354:	b003      	add	sp, #12
 8002356:	f85d fb04 	ldr.w	pc, [sp], #4
 800235a:	bf00      	nop
 800235c:	40026000 	.word	0x40026000
 8002360:	20000c58 	.word	0x20000c58
	...

08002370 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8002370:	b500      	push	{lr}
 8002372:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002374:	4b0c      	ldr	r3, [pc, #48]	; (80023a8 <Vector7C+0x38>)
 8002376:	685b      	ldr	r3, [r3, #4]
 8002378:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800237c:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0U;
 800237e:	4a0a      	ldr	r2, [pc, #40]	; (80023a8 <Vector7C+0x38>)
 8002380:	9b01      	ldr	r3, [sp, #4]
 8002382:	60d3      	str	r3, [r2, #12]
  if (dma.streams[4].func)
 8002384:	4b09      	ldr	r3, [pc, #36]	; (80023ac <Vector7C+0x3c>)
 8002386:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002388:	2b00      	cmp	r3, #0
 800238a:	d006      	beq.n	800239a <Vector7C+0x2a>
    dma.streams[4].func(dma.streams[4].param, flags);
 800238c:	4b07      	ldr	r3, [pc, #28]	; (80023ac <Vector7C+0x3c>)
 800238e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002390:	4a06      	ldr	r2, [pc, #24]	; (80023ac <Vector7C+0x3c>)
 8002392:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8002394:	9901      	ldr	r1, [sp, #4]
 8002396:	4610      	mov	r0, r2
 8002398:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800239a:	f002 fd21 	bl	8004de0 <__port_irq_epilogue>
}
 800239e:	bf00      	nop
 80023a0:	b003      	add	sp, #12
 80023a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80023a6:	bf00      	nop
 80023a8:	40026000 	.word	0x40026000
 80023ac:	20000c58 	.word	0x20000c58

080023b0 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 80023b0:	b500      	push	{lr}
 80023b2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80023b4:	4b0d      	ldr	r3, [pc, #52]	; (80023ec <Vector80+0x3c>)
 80023b6:	685b      	ldr	r3, [r3, #4]
 80023b8:	099b      	lsrs	r3, r3, #6
 80023ba:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80023be:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6U;
 80023c0:	4a0a      	ldr	r2, [pc, #40]	; (80023ec <Vector80+0x3c>)
 80023c2:	9b01      	ldr	r3, [sp, #4]
 80023c4:	019b      	lsls	r3, r3, #6
 80023c6:	60d3      	str	r3, [r2, #12]
  if (dma.streams[5].func)
 80023c8:	4b09      	ldr	r3, [pc, #36]	; (80023f0 <Vector80+0x40>)
 80023ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80023cc:	2b00      	cmp	r3, #0
 80023ce:	d006      	beq.n	80023de <Vector80+0x2e>
    dma.streams[5].func(dma.streams[5].param, flags);
 80023d0:	4b07      	ldr	r3, [pc, #28]	; (80023f0 <Vector80+0x40>)
 80023d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80023d4:	4a06      	ldr	r2, [pc, #24]	; (80023f0 <Vector80+0x40>)
 80023d6:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80023d8:	9901      	ldr	r1, [sp, #4]
 80023da:	4610      	mov	r0, r2
 80023dc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80023de:	f002 fcff 	bl	8004de0 <__port_irq_epilogue>
}
 80023e2:	bf00      	nop
 80023e4:	b003      	add	sp, #12
 80023e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80023ea:	bf00      	nop
 80023ec:	40026000 	.word	0x40026000
 80023f0:	20000c58 	.word	0x20000c58
	...

08002400 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8002400:	b500      	push	{lr}
 8002402:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002404:	4b0d      	ldr	r3, [pc, #52]	; (800243c <Vector84+0x3c>)
 8002406:	685b      	ldr	r3, [r3, #4]
 8002408:	0c1b      	lsrs	r3, r3, #16
 800240a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800240e:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16U;
 8002410:	4a0a      	ldr	r2, [pc, #40]	; (800243c <Vector84+0x3c>)
 8002412:	9b01      	ldr	r3, [sp, #4]
 8002414:	041b      	lsls	r3, r3, #16
 8002416:	60d3      	str	r3, [r2, #12]
  if (dma.streams[6].func)
 8002418:	4b09      	ldr	r3, [pc, #36]	; (8002440 <Vector84+0x40>)
 800241a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800241c:	2b00      	cmp	r3, #0
 800241e:	d006      	beq.n	800242e <Vector84+0x2e>
    dma.streams[6].func(dma.streams[6].param, flags);
 8002420:	4b07      	ldr	r3, [pc, #28]	; (8002440 <Vector84+0x40>)
 8002422:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002424:	4a06      	ldr	r2, [pc, #24]	; (8002440 <Vector84+0x40>)
 8002426:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8002428:	9901      	ldr	r1, [sp, #4]
 800242a:	4610      	mov	r0, r2
 800242c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800242e:	f002 fcd7 	bl	8004de0 <__port_irq_epilogue>
}
 8002432:	bf00      	nop
 8002434:	b003      	add	sp, #12
 8002436:	f85d fb04 	ldr.w	pc, [sp], #4
 800243a:	bf00      	nop
 800243c:	40026000 	.word	0x40026000
 8002440:	20000c58 	.word	0x20000c58
	...

08002450 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8002450:	b500      	push	{lr}
 8002452:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002454:	4b0d      	ldr	r3, [pc, #52]	; (800248c <VectorFC+0x3c>)
 8002456:	685b      	ldr	r3, [r3, #4]
 8002458:	0d9b      	lsrs	r3, r3, #22
 800245a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800245e:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22U;
 8002460:	4a0a      	ldr	r2, [pc, #40]	; (800248c <VectorFC+0x3c>)
 8002462:	9b01      	ldr	r3, [sp, #4]
 8002464:	059b      	lsls	r3, r3, #22
 8002466:	60d3      	str	r3, [r2, #12]
  if (dma.streams[7].func)
 8002468:	4b09      	ldr	r3, [pc, #36]	; (8002490 <VectorFC+0x40>)
 800246a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800246c:	2b00      	cmp	r3, #0
 800246e:	d006      	beq.n	800247e <VectorFC+0x2e>
    dma.streams[7].func(dma.streams[7].param, flags);
 8002470:	4b07      	ldr	r3, [pc, #28]	; (8002490 <VectorFC+0x40>)
 8002472:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002474:	4a06      	ldr	r2, [pc, #24]	; (8002490 <VectorFC+0x40>)
 8002476:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8002478:	9901      	ldr	r1, [sp, #4]
 800247a:	4610      	mov	r0, r2
 800247c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800247e:	f002 fcaf 	bl	8004de0 <__port_irq_epilogue>
}
 8002482:	bf00      	nop
 8002484:	b003      	add	sp, #12
 8002486:	f85d fb04 	ldr.w	pc, [sp], #4
 800248a:	bf00      	nop
 800248c:	40026000 	.word	0x40026000
 8002490:	20000c58 	.word	0x20000c58
	...

080024a0 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 80024a0:	b500      	push	{lr}
 80024a2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80024a4:	4b0c      	ldr	r3, [pc, #48]	; (80024d8 <Vector120+0x38>)
 80024a6:	681b      	ldr	r3, [r3, #0]
 80024a8:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80024ac:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0U;
 80024ae:	4a0a      	ldr	r2, [pc, #40]	; (80024d8 <Vector120+0x38>)
 80024b0:	9b01      	ldr	r3, [sp, #4]
 80024b2:	6093      	str	r3, [r2, #8]
  if (dma.streams[8].func)
 80024b4:	4b09      	ldr	r3, [pc, #36]	; (80024dc <Vector120+0x3c>)
 80024b6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80024b8:	2b00      	cmp	r3, #0
 80024ba:	d006      	beq.n	80024ca <Vector120+0x2a>
    dma.streams[8].func(dma.streams[8].param, flags);
 80024bc:	4b07      	ldr	r3, [pc, #28]	; (80024dc <Vector120+0x3c>)
 80024be:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80024c0:	4a06      	ldr	r2, [pc, #24]	; (80024dc <Vector120+0x3c>)
 80024c2:	6c92      	ldr	r2, [r2, #72]	; 0x48
 80024c4:	9901      	ldr	r1, [sp, #4]
 80024c6:	4610      	mov	r0, r2
 80024c8:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80024ca:	f002 fc89 	bl	8004de0 <__port_irq_epilogue>
}
 80024ce:	bf00      	nop
 80024d0:	b003      	add	sp, #12
 80024d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80024d6:	bf00      	nop
 80024d8:	40026400 	.word	0x40026400
 80024dc:	20000c58 	.word	0x20000c58

080024e0 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 80024e0:	b500      	push	{lr}
 80024e2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 80024e4:	4b0d      	ldr	r3, [pc, #52]	; (800251c <Vector124+0x3c>)
 80024e6:	681b      	ldr	r3, [r3, #0]
 80024e8:	099b      	lsrs	r3, r3, #6
 80024ea:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80024ee:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6U;
 80024f0:	4a0a      	ldr	r2, [pc, #40]	; (800251c <Vector124+0x3c>)
 80024f2:	9b01      	ldr	r3, [sp, #4]
 80024f4:	019b      	lsls	r3, r3, #6
 80024f6:	6093      	str	r3, [r2, #8]
  if (dma.streams[9].func)
 80024f8:	4b09      	ldr	r3, [pc, #36]	; (8002520 <Vector124+0x40>)
 80024fa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80024fc:	2b00      	cmp	r3, #0
 80024fe:	d006      	beq.n	800250e <Vector124+0x2e>
    dma.streams[9].func(dma.streams[9].param, flags);
 8002500:	4b07      	ldr	r3, [pc, #28]	; (8002520 <Vector124+0x40>)
 8002502:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8002504:	4a06      	ldr	r2, [pc, #24]	; (8002520 <Vector124+0x40>)
 8002506:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8002508:	9901      	ldr	r1, [sp, #4]
 800250a:	4610      	mov	r0, r2
 800250c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800250e:	f002 fc67 	bl	8004de0 <__port_irq_epilogue>
}
 8002512:	bf00      	nop
 8002514:	b003      	add	sp, #12
 8002516:	f85d fb04 	ldr.w	pc, [sp], #4
 800251a:	bf00      	nop
 800251c:	40026400 	.word	0x40026400
 8002520:	20000c58 	.word	0x20000c58
	...

08002530 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8002530:	b500      	push	{lr}
 8002532:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002534:	4b0d      	ldr	r3, [pc, #52]	; (800256c <Vector128+0x3c>)
 8002536:	681b      	ldr	r3, [r3, #0]
 8002538:	0c1b      	lsrs	r3, r3, #16
 800253a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800253e:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16U;
 8002540:	4a0a      	ldr	r2, [pc, #40]	; (800256c <Vector128+0x3c>)
 8002542:	9b01      	ldr	r3, [sp, #4]
 8002544:	041b      	lsls	r3, r3, #16
 8002546:	6093      	str	r3, [r2, #8]
  if (dma.streams[10].func)
 8002548:	4b09      	ldr	r3, [pc, #36]	; (8002570 <Vector128+0x40>)
 800254a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800254c:	2b00      	cmp	r3, #0
 800254e:	d006      	beq.n	800255e <Vector128+0x2e>
    dma.streams[10].func(dma.streams[10].param, flags);
 8002550:	4b07      	ldr	r3, [pc, #28]	; (8002570 <Vector128+0x40>)
 8002552:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002554:	4a06      	ldr	r2, [pc, #24]	; (8002570 <Vector128+0x40>)
 8002556:	6d92      	ldr	r2, [r2, #88]	; 0x58
 8002558:	9901      	ldr	r1, [sp, #4]
 800255a:	4610      	mov	r0, r2
 800255c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800255e:	f002 fc3f 	bl	8004de0 <__port_irq_epilogue>
}
 8002562:	bf00      	nop
 8002564:	b003      	add	sp, #12
 8002566:	f85d fb04 	ldr.w	pc, [sp], #4
 800256a:	bf00      	nop
 800256c:	40026400 	.word	0x40026400
 8002570:	20000c58 	.word	0x20000c58
	...

08002580 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8002580:	b500      	push	{lr}
 8002582:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002584:	4b0d      	ldr	r3, [pc, #52]	; (80025bc <Vector12C+0x3c>)
 8002586:	681b      	ldr	r3, [r3, #0]
 8002588:	0d9b      	lsrs	r3, r3, #22
 800258a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800258e:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22U;
 8002590:	4a0a      	ldr	r2, [pc, #40]	; (80025bc <Vector12C+0x3c>)
 8002592:	9b01      	ldr	r3, [sp, #4]
 8002594:	059b      	lsls	r3, r3, #22
 8002596:	6093      	str	r3, [r2, #8]
  if (dma.streams[11].func)
 8002598:	4b09      	ldr	r3, [pc, #36]	; (80025c0 <Vector12C+0x40>)
 800259a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800259c:	2b00      	cmp	r3, #0
 800259e:	d006      	beq.n	80025ae <Vector12C+0x2e>
    dma.streams[11].func(dma.streams[11].param, flags);
 80025a0:	4b07      	ldr	r3, [pc, #28]	; (80025c0 <Vector12C+0x40>)
 80025a2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80025a4:	4a06      	ldr	r2, [pc, #24]	; (80025c0 <Vector12C+0x40>)
 80025a6:	6e12      	ldr	r2, [r2, #96]	; 0x60
 80025a8:	9901      	ldr	r1, [sp, #4]
 80025aa:	4610      	mov	r0, r2
 80025ac:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80025ae:	f002 fc17 	bl	8004de0 <__port_irq_epilogue>
}
 80025b2:	bf00      	nop
 80025b4:	b003      	add	sp, #12
 80025b6:	f85d fb04 	ldr.w	pc, [sp], #4
 80025ba:	bf00      	nop
 80025bc:	40026400 	.word	0x40026400
 80025c0:	20000c58 	.word	0x20000c58
	...

080025d0 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 80025d0:	b500      	push	{lr}
 80025d2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 80025d4:	4b0c      	ldr	r3, [pc, #48]	; (8002608 <Vector130+0x38>)
 80025d6:	685b      	ldr	r3, [r3, #4]
 80025d8:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80025dc:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0U;
 80025de:	4a0a      	ldr	r2, [pc, #40]	; (8002608 <Vector130+0x38>)
 80025e0:	9b01      	ldr	r3, [sp, #4]
 80025e2:	60d3      	str	r3, [r2, #12]
  if (dma.streams[12].func)
 80025e4:	4b09      	ldr	r3, [pc, #36]	; (800260c <Vector130+0x3c>)
 80025e6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80025e8:	2b00      	cmp	r3, #0
 80025ea:	d006      	beq.n	80025fa <Vector130+0x2a>
    dma.streams[12].func(dma.streams[12].param, flags);
 80025ec:	4b07      	ldr	r3, [pc, #28]	; (800260c <Vector130+0x3c>)
 80025ee:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80025f0:	4a06      	ldr	r2, [pc, #24]	; (800260c <Vector130+0x3c>)
 80025f2:	6e92      	ldr	r2, [r2, #104]	; 0x68
 80025f4:	9901      	ldr	r1, [sp, #4]
 80025f6:	4610      	mov	r0, r2
 80025f8:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80025fa:	f002 fbf1 	bl	8004de0 <__port_irq_epilogue>
}
 80025fe:	bf00      	nop
 8002600:	b003      	add	sp, #12
 8002602:	f85d fb04 	ldr.w	pc, [sp], #4
 8002606:	bf00      	nop
 8002608:	40026400 	.word	0x40026400
 800260c:	20000c58 	.word	0x20000c58

08002610 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8002610:	b500      	push	{lr}
 8002612:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002614:	4b0d      	ldr	r3, [pc, #52]	; (800264c <Vector150+0x3c>)
 8002616:	685b      	ldr	r3, [r3, #4]
 8002618:	099b      	lsrs	r3, r3, #6
 800261a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800261e:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6U;
 8002620:	4a0a      	ldr	r2, [pc, #40]	; (800264c <Vector150+0x3c>)
 8002622:	9b01      	ldr	r3, [sp, #4]
 8002624:	019b      	lsls	r3, r3, #6
 8002626:	60d3      	str	r3, [r2, #12]
  if (dma.streams[13].func)
 8002628:	4b09      	ldr	r3, [pc, #36]	; (8002650 <Vector150+0x40>)
 800262a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800262c:	2b00      	cmp	r3, #0
 800262e:	d006      	beq.n	800263e <Vector150+0x2e>
    dma.streams[13].func(dma.streams[13].param, flags);
 8002630:	4b07      	ldr	r3, [pc, #28]	; (8002650 <Vector150+0x40>)
 8002632:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8002634:	4a06      	ldr	r2, [pc, #24]	; (8002650 <Vector150+0x40>)
 8002636:	6f12      	ldr	r2, [r2, #112]	; 0x70
 8002638:	9901      	ldr	r1, [sp, #4]
 800263a:	4610      	mov	r0, r2
 800263c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800263e:	f002 fbcf 	bl	8004de0 <__port_irq_epilogue>
}
 8002642:	bf00      	nop
 8002644:	b003      	add	sp, #12
 8002646:	f85d fb04 	ldr.w	pc, [sp], #4
 800264a:	bf00      	nop
 800264c:	40026400 	.word	0x40026400
 8002650:	20000c58 	.word	0x20000c58
	...

08002660 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8002660:	b500      	push	{lr}
 8002662:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002664:	4b0d      	ldr	r3, [pc, #52]	; (800269c <Vector154+0x3c>)
 8002666:	685b      	ldr	r3, [r3, #4]
 8002668:	0c1b      	lsrs	r3, r3, #16
 800266a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800266e:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16U;
 8002670:	4a0a      	ldr	r2, [pc, #40]	; (800269c <Vector154+0x3c>)
 8002672:	9b01      	ldr	r3, [sp, #4]
 8002674:	041b      	lsls	r3, r3, #16
 8002676:	60d3      	str	r3, [r2, #12]
  if (dma.streams[14].func)
 8002678:	4b09      	ldr	r3, [pc, #36]	; (80026a0 <Vector154+0x40>)
 800267a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800267c:	2b00      	cmp	r3, #0
 800267e:	d006      	beq.n	800268e <Vector154+0x2e>
    dma.streams[14].func(dma.streams[14].param, flags);
 8002680:	4b07      	ldr	r3, [pc, #28]	; (80026a0 <Vector154+0x40>)
 8002682:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8002684:	4a06      	ldr	r2, [pc, #24]	; (80026a0 <Vector154+0x40>)
 8002686:	6f92      	ldr	r2, [r2, #120]	; 0x78
 8002688:	9901      	ldr	r1, [sp, #4]
 800268a:	4610      	mov	r0, r2
 800268c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800268e:	f002 fba7 	bl	8004de0 <__port_irq_epilogue>
}
 8002692:	bf00      	nop
 8002694:	b003      	add	sp, #12
 8002696:	f85d fb04 	ldr.w	pc, [sp], #4
 800269a:	bf00      	nop
 800269c:	40026400 	.word	0x40026400
 80026a0:	20000c58 	.word	0x20000c58
	...

080026b0 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 80026b0:	b500      	push	{lr}
 80026b2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80026b4:	4b0d      	ldr	r3, [pc, #52]	; (80026ec <Vector158+0x3c>)
 80026b6:	685b      	ldr	r3, [r3, #4]
 80026b8:	0d9b      	lsrs	r3, r3, #22
 80026ba:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80026be:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22U;
 80026c0:	4a0a      	ldr	r2, [pc, #40]	; (80026ec <Vector158+0x3c>)
 80026c2:	9b01      	ldr	r3, [sp, #4]
 80026c4:	059b      	lsls	r3, r3, #22
 80026c6:	60d3      	str	r3, [r2, #12]
  if (dma.streams[15].func)
 80026c8:	4b09      	ldr	r3, [pc, #36]	; (80026f0 <Vector158+0x40>)
 80026ca:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80026cc:	2b00      	cmp	r3, #0
 80026ce:	d007      	beq.n	80026e0 <Vector158+0x30>
    dma.streams[15].func(dma.streams[15].param, flags);
 80026d0:	4b07      	ldr	r3, [pc, #28]	; (80026f0 <Vector158+0x40>)
 80026d2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80026d4:	4a06      	ldr	r2, [pc, #24]	; (80026f0 <Vector158+0x40>)
 80026d6:	f8d2 2080 	ldr.w	r2, [r2, #128]	; 0x80
 80026da:	9901      	ldr	r1, [sp, #4]
 80026dc:	4610      	mov	r0, r2
 80026de:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80026e0:	f002 fb7e 	bl	8004de0 <__port_irq_epilogue>
}
 80026e4:	bf00      	nop
 80026e6:	b003      	add	sp, #12
 80026e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80026ec:	40026400 	.word	0x40026400
 80026f0:	20000c58 	.word	0x20000c58
	...

08002700 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8002700:	b082      	sub	sp, #8
  unsigned i;

  dma.allocated_mask = 0U;
 8002702:	4b17      	ldr	r3, [pc, #92]	; (8002760 <dmaInit+0x60>)
 8002704:	2200      	movs	r2, #0
 8002706:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8002708:	2300      	movs	r3, #0
 800270a:	9301      	str	r3, [sp, #4]
 800270c:	e012      	b.n	8002734 <dmaInit+0x34>
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 800270e:	4915      	ldr	r1, [pc, #84]	; (8002764 <dmaInit+0x64>)
 8002710:	9a01      	ldr	r2, [sp, #4]
 8002712:	4613      	mov	r3, r2
 8002714:	005b      	lsls	r3, r3, #1
 8002716:	4413      	add	r3, r2
 8002718:	009b      	lsls	r3, r3, #2
 800271a:	440b      	add	r3, r1
 800271c:	681b      	ldr	r3, [r3, #0]
 800271e:	2200      	movs	r2, #0
 8002720:	601a      	str	r2, [r3, #0]
    dma.streams[i].func = NULL;
 8002722:	4a0f      	ldr	r2, [pc, #60]	; (8002760 <dmaInit+0x60>)
 8002724:	9b01      	ldr	r3, [sp, #4]
 8002726:	00db      	lsls	r3, r3, #3
 8002728:	4413      	add	r3, r2
 800272a:	2200      	movs	r2, #0
 800272c:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 800272e:	9b01      	ldr	r3, [sp, #4]
 8002730:	3301      	adds	r3, #1
 8002732:	9301      	str	r3, [sp, #4]
 8002734:	9b01      	ldr	r3, [sp, #4]
 8002736:	2b0f      	cmp	r3, #15
 8002738:	d9e9      	bls.n	800270e <dmaInit+0xe>
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 800273a:	4b0b      	ldr	r3, [pc, #44]	; (8002768 <dmaInit+0x68>)
 800273c:	f04f 32ff 	mov.w	r2, #4294967295
 8002740:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 8002742:	4b09      	ldr	r3, [pc, #36]	; (8002768 <dmaInit+0x68>)
 8002744:	f04f 32ff 	mov.w	r2, #4294967295
 8002748:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 800274a:	4b08      	ldr	r3, [pc, #32]	; (800276c <dmaInit+0x6c>)
 800274c:	f04f 32ff 	mov.w	r2, #4294967295
 8002750:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 8002752:	4b06      	ldr	r3, [pc, #24]	; (800276c <dmaInit+0x6c>)
 8002754:	f04f 32ff 	mov.w	r2, #4294967295
 8002758:	60da      	str	r2, [r3, #12]
}
 800275a:	bf00      	nop
 800275c:	b002      	add	sp, #8
 800275e:	4770      	bx	lr
 8002760:	20000c58 	.word	0x20000c58
 8002764:	08006dcc 	.word	0x08006dcc
 8002768:	40026000 	.word	0x40026000
 800276c:	40026400 	.word	0x40026400

08002770 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 8002770:	b500      	push	{lr}
 8002772:	b08b      	sub	sp, #44	; 0x2c
 8002774:	9003      	str	r0, [sp, #12]
 8002776:	9102      	str	r1, [sp, #8]
 8002778:	9201      	str	r2, [sp, #4]
 800277a:	9300      	str	r3, [sp, #0]
  uint32_t i, startid, endid;

  osalDbgCheckClassI();

  if (id < STM32_DMA_STREAMS) {
 800277c:	9b03      	ldr	r3, [sp, #12]
 800277e:	2b0f      	cmp	r3, #15
 8002780:	d806      	bhi.n	8002790 <dmaStreamAllocI+0x20>
    startid = id;
 8002782:	9b03      	ldr	r3, [sp, #12]
 8002784:	9308      	str	r3, [sp, #32]
    endid   = id;
 8002786:	9b03      	ldr	r3, [sp, #12]
 8002788:	9307      	str	r3, [sp, #28]
  else {
    osalDbgCheck(false);
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
 800278a:	9b08      	ldr	r3, [sp, #32]
 800278c:	9309      	str	r3, [sp, #36]	; 0x24
 800278e:	e078      	b.n	8002882 <dmaStreamAllocI+0x112>
    return NULL;
 8002790:	2300      	movs	r3, #0
 8002792:	e07b      	b.n	800288c <dmaStreamAllocI+0x11c>
    uint32_t mask = (1U << i);
 8002794:	2201      	movs	r2, #1
 8002796:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002798:	fa02 f303 	lsl.w	r3, r2, r3
 800279c:	9306      	str	r3, [sp, #24]
    if ((dma.allocated_mask & mask) == 0U) {
 800279e:	4b3d      	ldr	r3, [pc, #244]	; (8002894 <dmaStreamAllocI+0x124>)
 80027a0:	681a      	ldr	r2, [r3, #0]
 80027a2:	9b06      	ldr	r3, [sp, #24]
 80027a4:	4013      	ands	r3, r2
 80027a6:	2b00      	cmp	r3, #0
 80027a8:	d168      	bne.n	800287c <dmaStreamAllocI+0x10c>
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 80027aa:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80027ac:	4613      	mov	r3, r2
 80027ae:	005b      	lsls	r3, r3, #1
 80027b0:	4413      	add	r3, r2
 80027b2:	009b      	lsls	r3, r3, #2
 80027b4:	4a38      	ldr	r2, [pc, #224]	; (8002898 <dmaStreamAllocI+0x128>)
 80027b6:	4413      	add	r3, r2
 80027b8:	9305      	str	r3, [sp, #20]

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
 80027ba:	4a36      	ldr	r2, [pc, #216]	; (8002894 <dmaStreamAllocI+0x124>)
 80027bc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80027be:	00db      	lsls	r3, r3, #3
 80027c0:	4413      	add	r3, r2
 80027c2:	9a01      	ldr	r2, [sp, #4]
 80027c4:	605a      	str	r2, [r3, #4]
      dma.streams[i].param = param;
 80027c6:	4a33      	ldr	r2, [pc, #204]	; (8002894 <dmaStreamAllocI+0x124>)
 80027c8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80027ca:	00db      	lsls	r3, r3, #3
 80027cc:	4413      	add	r3, r2
 80027ce:	9a00      	ldr	r2, [sp, #0]
 80027d0:	609a      	str	r2, [r3, #8]
      dma.allocated_mask  |= mask;
 80027d2:	4b30      	ldr	r3, [pc, #192]	; (8002894 <dmaStreamAllocI+0x124>)
 80027d4:	681a      	ldr	r2, [r3, #0]
 80027d6:	9b06      	ldr	r3, [sp, #24]
 80027d8:	4313      	orrs	r3, r2
 80027da:	4a2e      	ldr	r2, [pc, #184]	; (8002894 <dmaStreamAllocI+0x124>)
 80027dc:	6013      	str	r3, [r2, #0]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 80027de:	9b06      	ldr	r3, [sp, #24]
 80027e0:	b2db      	uxtb	r3, r3
 80027e2:	2b00      	cmp	r3, #0
 80027e4:	d00d      	beq.n	8002802 <dmaStreamAllocI+0x92>
        rccEnableDMA1(true);
 80027e6:	4b2d      	ldr	r3, [pc, #180]	; (800289c <dmaStreamAllocI+0x12c>)
 80027e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80027ea:	4a2c      	ldr	r2, [pc, #176]	; (800289c <dmaStreamAllocI+0x12c>)
 80027ec:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80027f0:	6313      	str	r3, [r2, #48]	; 0x30
 80027f2:	4b2a      	ldr	r3, [pc, #168]	; (800289c <dmaStreamAllocI+0x12c>)
 80027f4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80027f6:	4a29      	ldr	r2, [pc, #164]	; (800289c <dmaStreamAllocI+0x12c>)
 80027f8:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80027fc:	6513      	str	r3, [r2, #80]	; 0x50
 80027fe:	4b27      	ldr	r3, [pc, #156]	; (800289c <dmaStreamAllocI+0x12c>)
 8002800:	6d1b      	ldr	r3, [r3, #80]	; 0x50
      }
      if ((STM32_DMA2_STREAMS_MASK & mask) != 0U) {
 8002802:	9b06      	ldr	r3, [sp, #24]
 8002804:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8002808:	2b00      	cmp	r3, #0
 800280a:	d00d      	beq.n	8002828 <dmaStreamAllocI+0xb8>
        rccEnableDMA2(true);
 800280c:	4b23      	ldr	r3, [pc, #140]	; (800289c <dmaStreamAllocI+0x12c>)
 800280e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002810:	4a22      	ldr	r2, [pc, #136]	; (800289c <dmaStreamAllocI+0x12c>)
 8002812:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8002816:	6313      	str	r3, [r2, #48]	; 0x30
 8002818:	4b20      	ldr	r3, [pc, #128]	; (800289c <dmaStreamAllocI+0x12c>)
 800281a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800281c:	4a1f      	ldr	r2, [pc, #124]	; (800289c <dmaStreamAllocI+0x12c>)
 800281e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8002822:	6513      	str	r3, [r2, #80]	; 0x50
 8002824:	4b1d      	ldr	r3, [pc, #116]	; (800289c <dmaStreamAllocI+0x12c>)
 8002826:	6d1b      	ldr	r3, [r3, #80]	; 0x50
        rccEnableDMAMUX(true);
      }
#endif

      /* Putting the stream in a safe state.*/
      dmaStreamDisable(dmastp);
 8002828:	9b05      	ldr	r3, [sp, #20]
 800282a:	681b      	ldr	r3, [r3, #0]
 800282c:	681a      	ldr	r2, [r3, #0]
 800282e:	9b05      	ldr	r3, [sp, #20]
 8002830:	681b      	ldr	r3, [r3, #0]
 8002832:	f022 021f 	bic.w	r2, r2, #31
 8002836:	601a      	str	r2, [r3, #0]
 8002838:	9b05      	ldr	r3, [sp, #20]
 800283a:	681b      	ldr	r3, [r3, #0]
 800283c:	681b      	ldr	r3, [r3, #0]
 800283e:	f003 0301 	and.w	r3, r3, #1
 8002842:	2b00      	cmp	r3, #0
 8002844:	d1f8      	bne.n	8002838 <dmaStreamAllocI+0xc8>
 8002846:	9b05      	ldr	r3, [sp, #20]
 8002848:	7a5b      	ldrb	r3, [r3, #9]
 800284a:	4619      	mov	r1, r3
 800284c:	9b05      	ldr	r3, [sp, #20]
 800284e:	685b      	ldr	r3, [r3, #4]
 8002850:	223d      	movs	r2, #61	; 0x3d
 8002852:	408a      	lsls	r2, r1
 8002854:	601a      	str	r2, [r3, #0]
      dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 8002856:	9b05      	ldr	r3, [sp, #20]
 8002858:	681b      	ldr	r3, [r3, #0]
 800285a:	2200      	movs	r2, #0
 800285c:	601a      	str	r2, [r3, #0]
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 800285e:	9b05      	ldr	r3, [sp, #20]
 8002860:	681b      	ldr	r3, [r3, #0]
 8002862:	2221      	movs	r2, #33	; 0x21
 8002864:	615a      	str	r2, [r3, #20]

      /* Enables the associated IRQ vector if a callback is defined.*/
      if (func != NULL) {
 8002866:	9b01      	ldr	r3, [sp, #4]
 8002868:	2b00      	cmp	r3, #0
 800286a:	d005      	beq.n	8002878 <dmaStreamAllocI+0x108>
        nvicEnableVector(dmastp->vector, priority);
 800286c:	9b05      	ldr	r3, [sp, #20]
 800286e:	7adb      	ldrb	r3, [r3, #11]
 8002870:	9902      	ldr	r1, [sp, #8]
 8002872:	4618      	mov	r0, r3
 8002874:	f7ff fa04 	bl	8001c80 <nvicEnableVector>
      }

      return dmastp;
 8002878:	9b05      	ldr	r3, [sp, #20]
 800287a:	e007      	b.n	800288c <dmaStreamAllocI+0x11c>
  for (i = startid; i <= endid; i++) {
 800287c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800287e:	3301      	adds	r3, #1
 8002880:	9309      	str	r3, [sp, #36]	; 0x24
 8002882:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8002884:	9b07      	ldr	r3, [sp, #28]
 8002886:	429a      	cmp	r2, r3
 8002888:	d984      	bls.n	8002794 <dmaStreamAllocI+0x24>
    }
  }

  return NULL;
 800288a:	2300      	movs	r3, #0
}
 800288c:	4618      	mov	r0, r3
 800288e:	b00b      	add	sp, #44	; 0x2c
 8002890:	f85d fb04 	ldr.w	pc, [sp], #4
 8002894:	20000c58 	.word	0x20000c58
 8002898:	08006dcc 	.word	0x08006dcc
 800289c:	40023800 	.word	0x40023800

080028a0 <dmaStreamFreeI>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @iclass
 */
void dmaStreamFreeI(const stm32_dma_stream_t *dmastp) {
 80028a0:	b500      	push	{lr}
 80028a2:	b083      	sub	sp, #12
 80028a4:	9001      	str	r0, [sp, #4]
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma.allocated_mask & (1U << dmastp->selfindex)) != 0U,
                "not allocated");

  /* Disables the associated IRQ vector.*/
  nvicDisableVector(dmastp->vector);
 80028a6:	9b01      	ldr	r3, [sp, #4]
 80028a8:	7adb      	ldrb	r3, [r3, #11]
 80028aa:	4618      	mov	r0, r3
 80028ac:	f7ff fa18 	bl	8001ce0 <nvicDisableVector>

  /* Marks the stream as not allocated.*/
  dma.allocated_mask &= ~(1U << dmastp->selfindex);
 80028b0:	4b1a      	ldr	r3, [pc, #104]	; (800291c <dmaStreamFreeI+0x7c>)
 80028b2:	681a      	ldr	r2, [r3, #0]
 80028b4:	9b01      	ldr	r3, [sp, #4]
 80028b6:	7a9b      	ldrb	r3, [r3, #10]
 80028b8:	4619      	mov	r1, r3
 80028ba:	2301      	movs	r3, #1
 80028bc:	408b      	lsls	r3, r1
 80028be:	43db      	mvns	r3, r3
 80028c0:	4013      	ands	r3, r2
 80028c2:	4a16      	ldr	r2, [pc, #88]	; (800291c <dmaStreamFreeI+0x7c>)
 80028c4:	6013      	str	r3, [r2, #0]

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma.allocated_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 80028c6:	4b15      	ldr	r3, [pc, #84]	; (800291c <dmaStreamFreeI+0x7c>)
 80028c8:	681b      	ldr	r3, [r3, #0]
 80028ca:	b2db      	uxtb	r3, r3
 80028cc:	2b00      	cmp	r3, #0
 80028ce:	d10d      	bne.n	80028ec <dmaStreamFreeI+0x4c>
    rccDisableDMA1();
 80028d0:	4b13      	ldr	r3, [pc, #76]	; (8002920 <dmaStreamFreeI+0x80>)
 80028d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80028d4:	4a12      	ldr	r2, [pc, #72]	; (8002920 <dmaStreamFreeI+0x80>)
 80028d6:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80028da:	6313      	str	r3, [r2, #48]	; 0x30
 80028dc:	4b10      	ldr	r3, [pc, #64]	; (8002920 <dmaStreamFreeI+0x80>)
 80028de:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80028e0:	4a0f      	ldr	r2, [pc, #60]	; (8002920 <dmaStreamFreeI+0x80>)
 80028e2:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80028e6:	6513      	str	r3, [r2, #80]	; 0x50
 80028e8:	4b0d      	ldr	r3, [pc, #52]	; (8002920 <dmaStreamFreeI+0x80>)
 80028ea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  }
  if ((dma.allocated_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 80028ec:	4b0b      	ldr	r3, [pc, #44]	; (800291c <dmaStreamFreeI+0x7c>)
 80028ee:	681b      	ldr	r3, [r3, #0]
 80028f0:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80028f4:	2b00      	cmp	r3, #0
 80028f6:	d10d      	bne.n	8002914 <dmaStreamFreeI+0x74>
    rccDisableDMA2();
 80028f8:	4b09      	ldr	r3, [pc, #36]	; (8002920 <dmaStreamFreeI+0x80>)
 80028fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80028fc:	4a08      	ldr	r2, [pc, #32]	; (8002920 <dmaStreamFreeI+0x80>)
 80028fe:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8002902:	6313      	str	r3, [r2, #48]	; 0x30
 8002904:	4b06      	ldr	r3, [pc, #24]	; (8002920 <dmaStreamFreeI+0x80>)
 8002906:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002908:	4a05      	ldr	r2, [pc, #20]	; (8002920 <dmaStreamFreeI+0x80>)
 800290a:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 800290e:	6513      	str	r3, [r2, #80]	; 0x50
 8002910:	4b03      	ldr	r3, [pc, #12]	; (8002920 <dmaStreamFreeI+0x80>)
 8002912:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  /* Shutting down DMAMUX if present.*/
  if (dma.allocated_mask == 0U) {
    rccDisableDMAMUX();
  }
#endif
}
 8002914:	bf00      	nop
 8002916:	b003      	add	sp, #12
 8002918:	f85d fb04 	ldr.w	pc, [sp], #4
 800291c:	20000c58 	.word	0x20000c58
 8002920:	40023800 	.word	0x40023800
	...

08002930 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 8002930:	bf00      	nop
 8002932:	4770      	bx	lr
	...

08002940 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8002940:	b08e      	sub	sp, #56	; 0x38
 8002942:	9003      	str	r0, [sp, #12]
 8002944:	9102      	str	r1, [sp, #8]
 8002946:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8002948:	9b01      	ldr	r3, [sp, #4]
 800294a:	f003 0303 	and.w	r3, r3, #3
 800294e:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8002950:	9b01      	ldr	r3, [sp, #4]
 8002952:	089b      	lsrs	r3, r3, #2
 8002954:	f003 0301 	and.w	r3, r3, #1
 8002958:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800295a:	9b01      	ldr	r3, [sp, #4]
 800295c:	08db      	lsrs	r3, r3, #3
 800295e:	f003 0303 	and.w	r3, r3, #3
 8002962:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8002964:	9b01      	ldr	r3, [sp, #4]
 8002966:	095b      	lsrs	r3, r3, #5
 8002968:	f003 0303 	and.w	r3, r3, #3
 800296c:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800296e:	9b01      	ldr	r3, [sp, #4]
 8002970:	09db      	lsrs	r3, r3, #7
 8002972:	f003 030f 	and.w	r3, r3, #15
 8002976:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8002978:	2300      	movs	r3, #0
 800297a:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 800297c:	9b02      	ldr	r3, [sp, #8]
 800297e:	f003 0301 	and.w	r3, r3, #1
 8002982:	2b00      	cmp	r3, #0
 8002984:	d079      	beq.n	8002a7a <_pal_lld_setgroupmode+0x13a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8002986:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002988:	f003 0307 	and.w	r3, r3, #7
 800298c:	009b      	lsls	r3, r3, #2
 800298e:	9a08      	ldr	r2, [sp, #32]
 8002990:	fa02 f303 	lsl.w	r3, r2, r3
 8002994:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 8002996:	2201      	movs	r2, #1
 8002998:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800299a:	fa02 f303 	lsl.w	r3, r2, r3
 800299e:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 80029a0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80029a2:	005b      	lsls	r3, r3, #1
 80029a4:	2203      	movs	r2, #3
 80029a6:	fa02 f303 	lsl.w	r3, r2, r3
 80029aa:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 80029ac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80029ae:	f003 0307 	and.w	r3, r3, #7
 80029b2:	009b      	lsls	r3, r3, #2
 80029b4:	220f      	movs	r2, #15
 80029b6:	fa02 f303 	lsl.w	r3, r2, r3
 80029ba:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80029bc:	9b03      	ldr	r3, [sp, #12]
 80029be:	685a      	ldr	r2, [r3, #4]
 80029c0:	9b06      	ldr	r3, [sp, #24]
 80029c2:	43db      	mvns	r3, r3
 80029c4:	401a      	ands	r2, r3
 80029c6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80029c8:	431a      	orrs	r2, r3
 80029ca:	9b03      	ldr	r3, [sp, #12]
 80029cc:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80029ce:	9b03      	ldr	r3, [sp, #12]
 80029d0:	689a      	ldr	r2, [r3, #8]
 80029d2:	9b05      	ldr	r3, [sp, #20]
 80029d4:	43db      	mvns	r3, r3
 80029d6:	401a      	ands	r2, r3
 80029d8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80029da:	431a      	orrs	r2, r3
 80029dc:	9b03      	ldr	r3, [sp, #12]
 80029de:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80029e0:	9b03      	ldr	r3, [sp, #12]
 80029e2:	68da      	ldr	r2, [r3, #12]
 80029e4:	9b05      	ldr	r3, [sp, #20]
 80029e6:	43db      	mvns	r3, r3
 80029e8:	401a      	ands	r2, r3
 80029ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80029ec:	431a      	orrs	r2, r3
 80029ee:	9b03      	ldr	r3, [sp, #12]
 80029f0:	60da      	str	r2, [r3, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 80029f2:	9b01      	ldr	r3, [sp, #4]
 80029f4:	f003 0303 	and.w	r3, r3, #3
 80029f8:	2b02      	cmp	r3, #2
 80029fa:	d11f      	bne.n	8002a3c <_pal_lld_setgroupmode+0xfc>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 80029fc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80029fe:	2b07      	cmp	r3, #7
 8002a00:	d809      	bhi.n	8002a16 <_pal_lld_setgroupmode+0xd6>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8002a02:	9b03      	ldr	r3, [sp, #12]
 8002a04:	6a1a      	ldr	r2, [r3, #32]
 8002a06:	9b04      	ldr	r3, [sp, #16]
 8002a08:	43db      	mvns	r3, r3
 8002a0a:	401a      	ands	r2, r3
 8002a0c:	9b07      	ldr	r3, [sp, #28]
 8002a0e:	431a      	orrs	r2, r3
 8002a10:	9b03      	ldr	r3, [sp, #12]
 8002a12:	621a      	str	r2, [r3, #32]
 8002a14:	e008      	b.n	8002a28 <_pal_lld_setgroupmode+0xe8>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8002a16:	9b03      	ldr	r3, [sp, #12]
 8002a18:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002a1a:	9b04      	ldr	r3, [sp, #16]
 8002a1c:	43db      	mvns	r3, r3
 8002a1e:	401a      	ands	r2, r3
 8002a20:	9b07      	ldr	r3, [sp, #28]
 8002a22:	431a      	orrs	r2, r3
 8002a24:	9b03      	ldr	r3, [sp, #12]
 8002a26:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 8002a28:	9b03      	ldr	r3, [sp, #12]
 8002a2a:	681a      	ldr	r2, [r3, #0]
 8002a2c:	9b05      	ldr	r3, [sp, #20]
 8002a2e:	43db      	mvns	r3, r3
 8002a30:	401a      	ands	r2, r3
 8002a32:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8002a34:	431a      	orrs	r2, r3
 8002a36:	9b03      	ldr	r3, [sp, #12]
 8002a38:	601a      	str	r2, [r3, #0]
 8002a3a:	e01e      	b.n	8002a7a <_pal_lld_setgroupmode+0x13a>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8002a3c:	9b03      	ldr	r3, [sp, #12]
 8002a3e:	681a      	ldr	r2, [r3, #0]
 8002a40:	9b05      	ldr	r3, [sp, #20]
 8002a42:	43db      	mvns	r3, r3
 8002a44:	401a      	ands	r2, r3
 8002a46:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8002a48:	431a      	orrs	r2, r3
 8002a4a:	9b03      	ldr	r3, [sp, #12]
 8002a4c:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 8002a4e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002a50:	2b07      	cmp	r3, #7
 8002a52:	d809      	bhi.n	8002a68 <_pal_lld_setgroupmode+0x128>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8002a54:	9b03      	ldr	r3, [sp, #12]
 8002a56:	6a1a      	ldr	r2, [r3, #32]
 8002a58:	9b04      	ldr	r3, [sp, #16]
 8002a5a:	43db      	mvns	r3, r3
 8002a5c:	401a      	ands	r2, r3
 8002a5e:	9b07      	ldr	r3, [sp, #28]
 8002a60:	431a      	orrs	r2, r3
 8002a62:	9b03      	ldr	r3, [sp, #12]
 8002a64:	621a      	str	r2, [r3, #32]
 8002a66:	e008      	b.n	8002a7a <_pal_lld_setgroupmode+0x13a>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8002a68:	9b03      	ldr	r3, [sp, #12]
 8002a6a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002a6c:	9b04      	ldr	r3, [sp, #16]
 8002a6e:	43db      	mvns	r3, r3
 8002a70:	401a      	ands	r2, r3
 8002a72:	9b07      	ldr	r3, [sp, #28]
 8002a74:	431a      	orrs	r2, r3
 8002a76:	9b03      	ldr	r3, [sp, #12]
 8002a78:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
 8002a7a:	9b02      	ldr	r3, [sp, #8]
 8002a7c:	085b      	lsrs	r3, r3, #1
 8002a7e:	9302      	str	r3, [sp, #8]
    if (!mask)
 8002a80:	9b02      	ldr	r3, [sp, #8]
 8002a82:	2b00      	cmp	r3, #0
 8002a84:	d00f      	beq.n	8002aa6 <_pal_lld_setgroupmode+0x166>
      return;
    otyper <<= 1;
 8002a86:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8002a88:	005b      	lsls	r3, r3, #1
 8002a8a:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 8002a8c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8002a8e:	009b      	lsls	r3, r3, #2
 8002a90:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 8002a92:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002a94:	009b      	lsls	r3, r3, #2
 8002a96:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 8002a98:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8002a9a:	009b      	lsls	r3, r3, #2
 8002a9c:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 8002a9e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002aa0:	3301      	adds	r3, #1
 8002aa2:	9309      	str	r3, [sp, #36]	; 0x24
    if ((mask & 1) != 0) {
 8002aa4:	e76a      	b.n	800297c <_pal_lld_setgroupmode+0x3c>
      return;
 8002aa6:	bf00      	nop
  }
}
 8002aa8:	b00e      	add	sp, #56	; 0x38
 8002aaa:	4770      	bx	lr
 8002aac:	0000      	movs	r0, r0
	...

08002ab0 <chSysLockFromISR.lto_priv.0>:
 *          not be limited to disabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8002ab0:	b082      	sub	sp, #8
 8002ab2:	2320      	movs	r3, #32
 8002ab4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002ab6:	9b01      	ldr	r3, [sp, #4]
 8002ab8:	f383 8811 	msr	BASEPRI, r3
}
 8002abc:	bf00      	nop
}
 8002abe:	bf00      	nop
 * @note    Same as @p port_lock() in this port.
 */
__STATIC_FORCEINLINE void port_lock_from_isr(void) {

  port_lock();
}
 8002ac0:	bf00      	nop

  port_lock_from_isr();
  __stats_start_measure_crit_isr();
  __dbg_check_lock_from_isr();
}
 8002ac2:	bf00      	nop
 8002ac4:	b002      	add	sp, #8
 8002ac6:	4770      	bx	lr
	...

08002ad0 <chSysUnlockFromISR.lto_priv.0>:
 *          not be limited to enabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8002ad0:	b082      	sub	sp, #8
 8002ad2:	2300      	movs	r3, #0
 8002ad4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002ad6:	9b01      	ldr	r3, [sp, #4]
 8002ad8:	f383 8811 	msr	BASEPRI, r3
}
 8002adc:	bf00      	nop
}
 8002ade:	bf00      	nop
 * @note    Same as @p port_unlock() in this port.
 */
__STATIC_FORCEINLINE void port_unlock_from_isr(void) {

  port_unlock();
}
 8002ae0:	bf00      	nop

  __dbg_check_unlock_from_isr();
  __stats_stop_measure_crit_isr();
  port_unlock_from_isr();
}
 8002ae2:	bf00      	nop
 8002ae4:	b002      	add	sp, #8
 8002ae6:	4770      	bx	lr
	...

08002af0 <osalSysLockFromISR.lto_priv.0>:
static inline void osalSysLockFromISR(void) {
 8002af0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8002af2:	f7ff ffdd 	bl	8002ab0 <chSysLockFromISR.lto_priv.0>
}
 8002af6:	bf00      	nop
 8002af8:	bd08      	pop	{r3, pc}
 8002afa:	bf00      	nop
 8002afc:	0000      	movs	r0, r0
	...

08002b00 <osalSysUnlockFromISR.lto_priv.0>:
static inline void osalSysUnlockFromISR(void) {
 8002b00:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8002b02:	f7ff ffe5 	bl	8002ad0 <chSysUnlockFromISR.lto_priv.0>
}
 8002b06:	bf00      	nop
 8002b08:	bd08      	pop	{r3, pc}
 8002b0a:	bf00      	nop
 8002b0c:	0000      	movs	r0, r0
	...

08002b10 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
 8002b10:	b508      	push	{r3, lr}
  chSysTimerHandlerI();
 8002b12:	f000 fe75 	bl	8003800 <chSysTimerHandlerI>
}
 8002b16:	bf00      	nop
 8002b18:	bd08      	pop	{r3, pc}
 8002b1a:	bf00      	nop
 8002b1c:	0000      	movs	r0, r0
	...

08002b20 <st_lld_init>:
                "clock rounding error");
  osalDbgAssert(((ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1U) < 0x10000,
                "clock prescaler overflow");

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8002b20:	4b1b      	ldr	r3, [pc, #108]	; (8002b90 <st_lld_init+0x70>)
 8002b22:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002b24:	4a1a      	ldr	r2, [pc, #104]	; (8002b90 <st_lld_init+0x70>)
 8002b26:	f043 0301 	orr.w	r3, r3, #1
 8002b2a:	6413      	str	r3, [r2, #64]	; 0x40
 8002b2c:	4b18      	ldr	r3, [pc, #96]	; (8002b90 <st_lld_init+0x70>)
 8002b2e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8002b30:	4a17      	ldr	r2, [pc, #92]	; (8002b90 <st_lld_init+0x70>)
 8002b32:	f043 0301 	orr.w	r3, r3, #1
 8002b36:	6613      	str	r3, [r2, #96]	; 0x60
 8002b38:	4b15      	ldr	r3, [pc, #84]	; (8002b90 <st_lld_init+0x70>)
 8002b3a:	6e1b      	ldr	r3, [r3, #96]	; 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8002b3c:	4b15      	ldr	r3, [pc, #84]	; (8002b94 <st_lld_init+0x74>)
 8002b3e:	689b      	ldr	r3, [r3, #8]
 8002b40:	4a14      	ldr	r2, [pc, #80]	; (8002b94 <st_lld_init+0x74>)
 8002b42:	f043 0301 	orr.w	r3, r3, #1
 8002b46:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8002b48:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002b4c:	f242 02cf 	movw	r2, #8399	; 0x20cf
 8002b50:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8002b52:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002b56:	f04f 32ff 	mov.w	r2, #4294967295
 8002b5a:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8002b5c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002b60:	2200      	movs	r2, #0
 8002b62:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8002b64:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002b68:	2200      	movs	r2, #0
 8002b6a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 8002b6c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002b70:	2200      	movs	r2, #0
 8002b72:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8002b74:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002b78:	2200      	movs	r2, #0
 8002b7a:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8002b7c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002b80:	2201      	movs	r2, #1
 8002b82:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8002b84:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002b88:	2201      	movs	r2, #1
 8002b8a:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8002b8c:	bf00      	nop
 8002b8e:	4770      	bx	lr
 8002b90:	40023800 	.word	0x40023800
 8002b94:	e0042000 	.word	0xe0042000
	...

08002ba0 <st_lld_serve_interrupt>:

/**
 * @brief   IRQ handling code.
 */
void st_lld_serve_interrupt(void) {
 8002ba0:	b500      	push	{lr}
 8002ba2:	b083      	sub	sp, #12
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;
 8002ba4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002ba8:	9301      	str	r3, [sp, #4]

  sr  = timp->SR;
 8002baa:	9b01      	ldr	r3, [sp, #4]
 8002bac:	691b      	ldr	r3, [r3, #16]
 8002bae:	9300      	str	r3, [sp, #0]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8002bb0:	9b01      	ldr	r3, [sp, #4]
 8002bb2:	68db      	ldr	r3, [r3, #12]
 8002bb4:	b2db      	uxtb	r3, r3
 8002bb6:	9a00      	ldr	r2, [sp, #0]
 8002bb8:	4013      	ands	r3, r2
 8002bba:	9300      	str	r3, [sp, #0]
  timp->SR = ~sr;
 8002bbc:	9b00      	ldr	r3, [sp, #0]
 8002bbe:	43da      	mvns	r2, r3
 8002bc0:	9b01      	ldr	r3, [sp, #4]
 8002bc2:	611a      	str	r2, [r3, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
 8002bc4:	9b00      	ldr	r3, [sp, #0]
 8002bc6:	f003 0302 	and.w	r3, r3, #2
 8002bca:	2b00      	cmp	r3, #0
 8002bcc:	d005      	beq.n	8002bda <st_lld_serve_interrupt+0x3a>
#endif
  {
    osalSysLockFromISR();
 8002bce:	f7ff ff8f 	bl	8002af0 <osalSysLockFromISR.lto_priv.0>
    osalOsTimerHandlerI();
 8002bd2:	f7ff ff9d 	bl	8002b10 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 8002bd6:	f7ff ff93 	bl	8002b00 <osalSysUnlockFromISR.lto_priv.0>
      st_callbacks[2](3U);
    }
  }
#endif
#endif
}
 8002bda:	bf00      	nop
 8002bdc:	b003      	add	sp, #12
 8002bde:	f85d fb04 	ldr.w	pc, [sp], #4
 8002be2:	bf00      	nop
	...

08002bf0 <chSysLockFromISR.lto_priv.1>:
static inline void chSysLockFromISR(void) {
 8002bf0:	b082      	sub	sp, #8
 8002bf2:	2320      	movs	r3, #32
 8002bf4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002bf6:	9b01      	ldr	r3, [sp, #4]
 8002bf8:	f383 8811 	msr	BASEPRI, r3
}
 8002bfc:	bf00      	nop
}
 8002bfe:	bf00      	nop
}
 8002c00:	bf00      	nop
}
 8002c02:	bf00      	nop
 8002c04:	b002      	add	sp, #8
 8002c06:	4770      	bx	lr
	...

08002c10 <chSysUnlockFromISR.lto_priv.1>:
static inline void chSysUnlockFromISR(void) {
 8002c10:	b082      	sub	sp, #8
 8002c12:	2300      	movs	r3, #0
 8002c14:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002c16:	9b01      	ldr	r3, [sp, #4]
 8002c18:	f383 8811 	msr	BASEPRI, r3
}
 8002c1c:	bf00      	nop
}
 8002c1e:	bf00      	nop
}
 8002c20:	bf00      	nop
}
 8002c22:	bf00      	nop
 8002c24:	b002      	add	sp, #8
 8002c26:	4770      	bx	lr
	...

08002c30 <osalSysLockFromISR.lto_priv.1>:
static inline void osalSysLockFromISR(void) {
 8002c30:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8002c32:	f7ff ffdd 	bl	8002bf0 <chSysLockFromISR.lto_priv.1>
}
 8002c36:	bf00      	nop
 8002c38:	bd08      	pop	{r3, pc}
 8002c3a:	bf00      	nop
 8002c3c:	0000      	movs	r0, r0
	...

08002c40 <osalSysUnlockFromISR.lto_priv.1>:
static inline void osalSysUnlockFromISR(void) {
 8002c40:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8002c42:	f7ff ffe5 	bl	8002c10 <chSysUnlockFromISR.lto_priv.1>
}
 8002c46:	bf00      	nop
 8002c48:	bd08      	pop	{r3, pc}
 8002c4a:	bf00      	nop
 8002c4c:	0000      	movs	r0, r0
	...

08002c50 <osalEventBroadcastFlagsI.lto_priv.1>:
                                            eventflags_t flags) {
 8002c50:	b500      	push	{lr}
 8002c52:	b083      	sub	sp, #12
 8002c54:	9001      	str	r0, [sp, #4]
 8002c56:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
 8002c58:	9900      	ldr	r1, [sp, #0]
 8002c5a:	9801      	ldr	r0, [sp, #4]
 8002c5c:	f001 fef8 	bl	8004a50 <chEvtBroadcastFlagsI>
}
 8002c60:	bf00      	nop
 8002c62:	b003      	add	sp, #12
 8002c64:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002c70 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 8002c70:	b084      	sub	sp, #16
 8002c72:	9001      	str	r0, [sp, #4]
 8002c74:	9100      	str	r1, [sp, #0]
  uint32_t brr;
  USART_TypeDef *u = sdp->usart;
 8002c76:	9b01      	ldr	r3, [sp, #4]
 8002c78:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8002c7a:	9302      	str	r3, [sp, #8]

  brr = (uint32_t)(sdp->clock / config->speed);
 8002c7c:	9b01      	ldr	r3, [sp, #4]
 8002c7e:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8002c80:	9b00      	ldr	r3, [sp, #0]
 8002c82:	681b      	ldr	r3, [r3, #0]
 8002c84:	fbb2 f3f3 	udiv	r3, r2, r3
 8002c88:	9303      	str	r3, [sp, #12]

#if defined(USART_CR1_OVER8)
  /* Correcting BRR value when oversampling by 8 instead of 16.
     Fraction is still 4 bits wide, but only lower 3 bits used.
     Mantissa is doubled, but Fraction is left the same.*/
  if (config->cr1 & USART_CR1_OVER8)
 8002c8a:	9b00      	ldr	r3, [sp, #0]
 8002c8c:	889b      	ldrh	r3, [r3, #4]
 8002c8e:	b21b      	sxth	r3, r3
 8002c90:	2b00      	cmp	r3, #0
 8002c92:	da08      	bge.n	8002ca6 <usart_init+0x36>
    brr = ((brr & ~7) * 2) | (brr & 7);
 8002c94:	9b03      	ldr	r3, [sp, #12]
 8002c96:	f023 0307 	bic.w	r3, r3, #7
 8002c9a:	005a      	lsls	r2, r3, #1
 8002c9c:	9b03      	ldr	r3, [sp, #12]
 8002c9e:	f003 0307 	and.w	r3, r3, #7
 8002ca2:	4313      	orrs	r3, r2
 8002ca4:	9303      	str	r3, [sp, #12]
#endif

  osalDbgAssert(brr < 0x10000, "invalid BRR value");

  u->BRR = brr;
 8002ca6:	9b02      	ldr	r3, [sp, #8]
 8002ca8:	9a03      	ldr	r2, [sp, #12]
 8002caa:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002cac:	9b00      	ldr	r3, [sp, #0]
 8002cae:	88db      	ldrh	r3, [r3, #6]
 8002cb0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002cb4:	b29b      	uxth	r3, r3
 8002cb6:	461a      	mov	r2, r3
 8002cb8:	9b02      	ldr	r3, [sp, #8]
 8002cba:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8002cbc:	9b00      	ldr	r3, [sp, #0]
 8002cbe:	891b      	ldrh	r3, [r3, #8]
 8002cc0:	f043 0301 	orr.w	r3, r3, #1
 8002cc4:	b29b      	uxth	r3, r3
 8002cc6:	461a      	mov	r2, r3
 8002cc8:	9b02      	ldr	r3, [sp, #8]
 8002cca:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002ccc:	9b00      	ldr	r3, [sp, #0]
 8002cce:	889b      	ldrh	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8002cd0:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
 8002cd4:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 8002cd8:	b29b      	uxth	r3, r3
 8002cda:	461a      	mov	r2, r3
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002cdc:	9b02      	ldr	r3, [sp, #8]
 8002cde:	60da      	str	r2, [r3, #12]
                         USART_CR1_RE;
  u->SR = 0;
 8002ce0:	9b02      	ldr	r3, [sp, #8]
 8002ce2:	2200      	movs	r2, #0
 8002ce4:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8002ce6:	9b02      	ldr	r3, [sp, #8]
 8002ce8:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8002cea:	9b02      	ldr	r3, [sp, #8]
 8002cec:	685b      	ldr	r3, [r3, #4]

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 8002cee:	9b00      	ldr	r3, [sp, #0]
 8002cf0:	889b      	ldrh	r3, [r3, #4]
 8002cf2:	f403 53a0 	and.w	r3, r3, #5120	; 0x1400
 8002cf6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8002cfa:	d104      	bne.n	8002d06 <usart_init+0x96>
    sdp->rxmask = 0x7F;
 8002cfc:	9b01      	ldr	r3, [sp, #4]
 8002cfe:	227f      	movs	r2, #127	; 0x7f
 8002d00:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
  }
  else {
    sdp->rxmask = 0xFF;
  }
}
 8002d04:	e003      	b.n	8002d0e <usart_init+0x9e>
    sdp->rxmask = 0xFF;
 8002d06:	9b01      	ldr	r3, [sp, #4]
 8002d08:	22ff      	movs	r2, #255	; 0xff
 8002d0a:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
}
 8002d0e:	bf00      	nop
 8002d10:	b004      	add	sp, #16
 8002d12:	4770      	bx	lr
	...

08002d20 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
 8002d20:	b500      	push	{lr}
 8002d22:	b085      	sub	sp, #20
 8002d24:	9001      	str	r0, [sp, #4]
 8002d26:	460b      	mov	r3, r1
 8002d28:	f8ad 3002 	strh.w	r3, [sp, #2]
  eventflags_t sts = 0;
 8002d2c:	2300      	movs	r3, #0
 8002d2e:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
 8002d30:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8002d34:	f003 0308 	and.w	r3, r3, #8
 8002d38:	2b00      	cmp	r3, #0
 8002d3a:	d003      	beq.n	8002d44 <set_error+0x24>
    sts |= SD_OVERRUN_ERROR;
 8002d3c:	9b03      	ldr	r3, [sp, #12]
 8002d3e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002d42:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
 8002d44:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8002d48:	f003 0301 	and.w	r3, r3, #1
 8002d4c:	2b00      	cmp	r3, #0
 8002d4e:	d003      	beq.n	8002d58 <set_error+0x38>
    sts |= SD_PARITY_ERROR;
 8002d50:	9b03      	ldr	r3, [sp, #12]
 8002d52:	f043 0320 	orr.w	r3, r3, #32
 8002d56:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
 8002d58:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8002d5c:	f003 0302 	and.w	r3, r3, #2
 8002d60:	2b00      	cmp	r3, #0
 8002d62:	d003      	beq.n	8002d6c <set_error+0x4c>
    sts |= SD_FRAMING_ERROR;
 8002d64:	9b03      	ldr	r3, [sp, #12]
 8002d66:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002d6a:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
 8002d6c:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8002d70:	f003 0304 	and.w	r3, r3, #4
 8002d74:	2b00      	cmp	r3, #0
 8002d76:	d003      	beq.n	8002d80 <set_error+0x60>
    sts |= SD_NOISE_ERROR;
 8002d78:	9b03      	ldr	r3, [sp, #12]
 8002d7a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002d7e:	9303      	str	r3, [sp, #12]
  chnAddFlagsI(sdp, sts);
 8002d80:	9b01      	ldr	r3, [sp, #4]
 8002d82:	3304      	adds	r3, #4
 8002d84:	9903      	ldr	r1, [sp, #12]
 8002d86:	4618      	mov	r0, r3
 8002d88:	f7ff ff62 	bl	8002c50 <osalEventBroadcastFlagsI.lto_priv.1>
}
 8002d8c:	bf00      	nop
 8002d8e:	b005      	add	sp, #20
 8002d90:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002da0 <notify2>:
  USART1->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
}
#endif

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {
 8002da0:	b082      	sub	sp, #8
 8002da2:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8002da4:	4b04      	ldr	r3, [pc, #16]	; (8002db8 <notify2+0x18>)
 8002da6:	68db      	ldr	r3, [r3, #12]
 8002da8:	4a03      	ldr	r2, [pc, #12]	; (8002db8 <notify2+0x18>)
 8002daa:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8002dae:	60d3      	str	r3, [r2, #12]
}
 8002db0:	bf00      	nop
 8002db2:	b002      	add	sp, #8
 8002db4:	4770      	bx	lr
 8002db6:	bf00      	nop
 8002db8:	40004400 	.word	0x40004400
 8002dbc:	00000000 	.word	0x00000000

08002dc0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8002dc0:	b508      	push	{r3, lr}
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
#endif
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 8002dc2:	4a06      	ldr	r2, [pc, #24]	; (8002ddc <sd_lld_init+0x1c>)
 8002dc4:	2100      	movs	r1, #0
 8002dc6:	4806      	ldr	r0, [pc, #24]	; (8002de0 <sd_lld_init+0x20>)
 8002dc8:	f7fe fe62 	bl	8001a90 <sdObjectInit>
  SD2.usart = USART2;
 8002dcc:	4b04      	ldr	r3, [pc, #16]	; (8002de0 <sd_lld_init+0x20>)
 8002dce:	4a05      	ldr	r2, [pc, #20]	; (8002de4 <sd_lld_init+0x24>)
 8002dd0:	675a      	str	r2, [r3, #116]	; 0x74
  SD2.clock = STM32_PCLK1;
 8002dd2:	4b03      	ldr	r3, [pc, #12]	; (8002de0 <sd_lld_init+0x20>)
 8002dd4:	4a04      	ldr	r2, [pc, #16]	; (8002de8 <sd_lld_init+0x28>)
 8002dd6:	679a      	str	r2, [r3, #120]	; 0x78
  SD10.clock = STM32_PCLK2;
#if !defined(STM32_UART10_SUPPRESS_ISR) && defined(STM32_UART10_NUMBER)
  nvicEnableVector(STM32_UART10_NUMBER, STM32_SERIAL_UART10_PRIORITY);
#endif
#endif
}
 8002dd8:	bf00      	nop
 8002dda:	bd08      	pop	{r3, pc}
 8002ddc:	08002da1 	.word	0x08002da1
 8002de0:	20000cdc 	.word	0x20000cdc
 8002de4:	40004400 	.word	0x40004400
 8002de8:	0280de80 	.word	0x0280de80
 8002dec:	00000000 	.word	0x00000000

08002df0 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8002df0:	b500      	push	{lr}
 8002df2:	b083      	sub	sp, #12
 8002df4:	9001      	str	r0, [sp, #4]
 8002df6:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 8002df8:	9b00      	ldr	r3, [sp, #0]
 8002dfa:	2b00      	cmp	r3, #0
 8002dfc:	d101      	bne.n	8002e02 <sd_lld_start+0x12>
    config = &default_config;
 8002dfe:	4b10      	ldr	r3, [pc, #64]	; (8002e40 <sd_lld_start+0x50>)
 8002e00:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 8002e02:	9b01      	ldr	r3, [sp, #4]
 8002e04:	7a1b      	ldrb	r3, [r3, #8]
 8002e06:	2b01      	cmp	r3, #1
 8002e08:	d111      	bne.n	8002e2e <sd_lld_start+0x3e>
    if (&SD1 == sdp) {
      rccEnableUSART1(true);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 8002e0a:	9b01      	ldr	r3, [sp, #4]
 8002e0c:	4a0d      	ldr	r2, [pc, #52]	; (8002e44 <sd_lld_start+0x54>)
 8002e0e:	4293      	cmp	r3, r2
 8002e10:	d10d      	bne.n	8002e2e <sd_lld_start+0x3e>
      rccEnableUSART2(true);
 8002e12:	4b0d      	ldr	r3, [pc, #52]	; (8002e48 <sd_lld_start+0x58>)
 8002e14:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002e16:	4a0c      	ldr	r2, [pc, #48]	; (8002e48 <sd_lld_start+0x58>)
 8002e18:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002e1c:	6413      	str	r3, [r2, #64]	; 0x40
 8002e1e:	4b0a      	ldr	r3, [pc, #40]	; (8002e48 <sd_lld_start+0x58>)
 8002e20:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8002e22:	4a09      	ldr	r2, [pc, #36]	; (8002e48 <sd_lld_start+0x58>)
 8002e24:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002e28:	6613      	str	r3, [r2, #96]	; 0x60
 8002e2a:	4b07      	ldr	r3, [pc, #28]	; (8002e48 <sd_lld_start+0x58>)
 8002e2c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    if (&SD10 == sdp) {
      rccEnableUART10(true);
    }
#endif
  }
  usart_init(sdp, config);
 8002e2e:	9900      	ldr	r1, [sp, #0]
 8002e30:	9801      	ldr	r0, [sp, #4]
 8002e32:	f7ff ff1d 	bl	8002c70 <usart_init>
}
 8002e36:	bf00      	nop
 8002e38:	b003      	add	sp, #12
 8002e3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e3e:	bf00      	nop
 8002e40:	08006e8c 	.word	0x08006e8c
 8002e44:	20000cdc 	.word	0x20000cdc
 8002e48:	40023800 	.word	0x40023800
 8002e4c:	00000000 	.word	0x00000000

08002e50 <sd_lld_serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
void sd_lld_serve_interrupt(SerialDriver *sdp) {
 8002e50:	b500      	push	{lr}
 8002e52:	b089      	sub	sp, #36	; 0x24
 8002e54:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 8002e56:	9b01      	ldr	r3, [sp, #4]
 8002e58:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8002e5a:	9306      	str	r3, [sp, #24]
  uint16_t cr1 = u->CR1;
 8002e5c:	9b06      	ldr	r3, [sp, #24]
 8002e5e:	68db      	ldr	r3, [r3, #12]
 8002e60:	f8ad 3016 	strh.w	r3, [sp, #22]
  uint16_t sr = u->SR;
 8002e64:	9b06      	ldr	r3, [sp, #24]
 8002e66:	681b      	ldr	r3, [r3, #0]
 8002e68:	f8ad 301e 	strh.w	r3, [sp, #30]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8002e6c:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8002e70:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002e74:	2b00      	cmp	r3, #0
 8002e76:	d00e      	beq.n	8002e96 <sd_lld_serve_interrupt+0x46>
    osalSysLockFromISR();
 8002e78:	f7ff feda 	bl	8002c30 <osalSysLockFromISR.lto_priv.1>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8002e7c:	9b01      	ldr	r3, [sp, #4]
 8002e7e:	3304      	adds	r3, #4
 8002e80:	f44f 7100 	mov.w	r1, #512	; 0x200
 8002e84:	4618      	mov	r0, r3
 8002e86:	f7ff fee3 	bl	8002c50 <osalEventBroadcastFlagsI.lto_priv.1>
    u->SR = ~USART_SR_LBD;
 8002e8a:	9b06      	ldr	r3, [sp, #24]
 8002e8c:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8002e90:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8002e92:	f7ff fed5 	bl	8002c40 <osalSysUnlockFromISR.lto_priv.1>
  }

  /* Data available.*/
  osalSysLockFromISR();
 8002e96:	f7ff fecb 	bl	8002c30 <osalSysLockFromISR.lto_priv.1>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8002e9a:	e024      	b.n	8002ee6 <sd_lld_serve_interrupt+0x96>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8002e9c:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8002ea0:	f003 030f 	and.w	r3, r3, #15
 8002ea4:	2b00      	cmp	r3, #0
 8002ea6:	d005      	beq.n	8002eb4 <sd_lld_serve_interrupt+0x64>
      set_error(sdp, sr);
 8002ea8:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8002eac:	4619      	mov	r1, r3
 8002eae:	9801      	ldr	r0, [sp, #4]
 8002eb0:	f7ff ff36 	bl	8002d20 <set_error>
    b = (uint8_t)u->DR & sdp->rxmask;
 8002eb4:	9b06      	ldr	r3, [sp, #24]
 8002eb6:	685b      	ldr	r3, [r3, #4]
 8002eb8:	b2da      	uxtb	r2, r3
 8002eba:	9b01      	ldr	r3, [sp, #4]
 8002ebc:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 8002ec0:	4013      	ands	r3, r2
 8002ec2:	f88d 300f 	strb.w	r3, [sp, #15]
    if (sr & USART_SR_RXNE)
 8002ec6:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8002eca:	f003 0320 	and.w	r3, r3, #32
 8002ece:	2b00      	cmp	r3, #0
 8002ed0:	d005      	beq.n	8002ede <sd_lld_serve_interrupt+0x8e>
      sdIncomingDataI(sdp, b);
 8002ed2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002ed6:	4619      	mov	r1, r3
 8002ed8:	9801      	ldr	r0, [sp, #4]
 8002eda:	f7fe fe21 	bl	8001b20 <sdIncomingDataI>
    sr = u->SR;
 8002ede:	9b06      	ldr	r3, [sp, #24]
 8002ee0:	681b      	ldr	r3, [r3, #0]
 8002ee2:	f8ad 301e 	strh.w	r3, [sp, #30]
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8002ee6:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8002eea:	f003 032f 	and.w	r3, r3, #47	; 0x2f
 8002eee:	2b00      	cmp	r3, #0
 8002ef0:	d1d4      	bne.n	8002e9c <sd_lld_serve_interrupt+0x4c>
  }
  osalSysUnlockFromISR();
 8002ef2:	f7ff fea5 	bl	8002c40 <osalSysUnlockFromISR.lto_priv.1>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8002ef6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002efa:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002efe:	2b00      	cmp	r3, #0
 8002f00:	d022      	beq.n	8002f48 <sd_lld_serve_interrupt+0xf8>
 8002f02:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8002f06:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002f0a:	2b00      	cmp	r3, #0
 8002f0c:	d01c      	beq.n	8002f48 <sd_lld_serve_interrupt+0xf8>
    msg_t b;
    osalSysLockFromISR();
 8002f0e:	f7ff fe8f 	bl	8002c30 <osalSysLockFromISR.lto_priv.1>
    b = oqGetI(&sdp->oqueue);
 8002f12:	9b01      	ldr	r3, [sp, #4]
 8002f14:	3330      	adds	r3, #48	; 0x30
 8002f16:	4618      	mov	r0, r3
 8002f18:	f7fe fc12 	bl	8001740 <oqGetI>
 8002f1c:	9004      	str	r0, [sp, #16]
    if (b < MSG_OK) {
 8002f1e:	9b04      	ldr	r3, [sp, #16]
 8002f20:	2b00      	cmp	r3, #0
 8002f22:	da0c      	bge.n	8002f3e <sd_lld_serve_interrupt+0xee>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8002f24:	9b01      	ldr	r3, [sp, #4]
 8002f26:	3304      	adds	r3, #4
 8002f28:	2108      	movs	r1, #8
 8002f2a:	4618      	mov	r0, r3
 8002f2c:	f7ff fe90 	bl	8002c50 <osalEventBroadcastFlagsI.lto_priv.1>
      u->CR1 = cr1 & ~USART_CR1_TXEIE;
 8002f30:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002f34:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8002f38:	9b06      	ldr	r3, [sp, #24]
 8002f3a:	60da      	str	r2, [r3, #12]
 8002f3c:	e002      	b.n	8002f44 <sd_lld_serve_interrupt+0xf4>
    }
    else
      u->DR = b;
 8002f3e:	9a04      	ldr	r2, [sp, #16]
 8002f40:	9b06      	ldr	r3, [sp, #24]
 8002f42:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
 8002f44:	f7ff fe7c 	bl	8002c40 <osalSysUnlockFromISR.lto_priv.1>
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 8002f48:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002f4c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002f50:	2b00      	cmp	r3, #0
 8002f52:	d027      	beq.n	8002fa4 <sd_lld_serve_interrupt+0x154>
 8002f54:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8002f58:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002f5c:	2b00      	cmp	r3, #0
 8002f5e:	d021      	beq.n	8002fa4 <sd_lld_serve_interrupt+0x154>
    osalSysLockFromISR();
 8002f60:	f7ff fe66 	bl	8002c30 <osalSysLockFromISR.lto_priv.1>
    if (oqIsEmptyI(&sdp->oqueue)) {
 8002f64:	9b01      	ldr	r3, [sp, #4]
 8002f66:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8002f68:	9b01      	ldr	r3, [sp, #4]
 8002f6a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002f6c:	429a      	cmp	r2, r3
 8002f6e:	d105      	bne.n	8002f7c <sd_lld_serve_interrupt+0x12c>
 8002f70:	9b01      	ldr	r3, [sp, #4]
 8002f72:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002f74:	2b00      	cmp	r3, #0
 8002f76:	d001      	beq.n	8002f7c <sd_lld_serve_interrupt+0x12c>
 8002f78:	2301      	movs	r3, #1
 8002f7a:	e000      	b.n	8002f7e <sd_lld_serve_interrupt+0x12e>
 8002f7c:	2300      	movs	r3, #0
 8002f7e:	f003 0301 	and.w	r3, r3, #1
 8002f82:	b2db      	uxtb	r3, r3
 8002f84:	2b00      	cmp	r3, #0
 8002f86:	d00b      	beq.n	8002fa0 <sd_lld_serve_interrupt+0x150>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8002f88:	9b01      	ldr	r3, [sp, #4]
 8002f8a:	3304      	adds	r3, #4
 8002f8c:	2110      	movs	r1, #16
 8002f8e:	4618      	mov	r0, r3
 8002f90:	f7ff fe5e 	bl	8002c50 <osalEventBroadcastFlagsI.lto_priv.1>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 8002f94:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002f98:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 8002f9c:	9b06      	ldr	r3, [sp, #24]
 8002f9e:	60da      	str	r2, [r3, #12]
    }
    osalSysUnlockFromISR();
 8002fa0:	f7ff fe4e 	bl	8002c40 <osalSysUnlockFromISR.lto_priv.1>
  }
}
 8002fa4:	bf00      	nop
 8002fa6:	b009      	add	sp, #36	; 0x24
 8002fa8:	f85d fb04 	ldr.w	pc, [sp], #4
 8002fac:	0000      	movs	r0, r0
	...

08002fb0 <osalSysHalt>:
static inline void osalSysHalt(const char *reason) {
 8002fb0:	b500      	push	{lr}
 8002fb2:	b083      	sub	sp, #12
 8002fb4:	9001      	str	r0, [sp, #4]
  chSysHalt(reason);
 8002fb6:	9801      	ldr	r0, [sp, #4]
 8002fb8:	f000 fc0a 	bl	80037d0 <chSysHalt>
}
 8002fbc:	bf00      	nop
 8002fbe:	b003      	add	sp, #12
 8002fc0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002fd0 <translate_errors>:
 *
 * @param[in] sr        USART SR register value
 *
 * @return  The error flags.
 */
static uartflags_t translate_errors(uint16_t sr) {
 8002fd0:	b084      	sub	sp, #16
 8002fd2:	4603      	mov	r3, r0
 8002fd4:	f8ad 3006 	strh.w	r3, [sp, #6]
  uartflags_t sts = 0;
 8002fd8:	2300      	movs	r3, #0
 8002fda:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
 8002fdc:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8002fe0:	f003 0308 	and.w	r3, r3, #8
 8002fe4:	2b00      	cmp	r3, #0
 8002fe6:	d003      	beq.n	8002ff0 <translate_errors+0x20>
    sts |= UART_OVERRUN_ERROR;
 8002fe8:	9b03      	ldr	r3, [sp, #12]
 8002fea:	f043 0310 	orr.w	r3, r3, #16
 8002fee:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
 8002ff0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8002ff4:	f003 0301 	and.w	r3, r3, #1
 8002ff8:	2b00      	cmp	r3, #0
 8002ffa:	d003      	beq.n	8003004 <translate_errors+0x34>
    sts |= UART_PARITY_ERROR;
 8002ffc:	9b03      	ldr	r3, [sp, #12]
 8002ffe:	f043 0304 	orr.w	r3, r3, #4
 8003002:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
 8003004:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8003008:	f003 0302 	and.w	r3, r3, #2
 800300c:	2b00      	cmp	r3, #0
 800300e:	d003      	beq.n	8003018 <translate_errors+0x48>
    sts |= UART_FRAMING_ERROR;
 8003010:	9b03      	ldr	r3, [sp, #12]
 8003012:	f043 0308 	orr.w	r3, r3, #8
 8003016:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
 8003018:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800301c:	f003 0304 	and.w	r3, r3, #4
 8003020:	2b00      	cmp	r3, #0
 8003022:	d003      	beq.n	800302c <translate_errors+0x5c>
    sts |= UART_NOISE_ERROR;
 8003024:	9b03      	ldr	r3, [sp, #12]
 8003026:	f043 0320 	orr.w	r3, r3, #32
 800302a:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_LBD)
 800302c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8003030:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8003034:	2b00      	cmp	r3, #0
 8003036:	d003      	beq.n	8003040 <translate_errors+0x70>
    sts |= UART_BREAK_DETECTED;
 8003038:	9b03      	ldr	r3, [sp, #12]
 800303a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800303e:	9303      	str	r3, [sp, #12]
  return sts;
 8003040:	9b03      	ldr	r3, [sp, #12]
}
 8003042:	4618      	mov	r0, r3
 8003044:	b004      	add	sp, #16
 8003046:	4770      	bx	lr
	...

08003050 <uart_enter_rx_idle_loop>:
/**
 * @brief   Puts the receiver in the UART_RX_IDLE state.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void uart_enter_rx_idle_loop(UARTDriver *uartp) {
 8003050:	b084      	sub	sp, #16
 8003052:	9001      	str	r0, [sp, #4]
  uint32_t mode;

  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
 8003054:	9b01      	ldr	r3, [sp, #4]
 8003056:	685b      	ldr	r3, [r3, #4]
 8003058:	68db      	ldr	r3, [r3, #12]
 800305a:	2b00      	cmp	r3, #0
 800305c:	d103      	bne.n	8003066 <uart_enter_rx_idle_loop+0x16>
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
 800305e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003062:	9303      	str	r3, [sp, #12]
 8003064:	e002      	b.n	800306c <uart_enter_rx_idle_loop+0x1c>
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
 8003066:	f44f 7388 	mov.w	r3, #272	; 0x110
 800306a:	9303      	str	r3, [sp, #12]
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 800306c:	9b01      	ldr	r3, [sp, #4]
 800306e:	f103 0220 	add.w	r2, r3, #32
 8003072:	9b01      	ldr	r3, [sp, #4]
 8003074:	699b      	ldr	r3, [r3, #24]
 8003076:	681b      	ldr	r3, [r3, #0]
 8003078:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 800307a:	9b01      	ldr	r3, [sp, #4]
 800307c:	699b      	ldr	r3, [r3, #24]
 800307e:	681b      	ldr	r3, [r3, #0]
 8003080:	2201      	movs	r2, #1
 8003082:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(uartp->dmarx, uartp->dmarxmode | mode);
 8003084:	9b01      	ldr	r3, [sp, #4]
 8003086:	6919      	ldr	r1, [r3, #16]
 8003088:	9b01      	ldr	r3, [sp, #4]
 800308a:	699b      	ldr	r3, [r3, #24]
 800308c:	681b      	ldr	r3, [r3, #0]
 800308e:	9a03      	ldr	r2, [sp, #12]
 8003090:	430a      	orrs	r2, r1
 8003092:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(uartp->dmarx);
 8003094:	9b01      	ldr	r3, [sp, #4]
 8003096:	699b      	ldr	r3, [r3, #24]
 8003098:	681b      	ldr	r3, [r3, #0]
 800309a:	681a      	ldr	r2, [r3, #0]
 800309c:	9b01      	ldr	r3, [sp, #4]
 800309e:	699b      	ldr	r3, [r3, #24]
 80030a0:	681b      	ldr	r3, [r3, #0]
 80030a2:	f042 0201 	orr.w	r2, r2, #1
 80030a6:	601a      	str	r2, [r3, #0]
}
 80030a8:	bf00      	nop
 80030aa:	b004      	add	sp, #16
 80030ac:	4770      	bx	lr
 80030ae:	bf00      	nop

080030b0 <usart_stop>:
 * @brief   USART de-initialization.
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void usart_stop(UARTDriver *uartp) {
 80030b0:	b082      	sub	sp, #8
 80030b2:	9001      	str	r0, [sp, #4]

  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
 80030b4:	9b01      	ldr	r3, [sp, #4]
 80030b6:	699b      	ldr	r3, [r3, #24]
 80030b8:	681b      	ldr	r3, [r3, #0]
 80030ba:	681a      	ldr	r2, [r3, #0]
 80030bc:	9b01      	ldr	r3, [sp, #4]
 80030be:	699b      	ldr	r3, [r3, #24]
 80030c0:	681b      	ldr	r3, [r3, #0]
 80030c2:	f022 021f 	bic.w	r2, r2, #31
 80030c6:	601a      	str	r2, [r3, #0]
 80030c8:	9b01      	ldr	r3, [sp, #4]
 80030ca:	699b      	ldr	r3, [r3, #24]
 80030cc:	681b      	ldr	r3, [r3, #0]
 80030ce:	681b      	ldr	r3, [r3, #0]
 80030d0:	f003 0301 	and.w	r3, r3, #1
 80030d4:	2b00      	cmp	r3, #0
 80030d6:	d1f7      	bne.n	80030c8 <usart_stop+0x18>
 80030d8:	9b01      	ldr	r3, [sp, #4]
 80030da:	699b      	ldr	r3, [r3, #24]
 80030dc:	7a5b      	ldrb	r3, [r3, #9]
 80030de:	4619      	mov	r1, r3
 80030e0:	9b01      	ldr	r3, [sp, #4]
 80030e2:	699b      	ldr	r3, [r3, #24]
 80030e4:	685b      	ldr	r3, [r3, #4]
 80030e6:	223d      	movs	r2, #61	; 0x3d
 80030e8:	408a      	lsls	r2, r1
 80030ea:	601a      	str	r2, [r3, #0]
  dmaStreamDisable(uartp->dmatx);
 80030ec:	9b01      	ldr	r3, [sp, #4]
 80030ee:	69db      	ldr	r3, [r3, #28]
 80030f0:	681b      	ldr	r3, [r3, #0]
 80030f2:	681a      	ldr	r2, [r3, #0]
 80030f4:	9b01      	ldr	r3, [sp, #4]
 80030f6:	69db      	ldr	r3, [r3, #28]
 80030f8:	681b      	ldr	r3, [r3, #0]
 80030fa:	f022 021f 	bic.w	r2, r2, #31
 80030fe:	601a      	str	r2, [r3, #0]
 8003100:	9b01      	ldr	r3, [sp, #4]
 8003102:	69db      	ldr	r3, [r3, #28]
 8003104:	681b      	ldr	r3, [r3, #0]
 8003106:	681b      	ldr	r3, [r3, #0]
 8003108:	f003 0301 	and.w	r3, r3, #1
 800310c:	2b00      	cmp	r3, #0
 800310e:	d1f7      	bne.n	8003100 <usart_stop+0x50>
 8003110:	9b01      	ldr	r3, [sp, #4]
 8003112:	69db      	ldr	r3, [r3, #28]
 8003114:	7a5b      	ldrb	r3, [r3, #9]
 8003116:	4619      	mov	r1, r3
 8003118:	9b01      	ldr	r3, [sp, #4]
 800311a:	69db      	ldr	r3, [r3, #28]
 800311c:	685b      	ldr	r3, [r3, #4]
 800311e:	223d      	movs	r2, #61	; 0x3d
 8003120:	408a      	lsls	r2, r1
 8003122:	601a      	str	r2, [r3, #0]

  /* Stops USART operations.*/
  uartp->usart->CR1 = 0;
 8003124:	9b01      	ldr	r3, [sp, #4]
 8003126:	689b      	ldr	r3, [r3, #8]
 8003128:	2200      	movs	r2, #0
 800312a:	60da      	str	r2, [r3, #12]
  uartp->usart->CR2 = 0;
 800312c:	9b01      	ldr	r3, [sp, #4]
 800312e:	689b      	ldr	r3, [r3, #8]
 8003130:	2200      	movs	r2, #0
 8003132:	611a      	str	r2, [r3, #16]
  uartp->usart->CR3 = 0;
 8003134:	9b01      	ldr	r3, [sp, #4]
 8003136:	689b      	ldr	r3, [r3, #8]
 8003138:	2200      	movs	r2, #0
 800313a:	615a      	str	r2, [r3, #20]
}
 800313c:	bf00      	nop
 800313e:	b002      	add	sp, #8
 8003140:	4770      	bx	lr
 8003142:	bf00      	nop
	...

08003150 <usart_start>:
 * @brief   USART initialization.
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void usart_start(UARTDriver *uartp) {
 8003150:	b500      	push	{lr}
 8003152:	b087      	sub	sp, #28
 8003154:	9001      	str	r0, [sp, #4]
  uint32_t fck;
  uint16_t cr1;
  USART_TypeDef *u = uartp->usart;
 8003156:	9b01      	ldr	r3, [sp, #4]
 8003158:	689b      	ldr	r3, [r3, #8]
 800315a:	9304      	str	r3, [sp, #16]

  /* Defensive programming, starting from a clean state.*/
  usart_stop(uartp);
 800315c:	9801      	ldr	r0, [sp, #4]
 800315e:	f7ff ffa7 	bl	80030b0 <usart_stop>

  /* Baud rate setting.*/
  fck = (uint32_t)(uartp->clock / uartp->config->speed);
 8003162:	9b01      	ldr	r3, [sp, #4]
 8003164:	68da      	ldr	r2, [r3, #12]
 8003166:	9b01      	ldr	r3, [sp, #4]
 8003168:	685b      	ldr	r3, [r3, #4]
 800316a:	699b      	ldr	r3, [r3, #24]
 800316c:	fbb2 f3f3 	udiv	r3, r2, r3
 8003170:	9305      	str	r3, [sp, #20]

  /* Correcting USARTDIV when oversampling by 8 instead of 16.
     Fraction is still 4 bits wide, but only lower 3 bits used.
     Mantissa is doubled, but Fraction is left the same.*/
#if defined(USART_CR1_OVER8)
  if (uartp->config->cr1 & USART_CR1_OVER8)
 8003172:	9b01      	ldr	r3, [sp, #4]
 8003174:	685b      	ldr	r3, [r3, #4]
 8003176:	8b9b      	ldrh	r3, [r3, #28]
 8003178:	b21b      	sxth	r3, r3
 800317a:	2b00      	cmp	r3, #0
 800317c:	da08      	bge.n	8003190 <usart_start+0x40>
    fck = ((fck & ~7) * 2) | (fck & 7);
 800317e:	9b05      	ldr	r3, [sp, #20]
 8003180:	f023 0307 	bic.w	r3, r3, #7
 8003184:	005a      	lsls	r2, r3, #1
 8003186:	9b05      	ldr	r3, [sp, #20]
 8003188:	f003 0307 	and.w	r3, r3, #7
 800318c:	4313      	orrs	r3, r2
 800318e:	9305      	str	r3, [sp, #20]
#endif
  u->BRR = fck;
 8003190:	9b04      	ldr	r3, [sp, #16]
 8003192:	9a05      	ldr	r2, [sp, #20]
 8003194:	609a      	str	r2, [r3, #8]

  /* Resetting eventual pending status flags.*/
  (void)u->SR;  /* SR reset step 1.*/
 8003196:	9b04      	ldr	r3, [sp, #16]
 8003198:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 800319a:	9b04      	ldr	r3, [sp, #16]
 800319c:	685b      	ldr	r3, [r3, #4]
  u->SR = 0;
 800319e:	9b04      	ldr	r3, [sp, #16]
 80031a0:	2200      	movs	r2, #0
 80031a2:	601a      	str	r2, [r3, #0]

  /* Note that some bits are enforced because required for correct driver
     operations.*/
  u->CR2 = uartp->config->cr2 | USART_CR2_LBDIE;
 80031a4:	9b01      	ldr	r3, [sp, #4]
 80031a6:	685b      	ldr	r3, [r3, #4]
 80031a8:	8bdb      	ldrh	r3, [r3, #30]
 80031aa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80031ae:	b29b      	uxth	r3, r3
 80031b0:	461a      	mov	r2, r3
 80031b2:	9b04      	ldr	r3, [sp, #16]
 80031b4:	611a      	str	r2, [r3, #16]
  u->CR3 = uartp->config->cr3 | USART_CR3_DMAT | USART_CR3_DMAR |
 80031b6:	9b01      	ldr	r3, [sp, #4]
 80031b8:	685b      	ldr	r3, [r3, #4]
 80031ba:	8c1b      	ldrh	r3, [r3, #32]
 80031bc:	f043 03c1 	orr.w	r3, r3, #193	; 0xc1
 80031c0:	b29b      	uxth	r3, r3
 80031c2:	461a      	mov	r2, r3
 80031c4:	9b04      	ldr	r3, [sp, #16]
 80031c6:	615a      	str	r2, [r3, #20]
                                USART_CR3_EIE;

  /* Mustn't ever set TCIE here - if done, it causes an immediate
     interrupt.*/
  cr1 = USART_CR1_UE | USART_CR1_PEIE | USART_CR1_TE | USART_CR1_RE;
 80031c8:	f242 130c 	movw	r3, #8460	; 0x210c
 80031cc:	f8ad 300e 	strh.w	r3, [sp, #14]
  u->CR1 = uartp->config->cr1 | cr1;
 80031d0:	9b01      	ldr	r3, [sp, #4]
 80031d2:	685b      	ldr	r3, [r3, #4]
 80031d4:	8b9a      	ldrh	r2, [r3, #28]
 80031d6:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 80031da:	4313      	orrs	r3, r2
 80031dc:	b29b      	uxth	r3, r3
 80031de:	461a      	mov	r2, r3
 80031e0:	9b04      	ldr	r3, [sp, #16]
 80031e2:	60da      	str	r2, [r3, #12]

  /* Starting the receiver idle loop.*/
  uart_enter_rx_idle_loop(uartp);
 80031e4:	9801      	ldr	r0, [sp, #4]
 80031e6:	f7ff ff33 	bl	8003050 <uart_enter_rx_idle_loop>
}
 80031ea:	bf00      	nop
 80031ec:	b007      	add	sp, #28
 80031ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80031f2:	bf00      	nop
	...

08003200 <uart_lld_serve_rx_end_irq>:
 * @brief   RX DMA common service routine.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void uart_lld_serve_rx_end_irq(UARTDriver *uartp, uint32_t flags) {
 8003200:	b500      	push	{lr}
 8003202:	b083      	sub	sp, #12
 8003204:	9001      	str	r0, [sp, #4]
 8003206:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_UART_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8003208:	9b00      	ldr	r3, [sp, #0]
 800320a:	f003 030c 	and.w	r3, r3, #12
 800320e:	2b00      	cmp	r3, #0
 8003210:	d002      	beq.n	8003218 <uart_lld_serve_rx_end_irq+0x18>
    STM32_UART_DMA_ERROR_HOOK(uartp);
 8003212:	4827      	ldr	r0, [pc, #156]	; (80032b0 <uart_lld_serve_rx_end_irq+0xb0>)
 8003214:	f7ff fecc 	bl	8002fb0 <osalSysHalt>
  }
#else
  (void)flags;
#endif

  if (uartp->rxstate == UART_RX_IDLE) {
 8003218:	9b01      	ldr	r3, [sp, #4]
 800321a:	789b      	ldrb	r3, [r3, #2]
 800321c:	2b00      	cmp	r3, #0
 800321e:	d10e      	bne.n	800323e <uart_lld_serve_rx_end_irq+0x3e>
    /* Receiver in idle state, a callback is generated, if enabled, for each
       received character and then the driver stays in the same state.*/
    _uart_rx_idle_code(uartp);
 8003220:	9b01      	ldr	r3, [sp, #4]
 8003222:	685b      	ldr	r3, [r3, #4]
 8003224:	68db      	ldr	r3, [r3, #12]
 8003226:	2b00      	cmp	r3, #0
 8003228:	d03d      	beq.n	80032a6 <uart_lld_serve_rx_end_irq+0xa6>
 800322a:	9b01      	ldr	r3, [sp, #4]
 800322c:	685b      	ldr	r3, [r3, #4]
 800322e:	68db      	ldr	r3, [r3, #12]
 8003230:	9a01      	ldr	r2, [sp, #4]
 8003232:	8c12      	ldrh	r2, [r2, #32]
 8003234:	b292      	uxth	r2, r2
 8003236:	4611      	mov	r1, r2
 8003238:	9801      	ldr	r0, [sp, #4]
 800323a:	4798      	blx	r3
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaStreamDisable(uartp->dmarx);
    _uart_rx_complete_isr_code(uartp);
  }
}
 800323c:	e033      	b.n	80032a6 <uart_lld_serve_rx_end_irq+0xa6>
    dmaStreamDisable(uartp->dmarx);
 800323e:	9b01      	ldr	r3, [sp, #4]
 8003240:	699b      	ldr	r3, [r3, #24]
 8003242:	681b      	ldr	r3, [r3, #0]
 8003244:	681a      	ldr	r2, [r3, #0]
 8003246:	9b01      	ldr	r3, [sp, #4]
 8003248:	699b      	ldr	r3, [r3, #24]
 800324a:	681b      	ldr	r3, [r3, #0]
 800324c:	f022 021f 	bic.w	r2, r2, #31
 8003250:	601a      	str	r2, [r3, #0]
 8003252:	bf00      	nop
 8003254:	9b01      	ldr	r3, [sp, #4]
 8003256:	699b      	ldr	r3, [r3, #24]
 8003258:	681b      	ldr	r3, [r3, #0]
 800325a:	681b      	ldr	r3, [r3, #0]
 800325c:	f003 0301 	and.w	r3, r3, #1
 8003260:	2b00      	cmp	r3, #0
 8003262:	d1f7      	bne.n	8003254 <uart_lld_serve_rx_end_irq+0x54>
 8003264:	9b01      	ldr	r3, [sp, #4]
 8003266:	699b      	ldr	r3, [r3, #24]
 8003268:	7a5b      	ldrb	r3, [r3, #9]
 800326a:	4619      	mov	r1, r3
 800326c:	9b01      	ldr	r3, [sp, #4]
 800326e:	699b      	ldr	r3, [r3, #24]
 8003270:	685b      	ldr	r3, [r3, #4]
 8003272:	223d      	movs	r2, #61	; 0x3d
 8003274:	408a      	lsls	r2, r1
 8003276:	601a      	str	r2, [r3, #0]
    _uart_rx_complete_isr_code(uartp);
 8003278:	9b01      	ldr	r3, [sp, #4]
 800327a:	2202      	movs	r2, #2
 800327c:	709a      	strb	r2, [r3, #2]
 800327e:	9b01      	ldr	r3, [sp, #4]
 8003280:	685b      	ldr	r3, [r3, #4]
 8003282:	689b      	ldr	r3, [r3, #8]
 8003284:	2b00      	cmp	r3, #0
 8003286:	d004      	beq.n	8003292 <uart_lld_serve_rx_end_irq+0x92>
 8003288:	9b01      	ldr	r3, [sp, #4]
 800328a:	685b      	ldr	r3, [r3, #4]
 800328c:	689b      	ldr	r3, [r3, #8]
 800328e:	9801      	ldr	r0, [sp, #4]
 8003290:	4798      	blx	r3
 8003292:	9b01      	ldr	r3, [sp, #4]
 8003294:	789b      	ldrb	r3, [r3, #2]
 8003296:	2b02      	cmp	r3, #2
 8003298:	d105      	bne.n	80032a6 <uart_lld_serve_rx_end_irq+0xa6>
 800329a:	9b01      	ldr	r3, [sp, #4]
 800329c:	2200      	movs	r2, #0
 800329e:	709a      	strb	r2, [r3, #2]
 80032a0:	9801      	ldr	r0, [sp, #4]
 80032a2:	f7ff fed5 	bl	8003050 <uart_enter_rx_idle_loop>
}
 80032a6:	bf00      	nop
 80032a8:	b003      	add	sp, #12
 80032aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80032ae:	bf00      	nop
 80032b0:	08006e98 	.word	0x08006e98
	...

080032c0 <uart_lld_serve_tx_end_irq>:
 * @brief   TX DMA common service routine.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void uart_lld_serve_tx_end_irq(UARTDriver *uartp, uint32_t flags) {
 80032c0:	b500      	push	{lr}
 80032c2:	b083      	sub	sp, #12
 80032c4:	9001      	str	r0, [sp, #4]
 80032c6:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_UART_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80032c8:	9b00      	ldr	r3, [sp, #0]
 80032ca:	f003 030c 	and.w	r3, r3, #12
 80032ce:	2b00      	cmp	r3, #0
 80032d0:	d002      	beq.n	80032d8 <uart_lld_serve_tx_end_irq+0x18>
    STM32_UART_DMA_ERROR_HOOK(uartp);
 80032d2:	481c      	ldr	r0, [pc, #112]	; (8003344 <uart_lld_serve_tx_end_irq+0x84>)
 80032d4:	f7ff fe6c 	bl	8002fb0 <osalSysHalt>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(uartp->dmatx);
 80032d8:	9b01      	ldr	r3, [sp, #4]
 80032da:	69db      	ldr	r3, [r3, #28]
 80032dc:	681b      	ldr	r3, [r3, #0]
 80032de:	681a      	ldr	r2, [r3, #0]
 80032e0:	9b01      	ldr	r3, [sp, #4]
 80032e2:	69db      	ldr	r3, [r3, #28]
 80032e4:	681b      	ldr	r3, [r3, #0]
 80032e6:	f022 021f 	bic.w	r2, r2, #31
 80032ea:	601a      	str	r2, [r3, #0]
 80032ec:	bf00      	nop
 80032ee:	9b01      	ldr	r3, [sp, #4]
 80032f0:	69db      	ldr	r3, [r3, #28]
 80032f2:	681b      	ldr	r3, [r3, #0]
 80032f4:	681b      	ldr	r3, [r3, #0]
 80032f6:	f003 0301 	and.w	r3, r3, #1
 80032fa:	2b00      	cmp	r3, #0
 80032fc:	d1f7      	bne.n	80032ee <uart_lld_serve_tx_end_irq+0x2e>
 80032fe:	9b01      	ldr	r3, [sp, #4]
 8003300:	69db      	ldr	r3, [r3, #28]
 8003302:	7a5b      	ldrb	r3, [r3, #9]
 8003304:	4619      	mov	r1, r3
 8003306:	9b01      	ldr	r3, [sp, #4]
 8003308:	69db      	ldr	r3, [r3, #28]
 800330a:	685b      	ldr	r3, [r3, #4]
 800330c:	223d      	movs	r2, #61	; 0x3d
 800330e:	408a      	lsls	r2, r1
 8003310:	601a      	str	r2, [r3, #0]

  /* A callback is generated, if enabled, after a completed transfer.*/
  _uart_tx1_isr_code(uartp);
 8003312:	9b01      	ldr	r3, [sp, #4]
 8003314:	2202      	movs	r2, #2
 8003316:	705a      	strb	r2, [r3, #1]
 8003318:	9b01      	ldr	r3, [sp, #4]
 800331a:	685b      	ldr	r3, [r3, #4]
 800331c:	681b      	ldr	r3, [r3, #0]
 800331e:	2b00      	cmp	r3, #0
 8003320:	d004      	beq.n	800332c <uart_lld_serve_tx_end_irq+0x6c>
 8003322:	9b01      	ldr	r3, [sp, #4]
 8003324:	685b      	ldr	r3, [r3, #4]
 8003326:	681b      	ldr	r3, [r3, #0]
 8003328:	9801      	ldr	r0, [sp, #4]
 800332a:	4798      	blx	r3
 800332c:	9b01      	ldr	r3, [sp, #4]
 800332e:	785b      	ldrb	r3, [r3, #1]
 8003330:	2b02      	cmp	r3, #2
 8003332:	d102      	bne.n	800333a <uart_lld_serve_tx_end_irq+0x7a>
 8003334:	9b01      	ldr	r3, [sp, #4]
 8003336:	2200      	movs	r2, #0
 8003338:	705a      	strb	r2, [r3, #1]
}
 800333a:	bf00      	nop
 800333c:	b003      	add	sp, #12
 800333e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003342:	bf00      	nop
 8003344:	08006e98 	.word	0x08006e98
	...

08003350 <uart_lld_init>:
/**
 * @brief   Low level UART driver initialization.
 *
 * @notapi
 */
void uart_lld_init(void) {
 8003350:	b508      	push	{r3, lr}

#if STM32_UART_USE_USART1
  uartObjectInit(&UARTD1);
 8003352:	480b      	ldr	r0, [pc, #44]	; (8003380 <uart_lld_init+0x30>)
 8003354:	f7fe fc44 	bl	8001be0 <uartObjectInit>
  UARTD1.usart   = USART1;
 8003358:	4b09      	ldr	r3, [pc, #36]	; (8003380 <uart_lld_init+0x30>)
 800335a:	4a0a      	ldr	r2, [pc, #40]	; (8003384 <uart_lld_init+0x34>)
 800335c:	609a      	str	r2, [r3, #8]
  UARTD1.clock   = STM32_PCLK2;
 800335e:	4b08      	ldr	r3, [pc, #32]	; (8003380 <uart_lld_init+0x30>)
 8003360:	4a09      	ldr	r2, [pc, #36]	; (8003388 <uart_lld_init+0x38>)
 8003362:	60da      	str	r2, [r3, #12]
  UARTD1.dmarxmode = STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE;
 8003364:	4b06      	ldr	r3, [pc, #24]	; (8003380 <uart_lld_init+0x30>)
 8003366:	2206      	movs	r2, #6
 8003368:	611a      	str	r2, [r3, #16]
  UARTD1.dmatxmode = STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE;
 800336a:	4b05      	ldr	r3, [pc, #20]	; (8003380 <uart_lld_init+0x30>)
 800336c:	2206      	movs	r2, #6
 800336e:	615a      	str	r2, [r3, #20]
  UARTD1.dmarx   = NULL;
 8003370:	4b03      	ldr	r3, [pc, #12]	; (8003380 <uart_lld_init+0x30>)
 8003372:	2200      	movs	r2, #0
 8003374:	619a      	str	r2, [r3, #24]
  UARTD1.dmatx   = NULL;
 8003376:	4b02      	ldr	r3, [pc, #8]	; (8003380 <uart_lld_init+0x30>)
 8003378:	2200      	movs	r2, #0
 800337a:	61da      	str	r2, [r3, #28]
  UARTD10.dmarxmode = STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE;
  UARTD10.dmatxmode = STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE;
  UARTD10.dmarx   = NULL;
  UARTD10.dmatx   = NULL;
#endif
}
 800337c:	bf00      	nop
 800337e:	bd08      	pop	{r3, pc}
 8003380:	20000d5c 	.word	0x20000d5c
 8003384:	40011000 	.word	0x40011000
 8003388:	0501bd00 	.word	0x0501bd00
 800338c:	00000000 	.word	0x00000000

08003390 <uart_lld_start>:
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {
 8003390:	b500      	push	{lr}
 8003392:	b083      	sub	sp, #12
 8003394:	9001      	str	r0, [sp, #4]

  if (uartp->state == UART_STOP) {
 8003396:	9b01      	ldr	r3, [sp, #4]
 8003398:	781b      	ldrb	r3, [r3, #0]
 800339a:	2b01      	cmp	r3, #1
 800339c:	d158      	bne.n	8003450 <uart_lld_start+0xc0>
#if STM32_UART_USE_USART1
    if (&UARTD1 == uartp) {
 800339e:	9b01      	ldr	r3, [sp, #4]
 80033a0:	4a32      	ldr	r2, [pc, #200]	; (800346c <uart_lld_start+0xdc>)
 80033a2:	4293      	cmp	r3, r2
 80033a4:	d12f      	bne.n	8003406 <uart_lld_start+0x76>
      uartp->dmarx = dmaStreamAllocI(STM32_UART_USART1_RX_DMA_STREAM,
 80033a6:	9b01      	ldr	r3, [sp, #4]
 80033a8:	4a31      	ldr	r2, [pc, #196]	; (8003470 <uart_lld_start+0xe0>)
 80033aa:	210c      	movs	r1, #12
 80033ac:	200d      	movs	r0, #13
 80033ae:	f7ff f9df 	bl	8002770 <dmaStreamAllocI>
 80033b2:	4602      	mov	r2, r0
 80033b4:	9b01      	ldr	r3, [sp, #4]
 80033b6:	619a      	str	r2, [r3, #24]
                                     STM32_UART_USART1_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)uart_lld_serve_rx_end_irq,
                                     (void *)uartp);
      osalDbgAssert(uartp->dmarx != NULL, "unable to allocate stream");
      uartp->dmatx = dmaStreamAllocI(STM32_UART_USART1_TX_DMA_STREAM,
 80033b8:	9b01      	ldr	r3, [sp, #4]
 80033ba:	4a2e      	ldr	r2, [pc, #184]	; (8003474 <uart_lld_start+0xe4>)
 80033bc:	210c      	movs	r1, #12
 80033be:	200f      	movs	r0, #15
 80033c0:	f7ff f9d6 	bl	8002770 <dmaStreamAllocI>
 80033c4:	4602      	mov	r2, r0
 80033c6:	9b01      	ldr	r3, [sp, #4]
 80033c8:	61da      	str	r2, [r3, #28]
                                     STM32_UART_USART1_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)uart_lld_serve_tx_end_irq,
                                     (void *)uartp);
      osalDbgAssert(uartp->dmatx != NULL, "unable to allocate stream");

      rccEnableUSART1(true);
 80033ca:	4b2b      	ldr	r3, [pc, #172]	; (8003478 <uart_lld_start+0xe8>)
 80033cc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80033ce:	4a2a      	ldr	r2, [pc, #168]	; (8003478 <uart_lld_start+0xe8>)
 80033d0:	f043 0310 	orr.w	r3, r3, #16
 80033d4:	6453      	str	r3, [r2, #68]	; 0x44
 80033d6:	4b28      	ldr	r3, [pc, #160]	; (8003478 <uart_lld_start+0xe8>)
 80033d8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80033da:	4a27      	ldr	r2, [pc, #156]	; (8003478 <uart_lld_start+0xe8>)
 80033dc:	f043 0310 	orr.w	r3, r3, #16
 80033e0:	6653      	str	r3, [r2, #100]	; 0x64
 80033e2:	4b25      	ldr	r3, [pc, #148]	; (8003478 <uart_lld_start+0xe8>)
 80033e4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
      nvicEnableVector(STM32_USART1_NUMBER, STM32_UART_USART1_IRQ_PRIORITY);
 80033e6:	210c      	movs	r1, #12
 80033e8:	2025      	movs	r0, #37	; 0x25
 80033ea:	f7fe fc49 	bl	8001c80 <nvicEnableVector>
      uartp->dmarxmode |= STM32_DMA_CR_CHSEL(USART1_RX_DMA_CHANNEL) |
 80033ee:	9b01      	ldr	r3, [sp, #4]
 80033f0:	691b      	ldr	r3, [r3, #16]
 80033f2:	f043 6200 	orr.w	r2, r3, #134217728	; 0x8000000
 80033f6:	9b01      	ldr	r3, [sp, #4]
 80033f8:	611a      	str	r2, [r3, #16]
                          STM32_DMA_CR_PL(STM32_UART_USART1_DMA_PRIORITY);
      uartp->dmatxmode |= STM32_DMA_CR_CHSEL(USART1_TX_DMA_CHANNEL) |
 80033fa:	9b01      	ldr	r3, [sp, #4]
 80033fc:	695b      	ldr	r3, [r3, #20]
 80033fe:	f043 6200 	orr.w	r2, r3, #134217728	; 0x8000000
 8003402:	9b01      	ldr	r3, [sp, #4]
 8003404:	615a      	str	r2, [r3, #20]
    }
#endif

    /* Static DMA setup, the transfer size depends on the USART settings,
       it is 16 bits if M=1 and PCE=0 else it is 8 bits.*/
    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M) {
 8003406:	9b01      	ldr	r3, [sp, #4]
 8003408:	685b      	ldr	r3, [r3, #4]
 800340a:	8b9b      	ldrh	r3, [r3, #28]
 800340c:	f403 53a0 	and.w	r3, r3, #5120	; 0x1400
 8003410:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003414:	d10b      	bne.n	800342e <uart_lld_start+0x9e>
      uartp->dmarxmode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8003416:	9b01      	ldr	r3, [sp, #4]
 8003418:	691b      	ldr	r3, [r3, #16]
 800341a:	f443 5220 	orr.w	r2, r3, #10240	; 0x2800
 800341e:	9b01      	ldr	r3, [sp, #4]
 8003420:	611a      	str	r2, [r3, #16]
      uartp->dmatxmode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8003422:	9b01      	ldr	r3, [sp, #4]
 8003424:	695b      	ldr	r3, [r3, #20]
 8003426:	f443 5220 	orr.w	r2, r3, #10240	; 0x2800
 800342a:	9b01      	ldr	r3, [sp, #4]
 800342c:	615a      	str	r2, [r3, #20]
    }
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->DR);
 800342e:	9b01      	ldr	r3, [sp, #4]
 8003430:	689b      	ldr	r3, [r3, #8]
 8003432:	1d1a      	adds	r2, r3, #4
 8003434:	9b01      	ldr	r3, [sp, #4]
 8003436:	699b      	ldr	r3, [r3, #24]
 8003438:	681b      	ldr	r3, [r3, #0]
 800343a:	609a      	str	r2, [r3, #8]
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->DR);
 800343c:	9b01      	ldr	r3, [sp, #4]
 800343e:	689b      	ldr	r3, [r3, #8]
 8003440:	1d1a      	adds	r2, r3, #4
 8003442:	9b01      	ldr	r3, [sp, #4]
 8003444:	69db      	ldr	r3, [r3, #28]
 8003446:	681b      	ldr	r3, [r3, #0]
 8003448:	609a      	str	r2, [r3, #8]
    uartp->rxbuf = 0;
 800344a:	9b01      	ldr	r3, [sp, #4]
 800344c:	2200      	movs	r2, #0
 800344e:	841a      	strh	r2, [r3, #32]
  }

  uartp->rxstate = UART_RX_IDLE;
 8003450:	9b01      	ldr	r3, [sp, #4]
 8003452:	2200      	movs	r2, #0
 8003454:	709a      	strb	r2, [r3, #2]
  uartp->txstate = UART_TX_IDLE;
 8003456:	9b01      	ldr	r3, [sp, #4]
 8003458:	2200      	movs	r2, #0
 800345a:	705a      	strb	r2, [r3, #1]
  usart_start(uartp);
 800345c:	9801      	ldr	r0, [sp, #4]
 800345e:	f7ff fe77 	bl	8003150 <usart_start>
}
 8003462:	bf00      	nop
 8003464:	b003      	add	sp, #12
 8003466:	f85d fb04 	ldr.w	pc, [sp], #4
 800346a:	bf00      	nop
 800346c:	20000d5c 	.word	0x20000d5c
 8003470:	08003201 	.word	0x08003201
 8003474:	080032c1 	.word	0x080032c1
 8003478:	40023800 	.word	0x40023800
 800347c:	00000000 	.word	0x00000000

08003480 <uart_lld_stop>:
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 *
 * @notapi
 */
void uart_lld_stop(UARTDriver *uartp) {
 8003480:	b500      	push	{lr}
 8003482:	b083      	sub	sp, #12
 8003484:	9001      	str	r0, [sp, #4]

  if (uartp->state == UART_READY) {
 8003486:	9b01      	ldr	r3, [sp, #4]
 8003488:	781b      	ldrb	r3, [r3, #0]
 800348a:	2b02      	cmp	r3, #2
 800348c:	d128      	bne.n	80034e0 <uart_lld_stop+0x60>
    usart_stop(uartp);
 800348e:	9801      	ldr	r0, [sp, #4]
 8003490:	f7ff fe0e 	bl	80030b0 <usart_stop>
    dmaStreamFreeI(uartp->dmarx);
 8003494:	9b01      	ldr	r3, [sp, #4]
 8003496:	699b      	ldr	r3, [r3, #24]
 8003498:	4618      	mov	r0, r3
 800349a:	f7ff fa01 	bl	80028a0 <dmaStreamFreeI>
    dmaStreamFreeI(uartp->dmatx);
 800349e:	9b01      	ldr	r3, [sp, #4]
 80034a0:	69db      	ldr	r3, [r3, #28]
 80034a2:	4618      	mov	r0, r3
 80034a4:	f7ff f9fc 	bl	80028a0 <dmaStreamFreeI>
    uartp->dmarx = NULL;
 80034a8:	9b01      	ldr	r3, [sp, #4]
 80034aa:	2200      	movs	r2, #0
 80034ac:	619a      	str	r2, [r3, #24]
    uartp->dmatx = NULL;
 80034ae:	9b01      	ldr	r3, [sp, #4]
 80034b0:	2200      	movs	r2, #0
 80034b2:	61da      	str	r2, [r3, #28]

#if STM32_UART_USE_USART1
    if (&UARTD1 == uartp) {
 80034b4:	9b01      	ldr	r3, [sp, #4]
 80034b6:	4a0c      	ldr	r2, [pc, #48]	; (80034e8 <uart_lld_stop+0x68>)
 80034b8:	4293      	cmp	r3, r2
 80034ba:	d111      	bne.n	80034e0 <uart_lld_stop+0x60>
      nvicDisableVector(STM32_USART1_NUMBER);
 80034bc:	2025      	movs	r0, #37	; 0x25
 80034be:	f7fe fc0f 	bl	8001ce0 <nvicDisableVector>
      rccDisableUSART1();
 80034c2:	4b0a      	ldr	r3, [pc, #40]	; (80034ec <uart_lld_stop+0x6c>)
 80034c4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80034c6:	4a09      	ldr	r2, [pc, #36]	; (80034ec <uart_lld_stop+0x6c>)
 80034c8:	f023 0310 	bic.w	r3, r3, #16
 80034cc:	6453      	str	r3, [r2, #68]	; 0x44
 80034ce:	4b07      	ldr	r3, [pc, #28]	; (80034ec <uart_lld_stop+0x6c>)
 80034d0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80034d2:	4a06      	ldr	r2, [pc, #24]	; (80034ec <uart_lld_stop+0x6c>)
 80034d4:	f023 0310 	bic.w	r3, r3, #16
 80034d8:	6653      	str	r3, [r2, #100]	; 0x64
 80034da:	4b04      	ldr	r3, [pc, #16]	; (80034ec <uart_lld_stop+0x6c>)
 80034dc:	6e5b      	ldr	r3, [r3, #100]	; 0x64
      return;
 80034de:	bf00      	nop
      rccDisableUART10();
      return;
    }
#endif
  }
}
 80034e0:	b003      	add	sp, #12
 80034e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80034e6:	bf00      	nop
 80034e8:	20000d5c 	.word	0x20000d5c
 80034ec:	40023800 	.word	0x40023800

080034f0 <uart_lld_serve_interrupt>:
/**
 * @brief   USART common service routine.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
void uart_lld_serve_interrupt(UARTDriver *uartp) {
 80034f0:	b510      	push	{r4, lr}
 80034f2:	b086      	sub	sp, #24
 80034f4:	9001      	str	r0, [sp, #4]
  uint16_t sr;
  USART_TypeDef *u = uartp->usart;
 80034f6:	9b01      	ldr	r3, [sp, #4]
 80034f8:	689b      	ldr	r3, [r3, #8]
 80034fa:	9305      	str	r3, [sp, #20]
  uint32_t cr1 = u->CR1;
 80034fc:	9b05      	ldr	r3, [sp, #20]
 80034fe:	68db      	ldr	r3, [r3, #12]
 8003500:	9304      	str	r3, [sp, #16]

  sr = u->SR;   /* SR reset step 1.*/
 8003502:	9b05      	ldr	r3, [sp, #20]
 8003504:	681b      	ldr	r3, [r3, #0]
 8003506:	f8ad 300e 	strh.w	r3, [sp, #14]
  (void)u->DR;  /* SR reset step 2.*/
 800350a:	9b05      	ldr	r3, [sp, #20]
 800350c:	685b      	ldr	r3, [r3, #4]

  if (sr & (USART_SR_LBD | USART_SR_ORE | USART_SR_NE |
 800350e:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 8003512:	f240 130f 	movw	r3, #271	; 0x10f
 8003516:	4013      	ands	r3, r2
 8003518:	2b00      	cmp	r3, #0
 800351a:	d014      	beq.n	8003546 <uart_lld_serve_interrupt+0x56>
            USART_SR_FE  | USART_SR_PE)) {
    u->SR = ~USART_SR_LBD;
 800351c:	9b05      	ldr	r3, [sp, #20]
 800351e:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8003522:	601a      	str	r2, [r3, #0]
    _uart_rx_error_isr_code(uartp, translate_errors(sr));
 8003524:	9b01      	ldr	r3, [sp, #4]
 8003526:	685b      	ldr	r3, [r3, #4]
 8003528:	691b      	ldr	r3, [r3, #16]
 800352a:	2b00      	cmp	r3, #0
 800352c:	d00b      	beq.n	8003546 <uart_lld_serve_interrupt+0x56>
 800352e:	9b01      	ldr	r3, [sp, #4]
 8003530:	685b      	ldr	r3, [r3, #4]
 8003532:	691c      	ldr	r4, [r3, #16]
 8003534:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8003538:	4618      	mov	r0, r3
 800353a:	f7ff fd49 	bl	8002fd0 <translate_errors>
 800353e:	4603      	mov	r3, r0
 8003540:	4619      	mov	r1, r3
 8003542:	9801      	ldr	r0, [sp, #4]
 8003544:	47a0      	blx	r4
  }

  if ((sr & USART_SR_TC) && (cr1 & USART_CR1_TCIE)) {
 8003546:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800354a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800354e:	2b00      	cmp	r3, #0
 8003550:	d017      	beq.n	8003582 <uart_lld_serve_interrupt+0x92>
 8003552:	9b04      	ldr	r3, [sp, #16]
 8003554:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8003558:	2b00      	cmp	r3, #0
 800355a:	d012      	beq.n	8003582 <uart_lld_serve_interrupt+0x92>
    /* TC interrupt cleared and disabled.*/
    u->SR = ~USART_SR_TC;
 800355c:	9b05      	ldr	r3, [sp, #20]
 800355e:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8003562:	601a      	str	r2, [r3, #0]
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8003564:	9b04      	ldr	r3, [sp, #16]
 8003566:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 800356a:	9b05      	ldr	r3, [sp, #20]
 800356c:	60da      	str	r2, [r3, #12]

    /* End of transmission, a callback is generated.*/
    _uart_tx2_isr_code(uartp);
 800356e:	9b01      	ldr	r3, [sp, #4]
 8003570:	685b      	ldr	r3, [r3, #4]
 8003572:	685b      	ldr	r3, [r3, #4]
 8003574:	2b00      	cmp	r3, #0
 8003576:	d004      	beq.n	8003582 <uart_lld_serve_interrupt+0x92>
 8003578:	9b01      	ldr	r3, [sp, #4]
 800357a:	685b      	ldr	r3, [r3, #4]
 800357c:	685b      	ldr	r3, [r3, #4]
 800357e:	9801      	ldr	r0, [sp, #4]
 8003580:	4798      	blx	r3
  }

  /* Timeout interrupt sources are only checked if enabled in CR1.*/
  if ((cr1 & USART_CR1_IDLEIE) && (sr & USART_SR_IDLE)) {
 8003582:	9b04      	ldr	r3, [sp, #16]
 8003584:	f003 0310 	and.w	r3, r3, #16
 8003588:	2b00      	cmp	r3, #0
 800358a:	d00f      	beq.n	80035ac <uart_lld_serve_interrupt+0xbc>
 800358c:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8003590:	f003 0310 	and.w	r3, r3, #16
 8003594:	2b00      	cmp	r3, #0
 8003596:	d009      	beq.n	80035ac <uart_lld_serve_interrupt+0xbc>
    _uart_timeout_isr_code(uartp);
 8003598:	9b01      	ldr	r3, [sp, #4]
 800359a:	685b      	ldr	r3, [r3, #4]
 800359c:	695b      	ldr	r3, [r3, #20]
 800359e:	2b00      	cmp	r3, #0
 80035a0:	d004      	beq.n	80035ac <uart_lld_serve_interrupt+0xbc>
 80035a2:	9b01      	ldr	r3, [sp, #4]
 80035a4:	685b      	ldr	r3, [r3, #4]
 80035a6:	695b      	ldr	r3, [r3, #20]
 80035a8:	9801      	ldr	r0, [sp, #4]
 80035aa:	4798      	blx	r3
  }
}
 80035ac:	bf00      	nop
 80035ae:	b006      	add	sp, #24
 80035b0:	bd10      	pop	{r4, pc}
 80035b2:	bf00      	nop
	...

080035c0 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
 80035c0:	b082      	sub	sp, #8
 80035c2:	9001      	str	r0, [sp, #4]
 80035c4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 80035c6:	9b00      	ldr	r3, [sp, #0]
 80035c8:	685a      	ldr	r2, [r3, #4]
 80035ca:	9b01      	ldr	r3, [sp, #4]
 80035cc:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80035ce:	9b00      	ldr	r3, [sp, #0]
 80035d0:	689a      	ldr	r2, [r3, #8]
 80035d2:	9b01      	ldr	r3, [sp, #4]
 80035d4:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80035d6:	9b00      	ldr	r3, [sp, #0]
 80035d8:	68da      	ldr	r2, [r3, #12]
 80035da:	9b01      	ldr	r3, [sp, #4]
 80035dc:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 80035de:	9b00      	ldr	r3, [sp, #0]
 80035e0:	691a      	ldr	r2, [r3, #16]
 80035e2:	9b01      	ldr	r3, [sp, #4]
 80035e4:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80035e6:	9b00      	ldr	r3, [sp, #0]
 80035e8:	695a      	ldr	r2, [r3, #20]
 80035ea:	9b01      	ldr	r3, [sp, #4]
 80035ec:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80035ee:	9b00      	ldr	r3, [sp, #0]
 80035f0:	699a      	ldr	r2, [r3, #24]
 80035f2:	9b01      	ldr	r3, [sp, #4]
 80035f4:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80035f6:	9b00      	ldr	r3, [sp, #0]
 80035f8:	681a      	ldr	r2, [r3, #0]
 80035fa:	9b01      	ldr	r3, [sp, #4]
 80035fc:	601a      	str	r2, [r3, #0]
}
 80035fe:	bf00      	nop
 8003600:	b002      	add	sp, #8
 8003602:	4770      	bx	lr
	...

08003610 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 8003610:	b508      	push	{r3, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8003612:	4b1b      	ldr	r3, [pc, #108]	; (8003680 <stm32_gpio_init+0x70>)
 8003614:	691b      	ldr	r3, [r3, #16]
 8003616:	4a1a      	ldr	r2, [pc, #104]	; (8003680 <stm32_gpio_init+0x70>)
 8003618:	f043 031f 	orr.w	r3, r3, #31
 800361c:	6113      	str	r3, [r2, #16]
 800361e:	4b18      	ldr	r3, [pc, #96]	; (8003680 <stm32_gpio_init+0x70>)
 8003620:	691b      	ldr	r3, [r3, #16]
 8003622:	4a17      	ldr	r2, [pc, #92]	; (8003680 <stm32_gpio_init+0x70>)
 8003624:	f023 031f 	bic.w	r3, r3, #31
 8003628:	6113      	str	r3, [r2, #16]
 800362a:	4b15      	ldr	r3, [pc, #84]	; (8003680 <stm32_gpio_init+0x70>)
 800362c:	691b      	ldr	r3, [r3, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 800362e:	4b14      	ldr	r3, [pc, #80]	; (8003680 <stm32_gpio_init+0x70>)
 8003630:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003632:	4a13      	ldr	r2, [pc, #76]	; (8003680 <stm32_gpio_init+0x70>)
 8003634:	f043 031f 	orr.w	r3, r3, #31
 8003638:	6313      	str	r3, [r2, #48]	; 0x30
 800363a:	4b11      	ldr	r3, [pc, #68]	; (8003680 <stm32_gpio_init+0x70>)
 800363c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800363e:	4a10      	ldr	r2, [pc, #64]	; (8003680 <stm32_gpio_init+0x70>)
 8003640:	f043 031f 	orr.w	r3, r3, #31
 8003644:	6513      	str	r3, [r2, #80]	; 0x50
 8003646:	4b0e      	ldr	r3, [pc, #56]	; (8003680 <stm32_gpio_init+0x70>)
 8003648:	6d1b      	ldr	r3, [r3, #80]	; 0x50

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 800364a:	490e      	ldr	r1, [pc, #56]	; (8003684 <stm32_gpio_init+0x74>)
 800364c:	480e      	ldr	r0, [pc, #56]	; (8003688 <stm32_gpio_init+0x78>)
 800364e:	f7ff ffb7 	bl	80035c0 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 8003652:	490e      	ldr	r1, [pc, #56]	; (800368c <stm32_gpio_init+0x7c>)
 8003654:	480e      	ldr	r0, [pc, #56]	; (8003690 <stm32_gpio_init+0x80>)
 8003656:	f7ff ffb3 	bl	80035c0 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 800365a:	490e      	ldr	r1, [pc, #56]	; (8003694 <stm32_gpio_init+0x84>)
 800365c:	480e      	ldr	r0, [pc, #56]	; (8003698 <stm32_gpio_init+0x88>)
 800365e:	f7ff ffaf 	bl	80035c0 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 8003662:	490e      	ldr	r1, [pc, #56]	; (800369c <stm32_gpio_init+0x8c>)
 8003664:	480e      	ldr	r0, [pc, #56]	; (80036a0 <stm32_gpio_init+0x90>)
 8003666:	f7ff ffab 	bl	80035c0 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
 800366a:	490e      	ldr	r1, [pc, #56]	; (80036a4 <stm32_gpio_init+0x94>)
 800366c:	480e      	ldr	r0, [pc, #56]	; (80036a8 <stm32_gpio_init+0x98>)
 800366e:	f7ff ffa7 	bl	80035c0 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
 8003672:	490e      	ldr	r1, [pc, #56]	; (80036ac <stm32_gpio_init+0x9c>)
 8003674:	480e      	ldr	r0, [pc, #56]	; (80036b0 <stm32_gpio_init+0xa0>)
 8003676:	f7ff ffa3 	bl	80035c0 <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
#endif
}
 800367a:	bf00      	nop
 800367c:	bd08      	pop	{r3, pc}
 800367e:	bf00      	nop
 8003680:	40023800 	.word	0x40023800
 8003684:	08006ea4 	.word	0x08006ea4
 8003688:	40020000 	.word	0x40020000
 800368c:	08006ec0 	.word	0x08006ec0
 8003690:	40020400 	.word	0x40020400
 8003694:	08006edc 	.word	0x08006edc
 8003698:	40020800 	.word	0x40020800
 800369c:	08006ef8 	.word	0x08006ef8
 80036a0:	40020c00 	.word	0x40020c00
 80036a4:	08006f14 	.word	0x08006f14
 80036a8:	40021000 	.word	0x40021000
 80036ac:	08006f30 	.word	0x08006f30
 80036b0:	40021c00 	.word	0x40021c00
	...

080036c0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 80036c0:	b508      	push	{r3, lr}

  stm32_gpio_init();
 80036c2:	f7ff ffa5 	bl	8003610 <stm32_gpio_init>
  stm32_clock_init();
 80036c6:	f7fe fd13 	bl	80020f0 <stm32_clock_init>
}
 80036ca:	bf00      	nop
 80036cc:	bd08      	pop	{r3, pc}
 80036ce:	bf00      	nop

080036d0 <boardInit>:
 * @brief   Board-specific initialization code.
 * @note    You can add your board-specific code here.
 */
void boardInit(void) {

}
 80036d0:	bf00      	nop
 80036d2:	4770      	bx	lr
	...

080036e0 <__tm_calibration_object_init>:
 *
 * @param[out] tcp      pointer to the @p tm_calibration_t structure
 *
 * @notapi
 */
static inline void __tm_calibration_object_init(tm_calibration_t *tcp) {
 80036e0:	b500      	push	{lr}
 80036e2:	b08b      	sub	sp, #44	; 0x2c
 80036e4:	9001      	str	r0, [sp, #4]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 80036e6:	9b01      	ldr	r3, [sp, #4]
 80036e8:	2200      	movs	r2, #0
 80036ea:	601a      	str	r2, [r3, #0]
  chTMObjectInit(&tm);
 80036ec:	ab02      	add	r3, sp, #8
 80036ee:	4618      	mov	r0, r3
 80036f0:	f001 f916 	bl	8004920 <chTMObjectInit>
  i = TM_CALIBRATION_LOOP;
 80036f4:	2304      	movs	r3, #4
 80036f6:	9309      	str	r3, [sp, #36]	; 0x24
  do {
    chTMStartMeasurementX(&tm);
 80036f8:	ab02      	add	r3, sp, #8
 80036fa:	4618      	mov	r0, r3
 80036fc:	f001 f930 	bl	8004960 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 8003700:	ab02      	add	r3, sp, #8
 8003702:	4618      	mov	r0, r3
 8003704:	f001 f93c 	bl	8004980 <chTMStopMeasurementX>
    i--;
 8003708:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800370a:	3b01      	subs	r3, #1
 800370c:	9309      	str	r3, [sp, #36]	; 0x24
  } while (i > 0U);
 800370e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003710:	2b00      	cmp	r3, #0
 8003712:	d1f1      	bne.n	80036f8 <__tm_calibration_object_init+0x18>
  tcp->offset = tm.best;
 8003714:	9a02      	ldr	r2, [sp, #8]
 8003716:	9b01      	ldr	r3, [sp, #4]
 8003718:	601a      	str	r2, [r3, #0]
}
 800371a:	bf00      	nop
 800371c:	b00b      	add	sp, #44	; 0x2c
 800371e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003722:	bf00      	nop
	...

08003730 <chSysUnlock.lto_priv.5>:
static inline void chSysUnlock(void) {
 8003730:	b082      	sub	sp, #8
 8003732:	2300      	movs	r3, #0
 8003734:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003736:	9b01      	ldr	r3, [sp, #4]
 8003738:	f383 8811 	msr	BASEPRI, r3
}
 800373c:	bf00      	nop
}
 800373e:	bf00      	nop
}
 8003740:	bf00      	nop
 8003742:	b002      	add	sp, #8
 8003744:	4770      	bx	lr
 8003746:	bf00      	nop
	...

08003750 <__oslib_init>:
/**
 * @brief   Initialization of all library modules.
 *
 * @notapi
 */
static inline void __oslib_init(void) {
 8003750:	b508      	push	{r3, lr}

#if CH_CFG_USE_MEMCORE == TRUE
  __core_init();
 8003752:	f001 f9cd 	bl	8004af0 <__core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  __heap_init();
 8003756:	f001 fa1b 	bl	8004b90 <__heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  __factory_init();
 800375a:	f001 fa71 	bl	8004c40 <__factory_init>
#endif
}
 800375e:	bf00      	nop
 8003760:	bd08      	pop	{r3, pc}
 8003762:	bf00      	nop
	...

08003770 <chSysInit>:
 *          interrupts are enabled.
 * @post    the system is in @p ch_sys_running state.
 *
 * @special
 */
void chSysInit(void) {
 8003770:	b500      	push	{lr}
 8003772:	b083      	sub	sp, #12
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 8003774:	4b11      	ldr	r3, [pc, #68]	; (80037bc <chSysInit+0x4c>)
 8003776:	2201      	movs	r2, #1
 8003778:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 800377a:	2300      	movs	r3, #0
 800377c:	9301      	str	r3, [sp, #4]
 800377e:	e008      	b.n	8003792 <chSysInit+0x22>
    ch_system.instances[i] = NULL;
 8003780:	4a0e      	ldr	r2, [pc, #56]	; (80037bc <chSysInit+0x4c>)
 8003782:	9b01      	ldr	r3, [sp, #4]
 8003784:	009b      	lsls	r3, r3, #2
 8003786:	4413      	add	r3, r2
 8003788:	2200      	movs	r2, #0
 800378a:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 800378c:	9b01      	ldr	r3, [sp, #4]
 800378e:	3301      	adds	r3, #1
 8003790:	9301      	str	r3, [sp, #4]
 8003792:	9b01      	ldr	r3, [sp, #4]
 8003794:	2b00      	cmp	r3, #0
 8003796:	d0f3      	beq.n	8003780 <chSysInit+0x10>
  }

#if CH_CFG_USE_TM == TRUE
  /* Time Measurement calibration.*/
  __tm_calibration_object_init(&ch_system.tmc);
 8003798:	4809      	ldr	r0, [pc, #36]	; (80037c0 <chSysInit+0x50>)
 800379a:	f7ff ffa1 	bl	80036e0 <__tm_calibration_object_init>

  /* User system initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* OS library modules.*/
  __oslib_init();
 800379e:	f7ff ffd7 	bl	8003750 <__oslib_init>

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);
 80037a2:	4908      	ldr	r1, [pc, #32]	; (80037c4 <chSysInit+0x54>)
 80037a4:	4808      	ldr	r0, [pc, #32]	; (80037c8 <chSysInit+0x58>)
 80037a6:	f000 fdc3 	bl	8004330 <chInstanceObjectInit>

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 80037aa:	4b04      	ldr	r3, [pc, #16]	; (80037bc <chSysInit+0x4c>)
 80037ac:	2202      	movs	r2, #2
 80037ae:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 80037b0:	f7ff ffbe 	bl	8003730 <chSysUnlock.lto_priv.5>
}
 80037b4:	bf00      	nop
 80037b6:	b003      	add	sp, #12
 80037b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80037bc:	20000d80 	.word	0x20000d80
 80037c0:	20000d88 	.word	0x20000d88
 80037c4:	08006fe4 	.word	0x08006fe4
 80037c8:	20000d90 	.word	0x20000d90
 80037cc:	00000000 	.word	0x00000000

080037d0 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 80037d0:	b082      	sub	sp, #8
 80037d2:	9001      	str	r0, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
 80037d4:	b672      	cpsid	i
}
 80037d6:	bf00      	nop
 *          the priority mask to level 0.
 */
__STATIC_FORCEINLINE void port_disable(void) {

  __disable_irq();
}
 80037d8:	bf00      	nop

  /* Logging the event.*/
  __trace_halt(reason);

  /* Pointing to the passed message.*/
  currcore->dbg.panic_msg = reason;
 80037da:	4a04      	ldr	r2, [pc, #16]	; (80037ec <chSysHalt+0x1c>)
 80037dc:	9b01      	ldr	r3, [sp, #4]
 80037de:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
     via some inter-core messaging or other means.*/
  PORT_SYSTEM_HALT_HOOK();
#endif

  /* Entering the halted state.*/
  ch_system.state = ch_sys_halted;
 80037e2:	4b03      	ldr	r3, [pc, #12]	; (80037f0 <chSysHalt+0x20>)
 80037e4:	2203      	movs	r2, #3
 80037e6:	701a      	strb	r2, [r3, #0]

  /* Harmless infinite loop.*/
  while (true) {
 80037e8:	e7fe      	b.n	80037e8 <chSysHalt+0x18>
 80037ea:	bf00      	nop
 80037ec:	20000d90 	.word	0x20000d90
 80037f0:	20000d80 	.word	0x20000d80
	...

08003800 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8003800:	b508      	push	{r3, lr}
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
 8003802:	f000 fa4d 	bl	8003ca0 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 8003806:	bf00      	nop
 8003808:	bd08      	pop	{r3, pc}
 800380a:	bf00      	nop
 800380c:	0000      	movs	r0, r0
	...

08003810 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
 8003810:	b082      	sub	sp, #8
 8003812:	9001      	str	r0, [sp, #4]

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 8003814:	4b04      	ldr	r3, [pc, #16]	; (8003828 <chRFCUCollectFaultsI+0x18>)
 8003816:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003818:	9b01      	ldr	r3, [sp, #4]
 800381a:	4313      	orrs	r3, r2
 800381c:	4a02      	ldr	r2, [pc, #8]	; (8003828 <chRFCUCollectFaultsI+0x18>)
 800381e:	6353      	str	r3, [r2, #52]	; 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 8003820:	bf00      	nop
 8003822:	b002      	add	sp, #8
 8003824:	4770      	bx	lr
 8003826:	bf00      	nop
 8003828:	20000d90 	.word	0x20000d90
 800382c:	00000000 	.word	0x00000000

08003830 <chTimeAddX>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
 8003830:	b082      	sub	sp, #8
 8003832:	9001      	str	r0, [sp, #4]
 8003834:	9100      	str	r1, [sp, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8003836:	9a01      	ldr	r2, [sp, #4]
 8003838:	9b00      	ldr	r3, [sp, #0]
 800383a:	4413      	add	r3, r2
}
 800383c:	4618      	mov	r0, r3
 800383e:	b002      	add	sp, #8
 8003840:	4770      	bx	lr
 8003842:	bf00      	nop
	...

08003850 <chTimeDiffX.lto_priv.0>:
 * @param[in] end       second system time
 * @return              The interval representing the time difference.
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8003850:	b082      	sub	sp, #8
 8003852:	9001      	str	r0, [sp, #4]
 8003854:	9100      	str	r1, [sp, #0]

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8003856:	9a00      	ldr	r2, [sp, #0]
 8003858:	9b01      	ldr	r3, [sp, #4]
 800385a:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 800385c:	4618      	mov	r0, r3
 800385e:	b002      	add	sp, #8
 8003860:	4770      	bx	lr
 8003862:	bf00      	nop
	...

08003870 <ch_dlist_isempty>:
 * @param[in] dlhp      pointer to the delta list header
 * @return              The status of the delta list.
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {
 8003870:	b082      	sub	sp, #8
 8003872:	9001      	str	r0, [sp, #4]

  return (bool)(dlhp == dlhp->next);
 8003874:	9b01      	ldr	r3, [sp, #4]
 8003876:	681b      	ldr	r3, [r3, #0]
 8003878:	9a01      	ldr	r2, [sp, #4]
 800387a:	429a      	cmp	r2, r3
 800387c:	bf0c      	ite	eq
 800387e:	2301      	moveq	r3, #1
 8003880:	2300      	movne	r3, #0
 8003882:	b2db      	uxtb	r3, r3
}
 8003884:	4618      	mov	r0, r3
 8003886:	b002      	add	sp, #8
 8003888:	4770      	bx	lr
 800388a:	bf00      	nop
 800388c:	0000      	movs	r0, r0
	...

08003890 <ch_dlist_isfirst>:
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline bool ch_dlist_isfirst(ch_delta_list_t *dlhp,
                                    ch_delta_list_t *dlp) {
 8003890:	b082      	sub	sp, #8
 8003892:	9001      	str	r0, [sp, #4]
 8003894:	9100      	str	r1, [sp, #0]

  return (bool)(dlhp->next == dlp);
 8003896:	9b01      	ldr	r3, [sp, #4]
 8003898:	681b      	ldr	r3, [r3, #0]
 800389a:	9a00      	ldr	r2, [sp, #0]
 800389c:	429a      	cmp	r2, r3
 800389e:	bf0c      	ite	eq
 80038a0:	2301      	moveq	r3, #1
 80038a2:	2300      	movne	r3, #0
 80038a4:	b2db      	uxtb	r3, r3
}
 80038a6:	4618      	mov	r0, r3
 80038a8:	b002      	add	sp, #8
 80038aa:	4770      	bx	lr
 80038ac:	0000      	movs	r0, r0
	...

080038b0 <ch_dlist_insert_after>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {
 80038b0:	b084      	sub	sp, #16
 80038b2:	9003      	str	r0, [sp, #12]
 80038b4:	9102      	str	r1, [sp, #8]
 80038b6:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 80038b8:	9b02      	ldr	r3, [sp, #8]
 80038ba:	9a01      	ldr	r2, [sp, #4]
 80038bc:	609a      	str	r2, [r3, #8]
  dlp->prev       = dlhp;
 80038be:	9b02      	ldr	r3, [sp, #8]
 80038c0:	9a03      	ldr	r2, [sp, #12]
 80038c2:	605a      	str	r2, [r3, #4]
  dlp->next       = dlp->prev->next;
 80038c4:	9b02      	ldr	r3, [sp, #8]
 80038c6:	685b      	ldr	r3, [r3, #4]
 80038c8:	681a      	ldr	r2, [r3, #0]
 80038ca:	9b02      	ldr	r3, [sp, #8]
 80038cc:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp;
 80038ce:	9b02      	ldr	r3, [sp, #8]
 80038d0:	681b      	ldr	r3, [r3, #0]
 80038d2:	9a02      	ldr	r2, [sp, #8]
 80038d4:	605a      	str	r2, [r3, #4]
  dlhp->next      = dlp;
 80038d6:	9b03      	ldr	r3, [sp, #12]
 80038d8:	9a02      	ldr	r2, [sp, #8]
 80038da:	601a      	str	r2, [r3, #0]
}
 80038dc:	bf00      	nop
 80038de:	b004      	add	sp, #16
 80038e0:	4770      	bx	lr
 80038e2:	bf00      	nop
	...

080038f0 <ch_dlist_insert_before>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {
 80038f0:	b084      	sub	sp, #16
 80038f2:	9003      	str	r0, [sp, #12]
 80038f4:	9102      	str	r1, [sp, #8]
 80038f6:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 80038f8:	9b02      	ldr	r3, [sp, #8]
 80038fa:	9a01      	ldr	r2, [sp, #4]
 80038fc:	609a      	str	r2, [r3, #8]
  dlp->next       = dlhp;
 80038fe:	9b02      	ldr	r3, [sp, #8]
 8003900:	9a03      	ldr	r2, [sp, #12]
 8003902:	601a      	str	r2, [r3, #0]
  dlp->prev       = dlp->next->prev;
 8003904:	9b02      	ldr	r3, [sp, #8]
 8003906:	681b      	ldr	r3, [r3, #0]
 8003908:	685a      	ldr	r2, [r3, #4]
 800390a:	9b02      	ldr	r3, [sp, #8]
 800390c:	605a      	str	r2, [r3, #4]
  dlp->prev->next = dlp;
 800390e:	9b02      	ldr	r3, [sp, #8]
 8003910:	685b      	ldr	r3, [r3, #4]
 8003912:	9a02      	ldr	r2, [sp, #8]
 8003914:	601a      	str	r2, [r3, #0]
  dlhp->prev      = dlp;
 8003916:	9b03      	ldr	r3, [sp, #12]
 8003918:	9a02      	ldr	r2, [sp, #8]
 800391a:	605a      	str	r2, [r3, #4]
}
 800391c:	bf00      	nop
 800391e:	b004      	add	sp, #16
 8003920:	4770      	bx	lr
 8003922:	bf00      	nop
	...

08003930 <ch_dlist_insert>:
 *
 * @notapi
 */
static inline void ch_dlist_insert(ch_delta_list_t *dlhp,
                                   ch_delta_list_t *dlep,
                                   sysinterval_t delta) {
 8003930:	b500      	push	{lr}
 8003932:	b087      	sub	sp, #28
 8003934:	9003      	str	r0, [sp, #12]
 8003936:	9102      	str	r1, [sp, #8]
 8003938:	9201      	str	r2, [sp, #4]
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
 800393a:	9b03      	ldr	r3, [sp, #12]
 800393c:	681b      	ldr	r3, [r3, #0]
 800393e:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8003940:	e007      	b.n	8003952 <ch_dlist_insert+0x22>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
 8003942:	9b05      	ldr	r3, [sp, #20]
 8003944:	689b      	ldr	r3, [r3, #8]
 8003946:	9a01      	ldr	r2, [sp, #4]
 8003948:	1ad3      	subs	r3, r2, r3
 800394a:	9301      	str	r3, [sp, #4]
    dlp = dlp->next;
 800394c:	9b05      	ldr	r3, [sp, #20]
 800394e:	681b      	ldr	r3, [r3, #0]
 8003950:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8003952:	9b05      	ldr	r3, [sp, #20]
 8003954:	689b      	ldr	r3, [r3, #8]
 8003956:	9a01      	ldr	r2, [sp, #4]
 8003958:	429a      	cmp	r2, r3
 800395a:	bf8c      	ite	hi
 800395c:	2301      	movhi	r3, #1
 800395e:	2300      	movls	r3, #0
 8003960:	b2db      	uxtb	r3, r3
 8003962:	2b00      	cmp	r3, #0
 8003964:	d1ed      	bne.n	8003942 <ch_dlist_insert+0x12>
  }

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);
 8003966:	9a01      	ldr	r2, [sp, #4]
 8003968:	9902      	ldr	r1, [sp, #8]
 800396a:	9805      	ldr	r0, [sp, #20]
 800396c:	f7ff ffc0 	bl	80038f0 <ch_dlist_insert_before>

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 8003970:	9b05      	ldr	r3, [sp, #20]
 8003972:	689a      	ldr	r2, [r3, #8]
 8003974:	9b01      	ldr	r3, [sp, #4]
 8003976:	1ad2      	subs	r2, r2, r3
 8003978:	9b05      	ldr	r3, [sp, #20]
 800397a:	609a      	str	r2, [r3, #8]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 800397c:	9b03      	ldr	r3, [sp, #12]
 800397e:	f04f 32ff 	mov.w	r2, #4294967295
 8003982:	609a      	str	r2, [r3, #8]
}
 8003984:	bf00      	nop
 8003986:	b007      	add	sp, #28
 8003988:	f85d fb04 	ldr.w	pc, [sp], #4
 800398c:	0000      	movs	r0, r0
	...

08003990 <ch_dlist_remove_first>:
 *
 * @param[in] dlhp      pointer to the delta list header
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_remove_first(ch_delta_list_t *dlhp) {
 8003990:	b084      	sub	sp, #16
 8003992:	9001      	str	r0, [sp, #4]
  ch_delta_list_t *dlp = dlhp->next;
 8003994:	9b01      	ldr	r3, [sp, #4]
 8003996:	681b      	ldr	r3, [r3, #0]
 8003998:	9303      	str	r3, [sp, #12]

  dlhp->next       = dlp->next;
 800399a:	9b03      	ldr	r3, [sp, #12]
 800399c:	681a      	ldr	r2, [r3, #0]
 800399e:	9b01      	ldr	r3, [sp, #4]
 80039a0:	601a      	str	r2, [r3, #0]
  dlhp->next->prev = dlhp;
 80039a2:	9b01      	ldr	r3, [sp, #4]
 80039a4:	681b      	ldr	r3, [r3, #0]
 80039a6:	9a01      	ldr	r2, [sp, #4]
 80039a8:	605a      	str	r2, [r3, #4]

  return dlp;
 80039aa:	9b03      	ldr	r3, [sp, #12]
}
 80039ac:	4618      	mov	r0, r3
 80039ae:	b004      	add	sp, #16
 80039b0:	4770      	bx	lr
 80039b2:	bf00      	nop
	...

080039c0 <ch_dlist_dequeue>:
 *
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {
 80039c0:	b082      	sub	sp, #8
 80039c2:	9001      	str	r0, [sp, #4]

  dlp->prev->next = dlp->next;
 80039c4:	9b01      	ldr	r3, [sp, #4]
 80039c6:	685b      	ldr	r3, [r3, #4]
 80039c8:	9a01      	ldr	r2, [sp, #4]
 80039ca:	6812      	ldr	r2, [r2, #0]
 80039cc:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp->prev;
 80039ce:	9b01      	ldr	r3, [sp, #4]
 80039d0:	681b      	ldr	r3, [r3, #0]
 80039d2:	9a01      	ldr	r2, [sp, #4]
 80039d4:	6852      	ldr	r2, [r2, #4]
 80039d6:	605a      	str	r2, [r3, #4]

  return dlp;
 80039d8:	9b01      	ldr	r3, [sp, #4]
}
 80039da:	4618      	mov	r0, r3
 80039dc:	b002      	add	sp, #8
 80039de:	4770      	bx	lr

080039e0 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 80039e0:	b500      	push	{lr}
 80039e2:	b083      	sub	sp, #12
 80039e4:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
 80039e6:	9801      	ldr	r0, [sp, #4]
 80039e8:	f7fd fbea 	bl	80011c0 <stStartAlarm>
}
 80039ec:	bf00      	nop
 80039ee:	b003      	add	sp, #12
 80039f0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003a00 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8003a00:	b508      	push	{r3, lr}

  stStopAlarm();
 8003a02:	f7fd fbed 	bl	80011e0 <stStopAlarm>
}
 8003a06:	bf00      	nop
 8003a08:	bd08      	pop	{r3, pc}
 8003a0a:	bf00      	nop
 8003a0c:	0000      	movs	r0, r0
	...

08003a10 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8003a10:	b500      	push	{lr}
 8003a12:	b083      	sub	sp, #12
 8003a14:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8003a16:	9801      	ldr	r0, [sp, #4]
 8003a18:	f7fd fbea 	bl	80011f0 <stSetAlarm>
}
 8003a1c:	bf00      	nop
 8003a1e:	b003      	add	sp, #12
 8003a20:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003a30 <port_timer_get_time.lto_priv.0>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8003a30:	b508      	push	{r3, lr}

  return stGetCounter();
 8003a32:	f7fd fbbd 	bl	80011b0 <stGetCounter>
 8003a36:	4603      	mov	r3, r0
}
 8003a38:	4618      	mov	r0, r3
 8003a3a:	bd08      	pop	{r3, pc}
 8003a3c:	0000      	movs	r0, r0
	...

08003a40 <chSysLockFromISR.lto_priv.3>:
static inline void chSysLockFromISR(void) {
 8003a40:	b082      	sub	sp, #8
 8003a42:	2320      	movs	r3, #32
 8003a44:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003a46:	9b01      	ldr	r3, [sp, #4]
 8003a48:	f383 8811 	msr	BASEPRI, r3
}
 8003a4c:	bf00      	nop
}
 8003a4e:	bf00      	nop
}
 8003a50:	bf00      	nop
}
 8003a52:	bf00      	nop
 8003a54:	b002      	add	sp, #8
 8003a56:	4770      	bx	lr
	...

08003a60 <chSysUnlockFromISR.lto_priv.3>:
static inline void chSysUnlockFromISR(void) {
 8003a60:	b082      	sub	sp, #8
 8003a62:	2300      	movs	r3, #0
 8003a64:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003a66:	9b01      	ldr	r3, [sp, #4]
 8003a68:	f383 8811 	msr	BASEPRI, r3
}
 8003a6c:	bf00      	nop
}
 8003a6e:	bf00      	nop
}
 8003a70:	bf00      	nop
}
 8003a72:	bf00      	nop
 8003a74:	b002      	add	sp, #8
 8003a76:	4770      	bx	lr
	...

08003a80 <chVTGetSystemTimeX.lto_priv.0>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8003a80:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8003a82:	f7ff ffd5 	bl	8003a30 <port_timer_get_time.lto_priv.0>
 8003a86:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003a88:	4618      	mov	r0, r3
 8003a8a:	bd08      	pop	{r3, pc}
 8003a8c:	0000      	movs	r0, r0
	...

08003a90 <vt_insert_first>:
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
                            virtual_timer_t *vtp,
                            systime_t now,
                            sysinterval_t delay) {
 8003a90:	b500      	push	{lr}
 8003a92:	b085      	sub	sp, #20
 8003a94:	9003      	str	r0, [sp, #12]
 8003a96:	9102      	str	r1, [sp, #8]
 8003a98:	9201      	str	r2, [sp, #4]
 8003a9a:	9300      	str	r3, [sp, #0]

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 8003a9c:	9b03      	ldr	r3, [sp, #12]
 8003a9e:	9a01      	ldr	r2, [sp, #4]
 8003aa0:	60da      	str	r2, [r3, #12]
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);
 8003aa2:	9b03      	ldr	r3, [sp, #12]
 8003aa4:	9902      	ldr	r1, [sp, #8]
 8003aa6:	9a00      	ldr	r2, [sp, #0]
 8003aa8:	4618      	mov	r0, r3
 8003aaa:	f7ff ff01 	bl	80038b0 <ch_dlist_insert_after>

  /* If the requested delay is lower than the minimum safe delta then it
     is raised to the minimum safe value.*/
  if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8003aae:	9b00      	ldr	r3, [sp, #0]
 8003ab0:	2b01      	cmp	r3, #1
 8003ab2:	d801      	bhi.n	8003ab8 <vt_insert_first+0x28>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8003ab4:	2302      	movs	r3, #2
 8003ab6:	9300      	str	r3, [sp, #0]
  }
#endif

  /* Being the first element inserted in the list the alarm timer
     is started.*/
  port_timer_start_alarm(chTimeAddX(vtlp->lasttime, delay));
 8003ab8:	9b03      	ldr	r3, [sp, #12]
 8003aba:	68db      	ldr	r3, [r3, #12]
 8003abc:	9900      	ldr	r1, [sp, #0]
 8003abe:	4618      	mov	r0, r3
 8003ac0:	f7ff feb6 	bl	8003830 <chTimeAddX>
 8003ac4:	4603      	mov	r3, r0
 8003ac6:	4618      	mov	r0, r3
 8003ac8:	f7ff ff8a 	bl	80039e0 <port_timer_start_alarm>
}
 8003acc:	bf00      	nop
 8003ace:	b005      	add	sp, #20
 8003ad0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003ae0 <vt_enqueue>:
 * @brief   Enqueues a virtual timer in a virtual timers list.
 */
static void vt_enqueue(virtual_timers_list_t *vtlp,
                       virtual_timer_t *vtp,
                       systime_t now,
                       sysinterval_t delay) {
 8003ae0:	b500      	push	{lr}
 8003ae2:	b089      	sub	sp, #36	; 0x24
 8003ae4:	9003      	str	r0, [sp, #12]
 8003ae6:	9102      	str	r1, [sp, #8]
 8003ae8:	9201      	str	r2, [sp, #4]
 8003aea:	9300      	str	r3, [sp, #0]
#if CH_CFG_ST_TIMEDELTA > 0
  {
    sysinterval_t nowdelta;

    /* Special case where the timers list is empty.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8003aec:	9b03      	ldr	r3, [sp, #12]
 8003aee:	4618      	mov	r0, r3
 8003af0:	f7ff febe 	bl	8003870 <ch_dlist_isempty>
 8003af4:	4603      	mov	r3, r0
 8003af6:	2b00      	cmp	r3, #0
 8003af8:	d006      	beq.n	8003b08 <vt_enqueue+0x28>

      vt_insert_first(vtlp, vtp, now, delay);
 8003afa:	9b00      	ldr	r3, [sp, #0]
 8003afc:	9a01      	ldr	r2, [sp, #4]
 8003afe:	9902      	ldr	r1, [sp, #8]
 8003b00:	9803      	ldr	r0, [sp, #12]
 8003b02:	f7ff ffc5 	bl	8003a90 <vt_insert_first>

      return;
 8003b06:	e02d      	b.n	8003b64 <vt_enqueue+0x84>
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8003b08:	9b03      	ldr	r3, [sp, #12]
 8003b0a:	68db      	ldr	r3, [r3, #12]
 8003b0c:	9901      	ldr	r1, [sp, #4]
 8003b0e:	4618      	mov	r0, r3
 8003b10:	f7ff fe9e 	bl	8003850 <chTimeDiffX.lto_priv.0>
 8003b14:	9005      	str	r0, [sp, #20]
    delta    = nowdelta + delay;
 8003b16:	9a05      	ldr	r2, [sp, #20]
 8003b18:	9b00      	ldr	r3, [sp, #0]
 8003b1a:	4413      	add	r3, r2
 8003b1c:	9307      	str	r3, [sp, #28]

    /* Scenario where a very large delay exceeded the numeric range, the
       delta is shortened to make it fit the numeric range, the timer
       will be triggered "deltanow" cycles earlier.*/
    if (delta < nowdelta) {
 8003b1e:	9a07      	ldr	r2, [sp, #28]
 8003b20:	9b05      	ldr	r3, [sp, #20]
 8003b22:	429a      	cmp	r2, r3
 8003b24:	d201      	bcs.n	8003b2a <vt_enqueue+0x4a>
      delta = delay;
 8003b26:	9b00      	ldr	r3, [sp, #0]
 8003b28:	9307      	str	r3, [sp, #28]
    }

    /* Checking if this timer would become the first in the delta list, this
       requires changing the current alarm setting.*/
    if (delta < vtlp->dlist.next->delta) {
 8003b2a:	9b03      	ldr	r3, [sp, #12]
 8003b2c:	681b      	ldr	r3, [r3, #0]
 8003b2e:	689b      	ldr	r3, [r3, #8]
 8003b30:	9a07      	ldr	r2, [sp, #28]
 8003b32:	429a      	cmp	r2, r3
 8003b34:	d210      	bcs.n	8003b58 <vt_enqueue+0x78>
      sysinterval_t deadline_delta;

      /* A small delay that will become the first element in the delta list
         and next deadline.*/
      deadline_delta = delta;
 8003b36:	9b07      	ldr	r3, [sp, #28]
 8003b38:	9306      	str	r3, [sp, #24]

      /* Limit delta to CH_CFG_ST_TIMEDELTA.*/
      if (deadline_delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8003b3a:	9b06      	ldr	r3, [sp, #24]
 8003b3c:	2b01      	cmp	r3, #1
 8003b3e:	d801      	bhi.n	8003b44 <vt_enqueue+0x64>
        deadline_delta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8003b40:	2302      	movs	r3, #2
 8003b42:	9306      	str	r3, [sp, #24]
         this can happen when: sizeof (systime_t) < sizeof (sysinterval_t).*/
      else if (deadline_delta > (sysinterval_t)TIME_MAX_SYSTIME) {
        deadline_delta = (sysinterval_t)TIME_MAX_SYSTIME;
      }
#endif
      port_timer_set_alarm(chTimeAddX(vtlp->lasttime, deadline_delta));
 8003b44:	9b03      	ldr	r3, [sp, #12]
 8003b46:	68db      	ldr	r3, [r3, #12]
 8003b48:	9906      	ldr	r1, [sp, #24]
 8003b4a:	4618      	mov	r0, r3
 8003b4c:	f7ff fe70 	bl	8003830 <chTimeAddX>
 8003b50:	4603      	mov	r3, r0
 8003b52:	4618      	mov	r0, r3
 8003b54:	f7ff ff5c 	bl	8003a10 <port_timer_set_alarm>

  /* Delta is initially equal to the specified delay.*/
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8003b58:	9b03      	ldr	r3, [sp, #12]
 8003b5a:	9902      	ldr	r1, [sp, #8]
 8003b5c:	9a07      	ldr	r2, [sp, #28]
 8003b5e:	4618      	mov	r0, r3
 8003b60:	f7ff fee6 	bl	8003930 <ch_dlist_insert>
}
 8003b64:	b009      	add	sp, #36	; 0x24
 8003b66:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b6a:	bf00      	nop
 8003b6c:	0000      	movs	r0, r0
	...

08003b70 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 8003b70:	b500      	push	{lr}
 8003b72:	b087      	sub	sp, #28
 8003b74:	9003      	str	r0, [sp, #12]
 8003b76:	9102      	str	r1, [sp, #8]
 8003b78:	9201      	str	r2, [sp, #4]
 8003b7a:	9300      	str	r3, [sp, #0]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8003b7c:	4b0b      	ldr	r3, [pc, #44]	; (8003bac <chVTDoSetI+0x3c>)
 8003b7e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  /* Timer initialization.*/
  vtp->par     = par;
 8003b80:	9b03      	ldr	r3, [sp, #12]
 8003b82:	9a00      	ldr	r2, [sp, #0]
 8003b84:	611a      	str	r2, [r3, #16]
  vtp->func    = vtfunc;
 8003b86:	9b03      	ldr	r3, [sp, #12]
 8003b88:	9a01      	ldr	r2, [sp, #4]
 8003b8a:	60da      	str	r2, [r3, #12]
  vtp->reload  = (sysinterval_t)0;
 8003b8c:	9b03      	ldr	r3, [sp, #12]
 8003b8e:	2200      	movs	r2, #0
 8003b90:	615a      	str	r2, [r3, #20]

  /* Inserting the timer in the delta list.*/
  vt_enqueue(vtlp, vtp, chVTGetSystemTimeX(), delay);
 8003b92:	f7ff ff75 	bl	8003a80 <chVTGetSystemTimeX.lto_priv.0>
 8003b96:	4602      	mov	r2, r0
 8003b98:	9b02      	ldr	r3, [sp, #8]
 8003b9a:	9903      	ldr	r1, [sp, #12]
 8003b9c:	9805      	ldr	r0, [sp, #20]
 8003b9e:	f7ff ff9f 	bl	8003ae0 <vt_enqueue>
}
 8003ba2:	bf00      	nop
 8003ba4:	b007      	add	sp, #28
 8003ba6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003baa:	bf00      	nop
 8003bac:	20000da0 	.word	0x20000da0

08003bb0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8003bb0:	b510      	push	{r4, lr}
 8003bb2:	b086      	sub	sp, #24
 8003bb4:	9001      	str	r0, [sp, #4]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8003bb6:	4b36      	ldr	r3, [pc, #216]	; (8003c90 <chVTDoResetI+0xe0>)
 8003bb8:	9304      	str	r3, [sp, #16]
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 8003bba:	9b04      	ldr	r3, [sp, #16]
 8003bbc:	9a01      	ldr	r2, [sp, #4]
 8003bbe:	4611      	mov	r1, r2
 8003bc0:	4618      	mov	r0, r3
 8003bc2:	f7ff fe65 	bl	8003890 <ch_dlist_isfirst>
 8003bc6:	4603      	mov	r3, r0
 8003bc8:	f083 0301 	eor.w	r3, r3, #1
 8003bcc:	b2db      	uxtb	r3, r3
 8003bce:	2b00      	cmp	r3, #0
 8003bd0:	d014      	beq.n	8003bfc <chVTDoResetI+0x4c>

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8003bd2:	9b01      	ldr	r3, [sp, #4]
 8003bd4:	4618      	mov	r0, r3
 8003bd6:	f7ff fef3 	bl	80039c0 <ch_dlist_dequeue>

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 8003bda:	9b01      	ldr	r3, [sp, #4]
 8003bdc:	681b      	ldr	r3, [r3, #0]
 8003bde:	6899      	ldr	r1, [r3, #8]
 8003be0:	9b01      	ldr	r3, [sp, #4]
 8003be2:	689a      	ldr	r2, [r3, #8]
 8003be4:	9b01      	ldr	r3, [sp, #4]
 8003be6:	681b      	ldr	r3, [r3, #0]
 8003be8:	440a      	add	r2, r1
 8003bea:	609a      	str	r2, [r3, #8]

    /* Marking timer as not armed.*/
    vtp->dlist.next = NULL;
 8003bec:	9b01      	ldr	r3, [sp, #4]
 8003bee:	2200      	movs	r2, #0
 8003bf0:	601a      	str	r2, [r3, #0]

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 8003bf2:	9b04      	ldr	r3, [sp, #16]
 8003bf4:	f04f 32ff 	mov.w	r2, #4294967295
 8003bf8:	609a      	str	r2, [r3, #8]

    return;
 8003bfa:	e046      	b.n	8003c8a <chVTDoResetI+0xda>
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
 8003bfc:	9b04      	ldr	r3, [sp, #16]
 8003bfe:	4618      	mov	r0, r3
 8003c00:	f7ff fec6 	bl	8003990 <ch_dlist_remove_first>
  vtp->dlist.next = NULL;
 8003c04:	9b01      	ldr	r3, [sp, #4]
 8003c06:	2200      	movs	r2, #0
 8003c08:	601a      	str	r2, [r3, #0]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8003c0a:	9b04      	ldr	r3, [sp, #16]
 8003c0c:	4618      	mov	r0, r3
 8003c0e:	f7ff fe2f 	bl	8003870 <ch_dlist_isempty>
 8003c12:	4603      	mov	r3, r0
 8003c14:	2b00      	cmp	r3, #0
 8003c16:	d002      	beq.n	8003c1e <chVTDoResetI+0x6e>
    port_timer_stop_alarm();
 8003c18:	f7ff fef2 	bl	8003a00 <port_timer_stop_alarm>

    return;
 8003c1c:	e035      	b.n	8003c8a <chVTDoResetI+0xda>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 8003c1e:	9b04      	ldr	r3, [sp, #16]
 8003c20:	681b      	ldr	r3, [r3, #0]
 8003c22:	6899      	ldr	r1, [r3, #8]
 8003c24:	9b01      	ldr	r3, [sp, #4]
 8003c26:	689a      	ldr	r2, [r3, #8]
 8003c28:	9b04      	ldr	r3, [sp, #16]
 8003c2a:	681b      	ldr	r3, [r3, #0]
 8003c2c:	440a      	add	r2, r1
 8003c2e:	609a      	str	r2, [r3, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(vtlp->lasttime, chVTGetSystemTimeX());
 8003c30:	9b04      	ldr	r3, [sp, #16]
 8003c32:	68dc      	ldr	r4, [r3, #12]
 8003c34:	f7ff ff24 	bl	8003a80 <chVTGetSystemTimeX.lto_priv.0>
 8003c38:	4603      	mov	r3, r0
 8003c3a:	4619      	mov	r1, r3
 8003c3c:	4620      	mov	r0, r4
 8003c3e:	f7ff fe07 	bl	8003850 <chTimeDiffX.lto_priv.0>
 8003c42:	9003      	str	r0, [sp, #12]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 8003c44:	9b04      	ldr	r3, [sp, #16]
 8003c46:	681b      	ldr	r3, [r3, #0]
 8003c48:	689b      	ldr	r3, [r3, #8]
 8003c4a:	9a03      	ldr	r2, [sp, #12]
 8003c4c:	429a      	cmp	r2, r3
 8003c4e:	d21b      	bcs.n	8003c88 <chVTDoResetI+0xd8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 8003c50:	9b04      	ldr	r3, [sp, #16]
 8003c52:	681b      	ldr	r3, [r3, #0]
 8003c54:	689a      	ldr	r2, [r3, #8]
 8003c56:	9b03      	ldr	r3, [sp, #12]
 8003c58:	1ad3      	subs	r3, r2, r3
 8003c5a:	9305      	str	r3, [sp, #20]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8003c5c:	9b05      	ldr	r3, [sp, #20]
 8003c5e:	2b01      	cmp	r3, #1
 8003c60:	d803      	bhi.n	8003c6a <chVTDoResetI+0xba>
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8003c62:	9b03      	ldr	r3, [sp, #12]
 8003c64:	3302      	adds	r3, #2
 8003c66:	9305      	str	r3, [sp, #20]
 8003c68:	e003      	b.n	8003c72 <chVTDoResetI+0xc2>
  }
  else {
    delta = nowdelta + delta;
 8003c6a:	9a05      	ldr	r2, [sp, #20]
 8003c6c:	9b03      	ldr	r3, [sp, #12]
 8003c6e:	4413      	add	r3, r2
 8003c70:	9305      	str	r3, [sp, #20]
    if (delta > (sysinterval_t)TIME_MAX_SYSTIME) {
      delta = (sysinterval_t)TIME_MAX_SYSTIME;
    }
#endif
  }
  port_timer_set_alarm(chTimeAddX(vtlp->lasttime, delta));
 8003c72:	9b04      	ldr	r3, [sp, #16]
 8003c74:	68db      	ldr	r3, [r3, #12]
 8003c76:	9905      	ldr	r1, [sp, #20]
 8003c78:	4618      	mov	r0, r3
 8003c7a:	f7ff fdd9 	bl	8003830 <chTimeAddX>
 8003c7e:	4603      	mov	r3, r0
 8003c80:	4618      	mov	r0, r3
 8003c82:	f7ff fec5 	bl	8003a10 <port_timer_set_alarm>
 8003c86:	e000      	b.n	8003c8a <chVTDoResetI+0xda>
    return;
 8003c88:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003c8a:	b006      	add	sp, #24
 8003c8c:	bd10      	pop	{r4, pc}
 8003c8e:	bf00      	nop
 8003c90:	20000da0 	.word	0x20000da0
	...

08003ca0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 8003ca0:	b510      	push	{r4, lr}
 8003ca2:	b088      	sub	sp, #32
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8003ca4:	4b57      	ldr	r3, [pc, #348]	; (8003e04 <chVTDoTickI+0x164>)
 8003ca6:	9305      	str	r3, [sp, #20]
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 8003ca8:	9b05      	ldr	r3, [sp, #20]
 8003caa:	681b      	ldr	r3, [r3, #0]
 8003cac:	9304      	str	r3, [sp, #16]

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
 8003cae:	f7ff fee7 	bl	8003a80 <chVTGetSystemTimeX.lto_priv.0>
 8003cb2:	9003      	str	r0, [sp, #12]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8003cb4:	9b05      	ldr	r3, [sp, #20]
 8003cb6:	68db      	ldr	r3, [r3, #12]
 8003cb8:	9903      	ldr	r1, [sp, #12]
 8003cba:	4618      	mov	r0, r3
 8003cbc:	f7ff fdc8 	bl	8003850 <chTimeDiffX.lto_priv.0>
 8003cc0:	9002      	str	r0, [sp, #8]

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
 8003cc2:	9b04      	ldr	r3, [sp, #16]
 8003cc4:	689b      	ldr	r3, [r3, #8]
 8003cc6:	9a02      	ldr	r2, [sp, #8]
 8003cc8:	429a      	cmp	r2, r3
 8003cca:	d366      	bcc.n	8003d9a <chVTDoTickI+0xfa>
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
 8003ccc:	9b05      	ldr	r3, [sp, #20]
 8003cce:	68da      	ldr	r2, [r3, #12]
 8003cd0:	9b04      	ldr	r3, [sp, #16]
 8003cd2:	689b      	ldr	r3, [r3, #8]
 8003cd4:	4619      	mov	r1, r3
 8003cd6:	4610      	mov	r0, r2
 8003cd8:	f7ff fdaa 	bl	8003830 <chTimeAddX>
 8003cdc:	9001      	str	r0, [sp, #4]
    vtlp->lasttime = lasttime;
 8003cde:	9b05      	ldr	r3, [sp, #20]
 8003ce0:	9a01      	ldr	r2, [sp, #4]
 8003ce2:	60da      	str	r2, [r3, #12]

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8003ce4:	9b04      	ldr	r3, [sp, #16]
 8003ce6:	4618      	mov	r0, r3
 8003ce8:	f7ff fe6a 	bl	80039c0 <ch_dlist_dequeue>
    vtp->dlist.next = NULL;
 8003cec:	9b04      	ldr	r3, [sp, #16]
 8003cee:	2200      	movs	r2, #0
 8003cf0:	601a      	str	r2, [r3, #0]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8003cf2:	9b05      	ldr	r3, [sp, #20]
 8003cf4:	4618      	mov	r0, r3
 8003cf6:	f7ff fdbb 	bl	8003870 <ch_dlist_isempty>
 8003cfa:	4603      	mov	r3, r0
 8003cfc:	2b00      	cmp	r3, #0
 8003cfe:	d001      	beq.n	8003d04 <chVTDoTickI+0x64>
      port_timer_stop_alarm();
 8003d00:	f7ff fe7e 	bl	8003a00 <port_timer_stop_alarm>
    }

    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();
 8003d04:	f7ff feac 	bl	8003a60 <chSysUnlockFromISR.lto_priv.3>
    vtp->func(vtp, vtp->par);
 8003d08:	9b04      	ldr	r3, [sp, #16]
 8003d0a:	68db      	ldr	r3, [r3, #12]
 8003d0c:	9a04      	ldr	r2, [sp, #16]
 8003d0e:	6912      	ldr	r2, [r2, #16]
 8003d10:	4611      	mov	r1, r2
 8003d12:	9804      	ldr	r0, [sp, #16]
 8003d14:	4798      	blx	r3
    chSysLockFromISR();
 8003d16:	f7ff fe93 	bl	8003a40 <chSysLockFromISR.lto_priv.3>

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 8003d1a:	9b04      	ldr	r3, [sp, #16]
 8003d1c:	695b      	ldr	r3, [r3, #20]
 8003d1e:	2b00      	cmp	r3, #0
 8003d20:	bf14      	ite	ne
 8003d22:	2301      	movne	r3, #1
 8003d24:	2300      	moveq	r3, #0
 8003d26:	b2db      	uxtb	r3, r3
 8003d28:	2b00      	cmp	r3, #0
 8003d2a:	d0bd      	beq.n	8003ca8 <chVTDoTickI+0x8>
      sysinterval_t delay;

      /* Refreshing the current time after spending time in the callback for
         a more accurate detection of too fast reloads.*/
      now = chVTGetSystemTimeX();
 8003d2c:	f7ff fea8 	bl	8003a80 <chVTGetSystemTimeX.lto_priv.0>
 8003d30:	9003      	str	r0, [sp, #12]
      nowdelta = chTimeDiffX(lasttime, now);
 8003d32:	9903      	ldr	r1, [sp, #12]
 8003d34:	9801      	ldr	r0, [sp, #4]
 8003d36:	f7ff fd8b 	bl	8003850 <chTimeDiffX.lto_priv.0>
 8003d3a:	9002      	str	r0, [sp, #8]

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8003d3c:	9b04      	ldr	r3, [sp, #16]
 8003d3e:	695b      	ldr	r3, [r3, #20]
 8003d40:	9a02      	ldr	r2, [sp, #8]
 8003d42:	429a      	cmp	r2, r3
 8003d44:	d905      	bls.n	8003d52 <chVTDoTickI+0xb2>
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
 8003d46:	2002      	movs	r0, #2
 8003d48:	f7ff fd62 	bl	8003810 <chRFCUCollectFaultsI>

        delay = (sysinterval_t)0;
 8003d4c:	2300      	movs	r3, #0
 8003d4e:	9306      	str	r3, [sp, #24]
 8003d50:	e004      	b.n	8003d5c <chVTDoTickI+0xbc>
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
 8003d52:	9b04      	ldr	r3, [sp, #16]
 8003d54:	695a      	ldr	r2, [r3, #20]
 8003d56:	9b02      	ldr	r3, [sp, #8]
 8003d58:	1ad3      	subs	r3, r2, r3
 8003d5a:	9306      	str	r3, [sp, #24]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8003d5c:	9b05      	ldr	r3, [sp, #20]
 8003d5e:	4618      	mov	r0, r3
 8003d60:	f7ff fd86 	bl	8003870 <ch_dlist_isempty>
 8003d64:	4603      	mov	r3, r0
 8003d66:	2b00      	cmp	r3, #0
 8003d68:	d006      	beq.n	8003d78 <chVTDoTickI+0xd8>

        vt_insert_first(vtlp, vtp, now, delay);
 8003d6a:	9b06      	ldr	r3, [sp, #24]
 8003d6c:	9a03      	ldr	r2, [sp, #12]
 8003d6e:	9904      	ldr	r1, [sp, #16]
 8003d70:	9805      	ldr	r0, [sp, #20]
 8003d72:	f7ff fe8d 	bl	8003a90 <vt_insert_first>

        return;
 8003d76:	e042      	b.n	8003dfe <chVTDoTickI+0x15e>

      /* Delay as delta from 'lasttime'. Note, it can overflow and the value
         becomes lower than 'nowdelta'. In that case the delta is shortened
         to make it fit the numeric range and the timer will be triggered
         "nowdelta" cycles earlier.*/
      delta = nowdelta + delay;
 8003d78:	9a02      	ldr	r2, [sp, #8]
 8003d7a:	9b06      	ldr	r3, [sp, #24]
 8003d7c:	4413      	add	r3, r2
 8003d7e:	9307      	str	r3, [sp, #28]
      if (delta < nowdelta) {
 8003d80:	9a07      	ldr	r2, [sp, #28]
 8003d82:	9b02      	ldr	r3, [sp, #8]
 8003d84:	429a      	cmp	r2, r3
 8003d86:	d201      	bcs.n	8003d8c <chVTDoTickI+0xec>
        delta = delay;
 8003d88:	9b06      	ldr	r3, [sp, #24]
 8003d8a:	9307      	str	r3, [sp, #28]
      }

      /* Insert into delta list. */
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8003d8c:	9b05      	ldr	r3, [sp, #20]
 8003d8e:	9904      	ldr	r1, [sp, #16]
 8003d90:	9a07      	ldr	r2, [sp, #28]
 8003d92:	4618      	mov	r0, r3
 8003d94:	f7ff fdcc 	bl	8003930 <ch_dlist_insert>
  while (true) {
 8003d98:	e786      	b.n	8003ca8 <chVTDoTickI+0x8>
      break;
 8003d9a:	bf00      	nop
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8003d9c:	9b05      	ldr	r3, [sp, #20]
 8003d9e:	4618      	mov	r0, r3
 8003da0:	f7ff fd66 	bl	8003870 <ch_dlist_isempty>
 8003da4:	4603      	mov	r3, r0
 8003da6:	2b00      	cmp	r3, #0
 8003da8:	d128      	bne.n	8003dfc <chVTDoTickI+0x15c>
    return;
  }

  /* Calculating the delta to the next alarm time.*/
  delta = vtp->dlist.delta - nowdelta;
 8003daa:	9b04      	ldr	r3, [sp, #16]
 8003dac:	689a      	ldr	r2, [r3, #8]
 8003dae:	9b02      	ldr	r3, [sp, #8]
 8003db0:	1ad3      	subs	r3, r2, r3
 8003db2:	9307      	str	r3, [sp, #28]

  /* Limit delta to CH_CFG_ST_TIMEDELTA.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8003db4:	9b07      	ldr	r3, [sp, #28]
 8003db6:	2b01      	cmp	r3, #1
 8003db8:	d801      	bhi.n	8003dbe <chVTDoTickI+0x11e>
    delta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8003dba:	2302      	movs	r3, #2
 8003dbc:	9307      	str	r3, [sp, #28]
  }
#endif

  /* Update alarm time to next timer.*/
  {
    sysinterval_t next_alarm = chTimeAddX(now, delta);
 8003dbe:	9907      	ldr	r1, [sp, #28]
 8003dc0:	9803      	ldr	r0, [sp, #12]
 8003dc2:	f7ff fd35 	bl	8003830 <chTimeAddX>
 8003dc6:	9000      	str	r0, [sp, #0]

    port_timer_set_alarm(next_alarm);
 8003dc8:	9800      	ldr	r0, [sp, #0]
 8003dca:	f7ff fe21 	bl	8003a10 <port_timer_set_alarm>

#if !defined(CH_VT_RFCU_DISABLED)
    if (chTimeDiffX(vtlp->lasttime, chVTGetSystemTimeX()) >
 8003dce:	9b05      	ldr	r3, [sp, #20]
 8003dd0:	68dc      	ldr	r4, [r3, #12]
 8003dd2:	f7ff fe55 	bl	8003a80 <chVTGetSystemTimeX.lto_priv.0>
 8003dd6:	4603      	mov	r3, r0
 8003dd8:	4619      	mov	r1, r3
 8003dda:	4620      	mov	r0, r4
 8003ddc:	f7ff fd38 	bl	8003850 <chTimeDiffX.lto_priv.0>
 8003de0:	4604      	mov	r4, r0
        chTimeDiffX(vtlp->lasttime, next_alarm)) {
 8003de2:	9b05      	ldr	r3, [sp, #20]
 8003de4:	68db      	ldr	r3, [r3, #12]
 8003de6:	9900      	ldr	r1, [sp, #0]
 8003de8:	4618      	mov	r0, r3
 8003dea:	f7ff fd31 	bl	8003850 <chTimeDiffX.lto_priv.0>
 8003dee:	4603      	mov	r3, r0
    if (chTimeDiffX(vtlp->lasttime, chVTGetSystemTimeX()) >
 8003df0:	429c      	cmp	r4, r3
 8003df2:	d904      	bls.n	8003dfe <chVTDoTickI+0x15e>

      chDbgAssert(false, "insufficient delta");
      chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8003df4:	2001      	movs	r0, #1
 8003df6:	f7ff fd0b 	bl	8003810 <chRFCUCollectFaultsI>
 8003dfa:	e000      	b.n	8003dfe <chVTDoTickI+0x15e>
    return;
 8003dfc:	bf00      	nop
                chTimeDiffX(vtlp->lasttime, next_alarm),
                "insufficient delta");
#endif
  }
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003dfe:	b008      	add	sp, #32
 8003e00:	bd10      	pop	{r4, pc}
 8003e02:	bf00      	nop
 8003e04:	20000da0 	.word	0x20000da0
	...

08003e10 <ch_queue_dequeue.lto_priv.0>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8003e10:	b082      	sub	sp, #8
 8003e12:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8003e14:	9b01      	ldr	r3, [sp, #4]
 8003e16:	685b      	ldr	r3, [r3, #4]
 8003e18:	9a01      	ldr	r2, [sp, #4]
 8003e1a:	6812      	ldr	r2, [r2, #0]
 8003e1c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 8003e1e:	9b01      	ldr	r3, [sp, #4]
 8003e20:	681b      	ldr	r3, [r3, #0]
 8003e22:	9a01      	ldr	r2, [sp, #4]
 8003e24:	6852      	ldr	r2, [r2, #4]
 8003e26:	605a      	str	r2, [r3, #4]
  return p;
 8003e28:	9b01      	ldr	r3, [sp, #4]
}
 8003e2a:	4618      	mov	r0, r3
 8003e2c:	b002      	add	sp, #8
 8003e2e:	4770      	bx	lr

08003e30 <ch_pqueue_remove_highest>:
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
 8003e30:	b084      	sub	sp, #16
 8003e32:	9001      	str	r0, [sp, #4]
  ch_priority_queue_t *p = pqp->next;
 8003e34:	9b01      	ldr	r3, [sp, #4]
 8003e36:	681b      	ldr	r3, [r3, #0]
 8003e38:	9303      	str	r3, [sp, #12]
  pqp->next       = p->next;
 8003e3a:	9b03      	ldr	r3, [sp, #12]
 8003e3c:	681a      	ldr	r2, [r3, #0]
 8003e3e:	9b01      	ldr	r3, [sp, #4]
 8003e40:	601a      	str	r2, [r3, #0]
  pqp->next->prev = pqp;
 8003e42:	9b01      	ldr	r3, [sp, #4]
 8003e44:	681b      	ldr	r3, [r3, #0]
 8003e46:	9a01      	ldr	r2, [sp, #4]
 8003e48:	605a      	str	r2, [r3, #4]
  return p;
 8003e4a:	9b03      	ldr	r3, [sp, #12]
}
 8003e4c:	4618      	mov	r0, r3
 8003e4e:	b004      	add	sp, #16
 8003e50:	4770      	bx	lr
 8003e52:	bf00      	nop
	...

08003e60 <ch_pqueue_insert_behind>:
                                                           ch_priority_queue_t *p) {
 8003e60:	b082      	sub	sp, #8
 8003e62:	9001      	str	r0, [sp, #4]
 8003e64:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8003e66:	9b01      	ldr	r3, [sp, #4]
 8003e68:	681b      	ldr	r3, [r3, #0]
 8003e6a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio >= p->prio));
 8003e6c:	9b01      	ldr	r3, [sp, #4]
 8003e6e:	689a      	ldr	r2, [r3, #8]
 8003e70:	9b00      	ldr	r3, [sp, #0]
 8003e72:	689b      	ldr	r3, [r3, #8]
 8003e74:	429a      	cmp	r2, r3
 8003e76:	bf2c      	ite	cs
 8003e78:	2301      	movcs	r3, #1
 8003e7a:	2300      	movcc	r3, #0
 8003e7c:	b2db      	uxtb	r3, r3
 8003e7e:	2b00      	cmp	r3, #0
 8003e80:	d1f1      	bne.n	8003e66 <ch_pqueue_insert_behind+0x6>
  p->next       = pqp;
 8003e82:	9b00      	ldr	r3, [sp, #0]
 8003e84:	9a01      	ldr	r2, [sp, #4]
 8003e86:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8003e88:	9b01      	ldr	r3, [sp, #4]
 8003e8a:	685a      	ldr	r2, [r3, #4]
 8003e8c:	9b00      	ldr	r3, [sp, #0]
 8003e8e:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003e90:	9b00      	ldr	r3, [sp, #0]
 8003e92:	685b      	ldr	r3, [r3, #4]
 8003e94:	9a00      	ldr	r2, [sp, #0]
 8003e96:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8003e98:	9b01      	ldr	r3, [sp, #4]
 8003e9a:	9a00      	ldr	r2, [sp, #0]
 8003e9c:	605a      	str	r2, [r3, #4]
  return p;
 8003e9e:	9b00      	ldr	r3, [sp, #0]
}
 8003ea0:	4618      	mov	r0, r3
 8003ea2:	b002      	add	sp, #8
 8003ea4:	4770      	bx	lr
 8003ea6:	bf00      	nop
	...

08003eb0 <ch_pqueue_insert_ahead>:
                                                          ch_priority_queue_t *p) {
 8003eb0:	b082      	sub	sp, #8
 8003eb2:	9001      	str	r0, [sp, #4]
 8003eb4:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8003eb6:	9b01      	ldr	r3, [sp, #4]
 8003eb8:	681b      	ldr	r3, [r3, #0]
 8003eba:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio > p->prio));
 8003ebc:	9b01      	ldr	r3, [sp, #4]
 8003ebe:	689a      	ldr	r2, [r3, #8]
 8003ec0:	9b00      	ldr	r3, [sp, #0]
 8003ec2:	689b      	ldr	r3, [r3, #8]
 8003ec4:	429a      	cmp	r2, r3
 8003ec6:	bf8c      	ite	hi
 8003ec8:	2301      	movhi	r3, #1
 8003eca:	2300      	movls	r3, #0
 8003ecc:	b2db      	uxtb	r3, r3
 8003ece:	2b00      	cmp	r3, #0
 8003ed0:	d1f1      	bne.n	8003eb6 <ch_pqueue_insert_ahead+0x6>
  p->next       = pqp;
 8003ed2:	9b00      	ldr	r3, [sp, #0]
 8003ed4:	9a01      	ldr	r2, [sp, #4]
 8003ed6:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8003ed8:	9b01      	ldr	r3, [sp, #4]
 8003eda:	685a      	ldr	r2, [r3, #4]
 8003edc:	9b00      	ldr	r3, [sp, #0]
 8003ede:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003ee0:	9b00      	ldr	r3, [sp, #0]
 8003ee2:	685b      	ldr	r3, [r3, #4]
 8003ee4:	9a00      	ldr	r2, [sp, #0]
 8003ee6:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8003ee8:	9b01      	ldr	r3, [sp, #4]
 8003eea:	9a00      	ldr	r2, [sp, #0]
 8003eec:	605a      	str	r2, [r3, #4]
  return p;
 8003eee:	9b00      	ldr	r3, [sp, #0]
}
 8003ef0:	4618      	mov	r0, r3
 8003ef2:	b002      	add	sp, #8
 8003ef4:	4770      	bx	lr
 8003ef6:	bf00      	nop
	...

08003f00 <chSysLockFromISR.lto_priv.4>:
static inline void chSysLockFromISR(void) {
 8003f00:	b082      	sub	sp, #8
 8003f02:	2320      	movs	r3, #32
 8003f04:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003f06:	9b01      	ldr	r3, [sp, #4]
 8003f08:	f383 8811 	msr	BASEPRI, r3
}
 8003f0c:	bf00      	nop
}
 8003f0e:	bf00      	nop
}
 8003f10:	bf00      	nop
}
 8003f12:	bf00      	nop
 8003f14:	b002      	add	sp, #8
 8003f16:	4770      	bx	lr
	...

08003f20 <chSysUnlockFromISR.lto_priv.4>:
static inline void chSysUnlockFromISR(void) {
 8003f20:	b082      	sub	sp, #8
 8003f22:	2300      	movs	r3, #0
 8003f24:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003f26:	9b01      	ldr	r3, [sp, #4]
 8003f28:	f383 8811 	msr	BASEPRI, r3
}
 8003f2c:	bf00      	nop
}
 8003f2e:	bf00      	nop
}
 8003f30:	bf00      	nop
}
 8003f32:	bf00      	nop
 8003f34:	b002      	add	sp, #8
 8003f36:	4770      	bx	lr
	...

08003f40 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8003f40:	b082      	sub	sp, #8
 8003f42:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->dlist.next != NULL);
 8003f44:	9b01      	ldr	r3, [sp, #4]
 8003f46:	681b      	ldr	r3, [r3, #0]
 8003f48:	2b00      	cmp	r3, #0
 8003f4a:	bf14      	ite	ne
 8003f4c:	2301      	movne	r3, #1
 8003f4e:	2300      	moveq	r3, #0
 8003f50:	b2db      	uxtb	r3, r3
}
 8003f52:	4618      	mov	r0, r3
 8003f54:	b002      	add	sp, #8
 8003f56:	4770      	bx	lr
	...

08003f60 <chSemFastSignalI.lto_priv.0>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8003f60:	b082      	sub	sp, #8
 8003f62:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->cnt++;
 8003f64:	9b01      	ldr	r3, [sp, #4]
 8003f66:	689b      	ldr	r3, [r3, #8]
 8003f68:	1c5a      	adds	r2, r3, #1
 8003f6a:	9b01      	ldr	r3, [sp, #4]
 8003f6c:	609a      	str	r2, [r3, #8]
}
 8003f6e:	bf00      	nop
 8003f70:	b002      	add	sp, #8
 8003f72:	4770      	bx	lr
	...

08003f80 <__sch_ready_behind>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_behind(thread_t *tp) {
 8003f80:	b500      	push	{lr}
 8003f82:	b083      	sub	sp, #12
 8003f84:	9001      	str	r0, [sp, #4]

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 8003f86:	9b01      	ldr	r3, [sp, #4]
 8003f88:	2200      	movs	r2, #0
 8003f8a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  /* Insertion in the priority queue.*/
  return (thread_t *)ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8003f8e:	9b01      	ldr	r3, [sp, #4]
 8003f90:	699b      	ldr	r3, [r3, #24]
 8003f92:	461a      	mov	r2, r3
 8003f94:	9b01      	ldr	r3, [sp, #4]
 8003f96:	4619      	mov	r1, r3
 8003f98:	4610      	mov	r0, r2
 8003f9a:	f7ff ff61 	bl	8003e60 <ch_pqueue_insert_behind>
 8003f9e:	4603      	mov	r3, r0
                                             &tp->hdr.pqueue);
}
 8003fa0:	4618      	mov	r0, r3
 8003fa2:	b003      	add	sp, #12
 8003fa4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003fb0 <__sch_ready_ahead>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_ahead(thread_t *tp) {
 8003fb0:	b500      	push	{lr}
 8003fb2:	b083      	sub	sp, #12
 8003fb4:	9001      	str	r0, [sp, #4]

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 8003fb6:	9b01      	ldr	r3, [sp, #4]
 8003fb8:	2200      	movs	r2, #0
 8003fba:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  /* Insertion in the priority queue.*/
  return (thread_t *)ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 8003fbe:	9b01      	ldr	r3, [sp, #4]
 8003fc0:	699b      	ldr	r3, [r3, #24]
 8003fc2:	461a      	mov	r2, r3
 8003fc4:	9b01      	ldr	r3, [sp, #4]
 8003fc6:	4619      	mov	r1, r3
 8003fc8:	4610      	mov	r0, r2
 8003fca:	f7ff ff71 	bl	8003eb0 <ch_pqueue_insert_ahead>
 8003fce:	4603      	mov	r3, r0
                                            &tp->hdr.pqueue);
}
 8003fd0:	4618      	mov	r0, r3
 8003fd2:	b003      	add	sp, #12
 8003fd4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003fe0 <__sch_wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 8003fe0:	b500      	push	{lr}
 8003fe2:	b085      	sub	sp, #20
 8003fe4:	9001      	str	r0, [sp, #4]
 8003fe6:	9100      	str	r1, [sp, #0]
  thread_t *tp = (thread_t *)p;
 8003fe8:	9b00      	ldr	r3, [sp, #0]
 8003fea:	9303      	str	r3, [sp, #12]

  (void)vtp;

  chSysLockFromISR();
 8003fec:	f7ff ff88 	bl	8003f00 <chSysLockFromISR.lto_priv.4>
  switch (tp->state) {
 8003ff0:	9b03      	ldr	r3, [sp, #12]
 8003ff2:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8003ff6:	2b07      	cmp	r3, #7
 8003ff8:	d824      	bhi.n	8004044 <__sch_wakeup+0x64>
 8003ffa:	a201      	add	r2, pc, #4	; (adr r2, 8004000 <__sch_wakeup+0x20>)
 8003ffc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004000:	08004021 	.word	0x08004021
 8004004:	08004045 	.word	0x08004045
 8004008:	08004045 	.word	0x08004045
 800400c:	08004027 	.word	0x08004027
 8004010:	0800403b 	.word	0x0800403b
 8004014:	08004031 	.word	0x08004031
 8004018:	08004045 	.word	0x08004045
 800401c:	0800403b 	.word	0x0800403b
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8004020:	f7ff ff7e 	bl	8003f20 <chSysUnlockFromISR.lto_priv.4>
    return;
 8004024:	e019      	b.n	800405a <__sch_wakeup+0x7a>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 8004026:	9b03      	ldr	r3, [sp, #12]
 8004028:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800402a:	2200      	movs	r2, #0
 800402c:	601a      	str	r2, [r3, #0]
    break;
 800402e:	e00a      	b.n	8004046 <__sch_wakeup+0x66>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8004030:	9b03      	ldr	r3, [sp, #12]
 8004032:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004034:	4618      	mov	r0, r3
 8004036:	f7ff ff93 	bl	8003f60 <chSemFastSignalI.lto_priv.0>
    /* Falls through.*/
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) ch_queue_dequeue(&tp->hdr.queue);
 800403a:	9b03      	ldr	r3, [sp, #12]
 800403c:	4618      	mov	r0, r3
 800403e:	f7ff fee7 	bl	8003e10 <ch_queue_dequeue.lto_priv.0>
    break;
 8004042:	e000      	b.n	8004046 <__sch_wakeup+0x66>
  default:
    /* Any other state, nothing to do.*/
    break;
 8004044:	bf00      	nop
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
 8004046:	9b03      	ldr	r3, [sp, #12]
 8004048:	f04f 32ff 	mov.w	r2, #4294967295
 800404c:	629a      	str	r2, [r3, #40]	; 0x28

  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
 800404e:	9803      	ldr	r0, [sp, #12]
 8004050:	f7ff ff96 	bl	8003f80 <__sch_ready_behind>
  chSysUnlockFromISR();
 8004054:	f7ff ff64 	bl	8003f20 <chSysUnlockFromISR.lto_priv.4>

  return;
 8004058:	bf00      	nop
}
 800405a:	b005      	add	sp, #20
 800405c:	f85d fb04 	ldr.w	pc, [sp], #4

08004060 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8004060:	b500      	push	{lr}
 8004062:	b083      	sub	sp, #12
 8004064:	9001      	str	r0, [sp, #4]
       the other core.*/
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
 8004066:	9801      	ldr	r0, [sp, #4]
 8004068:	f7ff ff8a 	bl	8003f80 <__sch_ready_behind>
 800406c:	4603      	mov	r3, r0
}
 800406e:	4618      	mov	r0, r3
 8004070:	b003      	add	sp, #12
 8004072:	f85d fb04 	ldr.w	pc, [sp], #4
 8004076:	bf00      	nop
	...

08004080 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8004080:	b500      	push	{lr}
 8004082:	b087      	sub	sp, #28
 8004084:	4603      	mov	r3, r0
 8004086:	f88d 3007 	strb.w	r3, [sp, #7]
  os_instance_t *oip = currcore;
 800408a:	4b0f      	ldr	r3, [pc, #60]	; (80040c8 <chSchGoSleepS+0x48>)
 800408c:	9304      	str	r3, [sp, #16]
  thread_t *otp = __instance_get_currthread(oip);
 800408e:	9b04      	ldr	r3, [sp, #16]
 8004090:	68db      	ldr	r3, [r3, #12]
 8004092:	9303      	str	r3, [sp, #12]

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
  chDbgAssert(otp->owner == oip, "invalid core");

  /* New state.*/
  otp->state = newstate;
 8004094:	9b03      	ldr	r3, [sp, #12]
 8004096:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800409a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = (thread_t *)ch_pqueue_remove_highest(&oip->rlist.pqueue);
 800409e:	9b04      	ldr	r3, [sp, #16]
 80040a0:	4618      	mov	r0, r3
 80040a2:	f7ff fec5 	bl	8003e30 <ch_pqueue_remove_highest>
 80040a6:	9005      	str	r0, [sp, #20]
  ntp->state = CH_STATE_CURRENT;
 80040a8:	9b05      	ldr	r3, [sp, #20]
 80040aa:	2201      	movs	r2, #1
 80040ac:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  __instance_set_currthread(oip, ntp);
 80040b0:	9b04      	ldr	r3, [sp, #16]
 80040b2:	9a05      	ldr	r2, [sp, #20]
 80040b4:	60da      	str	r2, [r3, #12]
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 80040b6:	9903      	ldr	r1, [sp, #12]
 80040b8:	9805      	ldr	r0, [sp, #20]
 80040ba:	f7fc f911 	bl	80002e0 <__port_switch>
}
 80040be:	bf00      	nop
 80040c0:	b007      	add	sp, #28
 80040c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80040c6:	bf00      	nop
 80040c8:	20000d90 	.word	0x20000d90
 80040cc:	00000000 	.word	0x00000000

080040d0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 80040d0:	b500      	push	{lr}
 80040d2:	b08b      	sub	sp, #44	; 0x2c
 80040d4:	4603      	mov	r3, r0
 80040d6:	9100      	str	r1, [sp, #0]
 80040d8:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *tp = __instance_get_currthread(currcore);
 80040dc:	4b15      	ldr	r3, [pc, #84]	; (8004134 <chSchGoSleepTimeoutS+0x64>)
 80040de:	68db      	ldr	r3, [r3, #12]
 80040e0:	9309      	str	r3, [sp, #36]	; 0x24

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
 80040e2:	9b00      	ldr	r3, [sp, #0]
 80040e4:	f1b3 3fff 	cmp.w	r3, #4294967295
 80040e8:	d016      	beq.n	8004118 <chSchGoSleepTimeoutS+0x48>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 80040ea:	a803      	add	r0, sp, #12
 80040ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80040ee:	4a12      	ldr	r2, [pc, #72]	; (8004138 <chSchGoSleepTimeoutS+0x68>)
 80040f0:	9900      	ldr	r1, [sp, #0]
 80040f2:	f7ff fd3d 	bl	8003b70 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80040f6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80040fa:	4618      	mov	r0, r3
 80040fc:	f7ff ffc0 	bl	8004080 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8004100:	ab03      	add	r3, sp, #12
 8004102:	4618      	mov	r0, r3
 8004104:	f7ff ff1c 	bl	8003f40 <chVTIsArmedI>
 8004108:	4603      	mov	r3, r0
 800410a:	2b00      	cmp	r3, #0
 800410c:	d009      	beq.n	8004122 <chSchGoSleepTimeoutS+0x52>
      chVTDoResetI(&vt);
 800410e:	ab03      	add	r3, sp, #12
 8004110:	4618      	mov	r0, r3
 8004112:	f7ff fd4d 	bl	8003bb0 <chVTDoResetI>
 8004116:	e004      	b.n	8004122 <chSchGoSleepTimeoutS+0x52>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8004118:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800411c:	4618      	mov	r0, r3
 800411e:	f7ff ffaf 	bl	8004080 <chSchGoSleepS>
  }

  return tp->u.rdymsg;
 8004122:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004124:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004126:	bf00      	nop
 8004128:	bf00      	nop
}
 800412a:	4618      	mov	r0, r3
 800412c:	b00b      	add	sp, #44	; 0x2c
 800412e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004132:	bf00      	nop
 8004134:	20000d90 	.word	0x20000d90
 8004138:	08003fe1 	.word	0x08003fe1
 800413c:	00000000 	.word	0x00000000

08004140 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8004140:	b500      	push	{lr}
 8004142:	b085      	sub	sp, #20
 8004144:	9001      	str	r0, [sp, #4]
 8004146:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 8004148:	4b14      	ldr	r3, [pc, #80]	; (800419c <chSchWakeupS+0x5c>)
 800414a:	9302      	str	r3, [sp, #8]
  thread_t *otp = __instance_get_currthread(oip);
 800414c:	9b02      	ldr	r3, [sp, #8]
 800414e:	68db      	ldr	r3, [r3, #12]
 8004150:	9303      	str	r3, [sp, #12]
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8004152:	9b01      	ldr	r3, [sp, #4]
 8004154:	9a00      	ldr	r2, [sp, #0]
 8004156:	629a      	str	r2, [r3, #40]	; 0x28
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 8004158:	9b01      	ldr	r3, [sp, #4]
 800415a:	689a      	ldr	r2, [r3, #8]
 800415c:	9b03      	ldr	r3, [sp, #12]
 800415e:	689b      	ldr	r3, [r3, #8]
 8004160:	429a      	cmp	r2, r3
 8004162:	bf94      	ite	ls
 8004164:	2301      	movls	r3, #1
 8004166:	2300      	movhi	r3, #0
 8004168:	b2db      	uxtb	r3, r3
 800416a:	2b00      	cmp	r3, #0
 800416c:	d003      	beq.n	8004176 <chSchWakeupS+0x36>
    (void) __sch_ready_behind(ntp);
 800416e:	9801      	ldr	r0, [sp, #4]
 8004170:	f7ff ff06 	bl	8003f80 <__sch_ready_behind>
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 8004174:	e00e      	b.n	8004194 <chSchWakeupS+0x54>
    otp = __sch_ready_ahead(otp);
 8004176:	9803      	ldr	r0, [sp, #12]
 8004178:	f7ff ff1a 	bl	8003fb0 <__sch_ready_ahead>
 800417c:	9003      	str	r0, [sp, #12]
    ntp->state = CH_STATE_CURRENT;
 800417e:	9b01      	ldr	r3, [sp, #4]
 8004180:	2201      	movs	r2, #1
 8004182:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    __instance_set_currthread(oip, ntp);
 8004186:	9b02      	ldr	r3, [sp, #8]
 8004188:	9a01      	ldr	r2, [sp, #4]
 800418a:	60da      	str	r2, [r3, #12]
    chSysSwitch(ntp, otp);
 800418c:	9903      	ldr	r1, [sp, #12]
 800418e:	9801      	ldr	r0, [sp, #4]
 8004190:	f7fc f8a6 	bl	80002e0 <__port_switch>
}
 8004194:	bf00      	nop
 8004196:	b005      	add	sp, #20
 8004198:	f85d fb04 	ldr.w	pc, [sp], #4
 800419c:	20000d90 	.word	0x20000d90

080041a0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 80041a0:	b084      	sub	sp, #16
  os_instance_t *oip = currcore;
 80041a2:	4b0b      	ldr	r3, [pc, #44]	; (80041d0 <chSchIsPreemptionRequired+0x30>)
 80041a4:	9303      	str	r3, [sp, #12]
  thread_t *tp = __instance_get_currthread(oip);
 80041a6:	9b03      	ldr	r3, [sp, #12]
 80041a8:	68db      	ldr	r3, [r3, #12]
 80041aa:	9302      	str	r3, [sp, #8]

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 80041ac:	9b03      	ldr	r3, [sp, #12]
 80041ae:	681b      	ldr	r3, [r3, #0]
 80041b0:	689b      	ldr	r3, [r3, #8]
 80041b2:	9301      	str	r3, [sp, #4]
  tprio_t p2 = tp->hdr.pqueue.prio;
 80041b4:	9b02      	ldr	r3, [sp, #8]
 80041b6:	689b      	ldr	r3, [r3, #8]
 80041b8:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 80041ba:	9a01      	ldr	r2, [sp, #4]
 80041bc:	9b00      	ldr	r3, [sp, #0]
 80041be:	429a      	cmp	r2, r3
 80041c0:	bf8c      	ite	hi
 80041c2:	2301      	movhi	r3, #1
 80041c4:	2300      	movls	r3, #0
 80041c6:	b2db      	uxtb	r3, r3
#endif
}
 80041c8:	4618      	mov	r0, r3
 80041ca:	b004      	add	sp, #16
 80041cc:	4770      	bx	lr
 80041ce:	bf00      	nop
 80041d0:	20000d90 	.word	0x20000d90
	...

080041e0 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
 80041e0:	b500      	push	{lr}
 80041e2:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 80041e4:	4b0e      	ldr	r3, [pc, #56]	; (8004220 <chSchDoPreemption+0x40>)
 80041e6:	9303      	str	r3, [sp, #12]
  thread_t *otp = __instance_get_currthread(oip);
 80041e8:	9b03      	ldr	r3, [sp, #12]
 80041ea:	68db      	ldr	r3, [r3, #12]
 80041ec:	9302      	str	r3, [sp, #8]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = (thread_t *)ch_pqueue_remove_highest(&oip->rlist.pqueue);
 80041ee:	9b03      	ldr	r3, [sp, #12]
 80041f0:	4618      	mov	r0, r3
 80041f2:	f7ff fe1d 	bl	8003e30 <ch_pqueue_remove_highest>
 80041f6:	9001      	str	r0, [sp, #4]
  ntp->state = CH_STATE_CURRENT;
 80041f8:	9b01      	ldr	r3, [sp, #4]
 80041fa:	2201      	movs	r2, #1
 80041fc:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  __instance_set_currthread(oip, ntp);
 8004200:	9b03      	ldr	r3, [sp, #12]
 8004202:	9a01      	ldr	r2, [sp, #4]
 8004204:	60da      	str	r2, [r3, #12]
    otp = __sch_ready_ahead(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
 8004206:	9802      	ldr	r0, [sp, #8]
 8004208:	f7ff fed2 	bl	8003fb0 <__sch_ready_ahead>
 800420c:	9002      	str	r0, [sp, #8]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 800420e:	9902      	ldr	r1, [sp, #8]
 8004210:	9801      	ldr	r0, [sp, #4]
 8004212:	f7fc f865 	bl	80002e0 <__port_switch>
}
 8004216:	bf00      	nop
 8004218:	b005      	add	sp, #20
 800421a:	f85d fb04 	ldr.w	pc, [sp], #4
 800421e:	bf00      	nop
 8004220:	20000d90 	.word	0x20000d90
	...

08004230 <__rfcu_object_init>:
 *
 * @param[out] rfcup    pointer to the @p rfcu_t structure
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {
 8004230:	b082      	sub	sp, #8
 8004232:	9001      	str	r0, [sp, #4]

  rfcup->mask = (rfcu_mask_t)0;
 8004234:	9b01      	ldr	r3, [sp, #4]
 8004236:	2200      	movs	r2, #0
 8004238:	601a      	str	r2, [r3, #0]
}
 800423a:	bf00      	nop
 800423c:	b002      	add	sp, #8
 800423e:	4770      	bx	lr

08004240 <__dbg_object_init>:
 *
 * @param[out] sdp      pointer to the @p system_debug_t structure
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {
 8004240:	b082      	sub	sp, #8
 8004242:	9001      	str	r0, [sp, #4]

  sdp->panic_msg = NULL;
 8004244:	9b01      	ldr	r3, [sp, #4]
 8004246:	2200      	movs	r2, #0
 8004248:	601a      	str	r2, [r3, #0]
#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  /* The initial state is assumed to be within a critical zone.*/
  sdp->isr_cnt  = (cnt_t)0;
  sdp->lock_cnt = (cnt_t)1;
#endif
}
 800424a:	bf00      	nop
 800424c:	b002      	add	sp, #8
 800424e:	4770      	bx	lr

08004250 <ch_queue_init.lto_priv.2>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8004250:	b082      	sub	sp, #8
 8004252:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8004254:	9b01      	ldr	r3, [sp, #4]
 8004256:	9a01      	ldr	r2, [sp, #4]
 8004258:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800425a:	9b01      	ldr	r3, [sp, #4]
 800425c:	9a01      	ldr	r2, [sp, #4]
 800425e:	605a      	str	r2, [r3, #4]
}
 8004260:	bf00      	nop
 8004262:	b002      	add	sp, #8
 8004264:	4770      	bx	lr
 8004266:	bf00      	nop
	...

08004270 <ch_pqueue_init>:
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {
 8004270:	b082      	sub	sp, #8
 8004272:	9001      	str	r0, [sp, #4]
  pqp->next = pqp;
 8004274:	9b01      	ldr	r3, [sp, #4]
 8004276:	9a01      	ldr	r2, [sp, #4]
 8004278:	601a      	str	r2, [r3, #0]
  pqp->prev = pqp;
 800427a:	9b01      	ldr	r3, [sp, #4]
 800427c:	9a01      	ldr	r2, [sp, #4]
 800427e:	605a      	str	r2, [r3, #4]
  pqp->prio = (tprio_t)0;
 8004280:	9b01      	ldr	r3, [sp, #4]
 8004282:	2200      	movs	r2, #0
 8004284:	609a      	str	r2, [r3, #8]
}
 8004286:	bf00      	nop
 8004288:	b002      	add	sp, #8
 800428a:	4770      	bx	lr
 800428c:	0000      	movs	r0, r0
	...

08004290 <ch_dlist_init>:
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {
 8004290:	b082      	sub	sp, #8
 8004292:	9001      	str	r0, [sp, #4]
  dlhp->next  = dlhp;
 8004294:	9b01      	ldr	r3, [sp, #4]
 8004296:	9a01      	ldr	r2, [sp, #4]
 8004298:	601a      	str	r2, [r3, #0]
  dlhp->prev  = dlhp;
 800429a:	9b01      	ldr	r3, [sp, #4]
 800429c:	9a01      	ldr	r2, [sp, #4]
 800429e:	605a      	str	r2, [r3, #4]
  dlhp->delta = (sysinterval_t)-1;
 80042a0:	9b01      	ldr	r3, [sp, #4]
 80042a2:	f04f 32ff 	mov.w	r2, #4294967295
 80042a6:	609a      	str	r2, [r3, #8]
}
 80042a8:	bf00      	nop
 80042aa:	b002      	add	sp, #8
 80042ac:	4770      	bx	lr
 80042ae:	bf00      	nop

080042b0 <port_timer_get_time.lto_priv.1>:
static inline systime_t port_timer_get_time(void) {
 80042b0:	b508      	push	{r3, lr}
  return stGetCounter();
 80042b2:	f7fc ff7d 	bl	80011b0 <stGetCounter>
 80042b6:	4603      	mov	r3, r0
}
 80042b8:	4618      	mov	r0, r3
 80042ba:	bd08      	pop	{r3, pc}
 80042bc:	0000      	movs	r0, r0
	...

080042c0 <chVTGetSystemTimeX.lto_priv.1>:
static inline systime_t chVTGetSystemTimeX(void) {
 80042c0:	b508      	push	{r3, lr}
  return port_timer_get_time();
 80042c2:	f7ff fff5 	bl	80042b0 <port_timer_get_time.lto_priv.1>
 80042c6:	4603      	mov	r3, r0
}
 80042c8:	4618      	mov	r0, r3
 80042ca:	bd08      	pop	{r3, pc}
 80042cc:	0000      	movs	r0, r0
	...

080042d0 <__vt_object_init>:
 *
 * @param[out] vtlp     pointer to the @p virtual_timers_list_t structure
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {
 80042d0:	b530      	push	{r4, r5, lr}
 80042d2:	b083      	sub	sp, #12
 80042d4:	9001      	str	r0, [sp, #4]

  ch_dlist_init(&vtlp->dlist);
 80042d6:	9b01      	ldr	r3, [sp, #4]
 80042d8:	4618      	mov	r0, r3
 80042da:	f7ff ffd9 	bl	8004290 <ch_dlist_init>
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 80042de:	9b01      	ldr	r3, [sp, #4]
 80042e0:	2200      	movs	r2, #0
 80042e2:	60da      	str	r2, [r3, #12]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 80042e4:	f7ff ffec 	bl	80042c0 <chVTGetSystemTimeX.lto_priv.1>
 80042e8:	4603      	mov	r3, r0
 80042ea:	2200      	movs	r2, #0
 80042ec:	461c      	mov	r4, r3
 80042ee:	4615      	mov	r5, r2
 80042f0:	9b01      	ldr	r3, [sp, #4]
 80042f2:	e9c3 4504 	strd	r4, r5, [r3, #16]
#endif
}
 80042f6:	bf00      	nop
 80042f8:	b003      	add	sp, #12
 80042fa:	bd30      	pop	{r4, r5, pc}
 80042fc:	0000      	movs	r0, r0
	...

08004300 <__reg_object_init>:
 *
 * @param[out] rp       pointer to a @p registry_t structure
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {
 8004300:	b500      	push	{lr}
 8004302:	b083      	sub	sp, #12
 8004304:	9001      	str	r0, [sp, #4]

  ch_queue_init(&rp->queue);
 8004306:	9b01      	ldr	r3, [sp, #4]
 8004308:	4618      	mov	r0, r3
 800430a:	f7ff ffa1 	bl	8004250 <ch_queue_init.lto_priv.2>
}
 800430e:	bf00      	nop
 8004310:	b003      	add	sp, #12
 8004312:	f85d fb04 	ldr.w	pc, [sp], #4
 8004316:	bf00      	nop
	...

08004320 <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
 8004320:	b082      	sub	sp, #8
 8004322:	9001      	str	r0, [sp, #4]
__STATIC_FORCEINLINE void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8004324:	bf00      	nop
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8004326:	e7fd      	b.n	8004324 <__idle_thread+0x4>
	...

08004330 <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
 8004330:	b500      	push	{lr}
 8004332:	b08b      	sub	sp, #44	; 0x2c
 8004334:	9001      	str	r0, [sp, #4]
 8004336:	9100      	str	r1, [sp, #0]

  /* Registering into the global system structure.*/
#if CH_CFG_SMP_MODE == TRUE
  core_id = port_get_core_id();
#else
  core_id = 0U;
 8004338:	2300      	movs	r3, #0
 800433a:	9309      	str	r3, [sp, #36]	; 0x24
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
 800433c:	4a28      	ldr	r2, [pc, #160]	; (80043e0 <chInstanceObjectInit+0xb0>)
 800433e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004340:	009b      	lsls	r3, r3, #2
 8004342:	4413      	add	r3, r2
 8004344:	9a01      	ldr	r2, [sp, #4]
 8004346:	605a      	str	r2, [r3, #4]

  /* Core associated to this instance.*/
  oip->core_id = core_id;
 8004348:	9b01      	ldr	r3, [sp, #4]
 800434a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800434c:	631a      	str	r2, [r3, #48]	; 0x30

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 800434e:	9b01      	ldr	r3, [sp, #4]
 8004350:	9a00      	ldr	r2, [sp, #0]
 8004352:	639a      	str	r2, [r3, #56]	; 0x38

  /* Port initialization for the current instance.*/
  port_init(oip);
 8004354:	9801      	ldr	r0, [sp, #4]
 8004356:	f000 fd13 	bl	8004d80 <port_init>

  /* Ready list initialization.*/
  ch_pqueue_init(&oip->rlist.pqueue);
 800435a:	9b01      	ldr	r3, [sp, #4]
 800435c:	4618      	mov	r0, r3
 800435e:	f7ff ff87 	bl	8004270 <ch_pqueue_init>

#if (CH_CFG_USE_REGISTRY == TRUE) && (CH_CFG_SMP_MODE == FALSE)
  /* Registry initialization when SMP mode is disabled.*/
  __reg_object_init(&oip->reglist);
 8004362:	9b01      	ldr	r3, [sp, #4]
 8004364:	3328      	adds	r3, #40	; 0x28
 8004366:	4618      	mov	r0, r3
 8004368:	f7ff ffca 	bl	8004300 <__reg_object_init>
#endif

#if CH_CFG_SMP_MODE == FALSE
  /* RFCU initialization when SMP mode is disabled.*/
  __rfcu_object_init(&oip->rfcu);
 800436c:	9b01      	ldr	r3, [sp, #4]
 800436e:	3334      	adds	r3, #52	; 0x34
 8004370:	4618      	mov	r0, r3
 8004372:	f7ff ff5d 	bl	8004230 <__rfcu_object_init>
#endif

  /* Virtual timers list initialization.*/
  __vt_object_init(&oip->vtlist);
 8004376:	9b01      	ldr	r3, [sp, #4]
 8004378:	3310      	adds	r3, #16
 800437a:	4618      	mov	r0, r3
 800437c:	f7ff ffa8 	bl	80042d0 <__vt_object_init>

  /* Debug support initialization.*/
  __dbg_object_init(&oip->dbg);
 8004380:	9b01      	ldr	r3, [sp, #4]
 8004382:	3384      	adds	r3, #132	; 0x84
 8004384:	4618      	mov	r0, r3
 8004386:	f7ff ff5b 	bl	8004240 <__dbg_object_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 800438a:	9b01      	ldr	r3, [sp, #4]
 800438c:	f103 013c 	add.w	r1, r3, #60	; 0x3c
 8004390:	2380      	movs	r3, #128	; 0x80
 8004392:	4a14      	ldr	r2, [pc, #80]	; (80043e4 <chInstanceObjectInit+0xb4>)
 8004394:	9801      	ldr	r0, [sp, #4]
 8004396:	f000 f903 	bl	80045a0 <__thd_object_init>
 800439a:	4602      	mov	r2, r0
 800439c:	9b01      	ldr	r3, [sp, #4]
 800439e:	60da      	str	r2, [r3, #12]
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
                                         "idle", IDLEPRIO);
#endif

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
 80043a0:	9b01      	ldr	r3, [sp, #4]
 80043a2:	68db      	ldr	r3, [r3, #12]
 80043a4:	9a00      	ldr	r2, [sp, #0]
 80043a6:	6852      	ldr	r2, [r2, #4]
 80043a8:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 80043aa:	9b01      	ldr	r3, [sp, #4]
 80043ac:	68db      	ldr	r3, [r3, #12]
 80043ae:	2201      	movs	r2, #1
 80043b0:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
 80043b4:	4b0c      	ldr	r3, [pc, #48]	; (80043e8 <chInstanceObjectInit+0xb8>)
 80043b6:	9303      	str	r3, [sp, #12]
      .name     = "idle",
      .wbase    = oicp->idlethread_base,
 80043b8:	9b00      	ldr	r3, [sp, #0]
 80043ba:	68db      	ldr	r3, [r3, #12]
    thread_descriptor_t idle_descriptor = {
 80043bc:	9304      	str	r3, [sp, #16]
      .wend     = oicp->idlethread_end,
 80043be:	9b00      	ldr	r3, [sp, #0]
 80043c0:	691b      	ldr	r3, [r3, #16]
    thread_descriptor_t idle_descriptor = {
 80043c2:	9305      	str	r3, [sp, #20]
 80043c4:	2301      	movs	r3, #1
 80043c6:	9306      	str	r3, [sp, #24]
 80043c8:	4b08      	ldr	r3, [pc, #32]	; (80043ec <chInstanceObjectInit+0xbc>)
 80043ca:	9307      	str	r3, [sp, #28]
 80043cc:	2300      	movs	r3, #0
 80043ce:	9308      	str	r3, [sp, #32]
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
 80043d0:	ab03      	add	r3, sp, #12
 80043d2:	4618      	mov	r0, r3
 80043d4:	f000 f954 	bl	8004680 <chThdCreateI>
  }
#endif
}
 80043d8:	bf00      	nop
 80043da:	b00b      	add	sp, #44	; 0x2c
 80043dc:	f85d fb04 	ldr.w	pc, [sp], #4
 80043e0:	20000d80 	.word	0x20000d80
 80043e4:	08007008 	.word	0x08007008
 80043e8:	08006ff8 	.word	0x08006ff8
 80043ec:	08004321 	.word	0x08004321

080043f0 <ch_list_init>:
static inline void ch_list_init(ch_list_t *lp) {
 80043f0:	b082      	sub	sp, #8
 80043f2:	9001      	str	r0, [sp, #4]
  lp->next = lp;
 80043f4:	9b01      	ldr	r3, [sp, #4]
 80043f6:	9a01      	ldr	r2, [sp, #4]
 80043f8:	601a      	str	r2, [r3, #0]
}
 80043fa:	bf00      	nop
 80043fc:	b002      	add	sp, #8
 80043fe:	4770      	bx	lr

08004400 <ch_list_notempty>:
static inline bool ch_list_notempty(ch_list_t *lp) {
 8004400:	b082      	sub	sp, #8
 8004402:	9001      	str	r0, [sp, #4]
  return (bool)(lp->next != lp);
 8004404:	9b01      	ldr	r3, [sp, #4]
 8004406:	681b      	ldr	r3, [r3, #0]
 8004408:	9a01      	ldr	r2, [sp, #4]
 800440a:	429a      	cmp	r2, r3
 800440c:	bf14      	ite	ne
 800440e:	2301      	movne	r3, #1
 8004410:	2300      	moveq	r3, #0
 8004412:	b2db      	uxtb	r3, r3
}
 8004414:	4618      	mov	r0, r3
 8004416:	b002      	add	sp, #8
 8004418:	4770      	bx	lr
 800441a:	bf00      	nop
 800441c:	0000      	movs	r0, r0
	...

08004420 <ch_list_unlink>:
static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
 8004420:	b084      	sub	sp, #16
 8004422:	9001      	str	r0, [sp, #4]
  ch_list_t *p = lp->next;
 8004424:	9b01      	ldr	r3, [sp, #4]
 8004426:	681b      	ldr	r3, [r3, #0]
 8004428:	9303      	str	r3, [sp, #12]
  lp->next = p->next;
 800442a:	9b03      	ldr	r3, [sp, #12]
 800442c:	681a      	ldr	r2, [r3, #0]
 800442e:	9b01      	ldr	r3, [sp, #4]
 8004430:	601a      	str	r2, [r3, #0]
  return p;
 8004432:	9b03      	ldr	r3, [sp, #12]
}
 8004434:	4618      	mov	r0, r3
 8004436:	b004      	add	sp, #16
 8004438:	4770      	bx	lr
 800443a:	bf00      	nop
 800443c:	0000      	movs	r0, r0
	...

08004440 <ch_queue_init.lto_priv.3>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8004440:	b082      	sub	sp, #8
 8004442:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8004444:	9b01      	ldr	r3, [sp, #4]
 8004446:	9a01      	ldr	r2, [sp, #4]
 8004448:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800444a:	9b01      	ldr	r3, [sp, #4]
 800444c:	9a01      	ldr	r2, [sp, #4]
 800444e:	605a      	str	r2, [r3, #4]
}
 8004450:	bf00      	nop
 8004452:	b002      	add	sp, #8
 8004454:	4770      	bx	lr
 8004456:	bf00      	nop
	...

08004460 <ch_queue_notempty.lto_priv.0>:
static inline bool ch_queue_notempty(const ch_queue_t *qp) {
 8004460:	b082      	sub	sp, #8
 8004462:	9001      	str	r0, [sp, #4]
  return (bool)(qp->next != qp);
 8004464:	9b01      	ldr	r3, [sp, #4]
 8004466:	681b      	ldr	r3, [r3, #0]
 8004468:	9a01      	ldr	r2, [sp, #4]
 800446a:	429a      	cmp	r2, r3
 800446c:	bf14      	ite	ne
 800446e:	2301      	movne	r3, #1
 8004470:	2300      	moveq	r3, #0
 8004472:	b2db      	uxtb	r3, r3
}
 8004474:	4618      	mov	r0, r3
 8004476:	b002      	add	sp, #8
 8004478:	4770      	bx	lr
 800447a:	bf00      	nop
 800447c:	0000      	movs	r0, r0
	...

08004480 <ch_queue_insert.lto_priv.0>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
 8004480:	b082      	sub	sp, #8
 8004482:	9001      	str	r0, [sp, #4]
 8004484:	9100      	str	r1, [sp, #0]
  p->next       = qp;
 8004486:	9b00      	ldr	r3, [sp, #0]
 8004488:	9a01      	ldr	r2, [sp, #4]
 800448a:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
 800448c:	9b01      	ldr	r3, [sp, #4]
 800448e:	685a      	ldr	r2, [r3, #4]
 8004490:	9b00      	ldr	r3, [sp, #0]
 8004492:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8004494:	9b00      	ldr	r3, [sp, #0]
 8004496:	685b      	ldr	r3, [r3, #4]
 8004498:	9a00      	ldr	r2, [sp, #0]
 800449a:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
 800449c:	9b01      	ldr	r3, [sp, #4]
 800449e:	9a00      	ldr	r2, [sp, #0]
 80044a0:	605a      	str	r2, [r3, #4]
}
 80044a2:	bf00      	nop
 80044a4:	b002      	add	sp, #8
 80044a6:	4770      	bx	lr
	...

080044b0 <ch_queue_fifo_remove.lto_priv.0>:
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
 80044b0:	b084      	sub	sp, #16
 80044b2:	9001      	str	r0, [sp, #4]
  ch_queue_t *p = qp->next;
 80044b4:	9b01      	ldr	r3, [sp, #4]
 80044b6:	681b      	ldr	r3, [r3, #0]
 80044b8:	9303      	str	r3, [sp, #12]
  qp->next       = p->next;
 80044ba:	9b03      	ldr	r3, [sp, #12]
 80044bc:	681a      	ldr	r2, [r3, #0]
 80044be:	9b01      	ldr	r3, [sp, #4]
 80044c0:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
 80044c2:	9b01      	ldr	r3, [sp, #4]
 80044c4:	681b      	ldr	r3, [r3, #0]
 80044c6:	9a01      	ldr	r2, [sp, #4]
 80044c8:	605a      	str	r2, [r3, #4]
  return p;
 80044ca:	9b03      	ldr	r3, [sp, #12]
}
 80044cc:	4618      	mov	r0, r3
 80044ce:	b004      	add	sp, #16
 80044d0:	4770      	bx	lr
 80044d2:	bf00      	nop
	...

080044e0 <ch_queue_dequeue.lto_priv.1>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 80044e0:	b082      	sub	sp, #8
 80044e2:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 80044e4:	9b01      	ldr	r3, [sp, #4]
 80044e6:	685b      	ldr	r3, [r3, #4]
 80044e8:	9a01      	ldr	r2, [sp, #4]
 80044ea:	6812      	ldr	r2, [r2, #0]
 80044ec:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 80044ee:	9b01      	ldr	r3, [sp, #4]
 80044f0:	681b      	ldr	r3, [r3, #0]
 80044f2:	9a01      	ldr	r2, [sp, #4]
 80044f4:	6852      	ldr	r2, [r2, #4]
 80044f6:	605a      	str	r2, [r3, #4]
  return p;
 80044f8:	9b01      	ldr	r3, [sp, #4]
}
 80044fa:	4618      	mov	r0, r3
 80044fc:	b002      	add	sp, #8
 80044fe:	4770      	bx	lr

08004500 <chSysLock.lto_priv.6>:
static inline void chSysLock(void) {
 8004500:	b082      	sub	sp, #8
 8004502:	2320      	movs	r3, #32
 8004504:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004506:	9b01      	ldr	r3, [sp, #4]
 8004508:	f383 8811 	msr	BASEPRI, r3
}
 800450c:	bf00      	nop
}
 800450e:	bf00      	nop
}
 8004510:	bf00      	nop
 8004512:	b002      	add	sp, #8
 8004514:	4770      	bx	lr
 8004516:	bf00      	nop
	...

08004520 <chSysUnlock.lto_priv.6>:
static inline void chSysUnlock(void) {
 8004520:	b082      	sub	sp, #8
 8004522:	2300      	movs	r3, #0
 8004524:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004526:	9b01      	ldr	r3, [sp, #4]
 8004528:	f383 8811 	msr	BASEPRI, r3
}
 800452c:	bf00      	nop
}
 800452e:	bf00      	nop
}
 8004530:	bf00      	nop
 8004532:	b002      	add	sp, #8
 8004534:	4770      	bx	lr
 8004536:	bf00      	nop
	...

08004540 <chThdGetSelfX.lto_priv.0>:
  return __sch_get_currthread();
 8004540:	4b01      	ldr	r3, [pc, #4]	; (8004548 <chThdGetSelfX.lto_priv.0+0x8>)
 8004542:	68db      	ldr	r3, [r3, #12]
}
 8004544:	4618      	mov	r0, r3
 8004546:	4770      	bx	lr
 8004548:	20000d90 	.word	0x20000d90
 800454c:	00000000 	.word	0x00000000

08004550 <chThdSleepS>:
static inline void chThdSleepS(sysinterval_t ticks) {
 8004550:	b500      	push	{lr}
 8004552:	b083      	sub	sp, #12
 8004554:	9001      	str	r0, [sp, #4]
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8004556:	9901      	ldr	r1, [sp, #4]
 8004558:	2008      	movs	r0, #8
 800455a:	f7ff fdb9 	bl	80040d0 <chSchGoSleepTimeoutS>
}
 800455e:	bf00      	nop
 8004560:	b003      	add	sp, #12
 8004562:	f85d fb04 	ldr.w	pc, [sp], #4
 8004566:	bf00      	nop
	...

08004570 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8004570:	b500      	push	{lr}
 8004572:	b085      	sub	sp, #20
 8004574:	9001      	str	r0, [sp, #4]
 8004576:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(ch_queue_notempty(&tqp->queue), "empty queue");

  tp = (thread_t *)ch_queue_fifo_remove(&tqp->queue);
 8004578:	9b01      	ldr	r3, [sp, #4]
 800457a:	4618      	mov	r0, r3
 800457c:	f7ff ff98 	bl	80044b0 <ch_queue_fifo_remove.lto_priv.0>
 8004580:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8004582:	9b03      	ldr	r3, [sp, #12]
 8004584:	9a00      	ldr	r2, [sp, #0]
 8004586:	629a      	str	r2, [r3, #40]	; 0x28
  (void) chSchReadyI(tp);
 8004588:	9803      	ldr	r0, [sp, #12]
 800458a:	f7ff fd69 	bl	8004060 <chSchReadyI>
}
 800458e:	bf00      	nop
 8004590:	b005      	add	sp, #20
 8004592:	f85d fb04 	ldr.w	pc, [sp], #4
 8004596:	bf00      	nop
	...

080045a0 <__thd_object_init>:
 * @notapi
 */
thread_t *__thd_object_init(os_instance_t *oip,
                            thread_t *tp,
                            const char *name,
                            tprio_t prio) {
 80045a0:	b500      	push	{lr}
 80045a2:	b085      	sub	sp, #20
 80045a4:	9003      	str	r0, [sp, #12]
 80045a6:	9102      	str	r1, [sp, #8]
 80045a8:	9201      	str	r2, [sp, #4]
 80045aa:	9300      	str	r3, [sp, #0]

  tp->hdr.pqueue.prio   = prio;
 80045ac:	9b02      	ldr	r3, [sp, #8]
 80045ae:	9a00      	ldr	r2, [sp, #0]
 80045b0:	609a      	str	r2, [r3, #8]
  tp->state             = CH_STATE_WTSTART;
 80045b2:	9b02      	ldr	r3, [sp, #8]
 80045b4:	2202      	movs	r2, #2
 80045b6:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  tp->flags             = CH_FLAG_MODE_STATIC;
 80045ba:	9b02      	ldr	r3, [sp, #8]
 80045bc:	2200      	movs	r2, #0
 80045be:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
  tp->owner             = oip;
 80045c2:	9b02      	ldr	r3, [sp, #8]
 80045c4:	9a03      	ldr	r2, [sp, #12]
 80045c6:	619a      	str	r2, [r3, #24]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks             = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio          = prio;
 80045c8:	9b02      	ldr	r3, [sp, #8]
 80045ca:	9a00      	ldr	r2, [sp, #0]
 80045cc:	641a      	str	r2, [r3, #64]	; 0x40
  tp->mtxlist           = NULL;
 80045ce:	9b02      	ldr	r3, [sp, #8]
 80045d0:	2200      	movs	r2, #0
 80045d2:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending          = (eventmask_t)0;
 80045d4:	9b02      	ldr	r3, [sp, #8]
 80045d6:	2200      	movs	r2, #0
 80045d8:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time              = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
 80045da:	9b02      	ldr	r3, [sp, #8]
 80045dc:	2201      	movs	r2, #1
 80045de:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
  tp->name              = name;
 80045e2:	9b02      	ldr	r3, [sp, #8]
 80045e4:	9a01      	ldr	r2, [sp, #4]
 80045e6:	61da      	str	r2, [r3, #28]
  REG_INSERT(oip, tp);
 80045e8:	9b03      	ldr	r3, [sp, #12]
 80045ea:	f103 0228 	add.w	r2, r3, #40	; 0x28
 80045ee:	9b02      	ldr	r3, [sp, #8]
 80045f0:	3310      	adds	r3, #16
 80045f2:	4619      	mov	r1, r3
 80045f4:	4610      	mov	r0, r2
 80045f6:	f7ff ff43 	bl	8004480 <ch_queue_insert.lto_priv.0>
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  ch_list_init(&tp->waiting);
 80045fa:	9b02      	ldr	r3, [sp, #8]
 80045fc:	332c      	adds	r3, #44	; 0x2c
 80045fe:	4618      	mov	r0, r3
 8004600:	f7ff fef6 	bl	80043f0 <ch_list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
 8004604:	9b02      	ldr	r3, [sp, #8]
 8004606:	3330      	adds	r3, #48	; 0x30
 8004608:	4618      	mov	r0, r3
 800460a:	f7ff ff19 	bl	8004440 <ch_queue_init.lto_priv.3>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 800460e:	9b02      	ldr	r3, [sp, #8]
}
 8004610:	4618      	mov	r0, r3
 8004612:	b005      	add	sp, #20
 8004614:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004620 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8004620:	b500      	push	{lr}
 8004622:	b085      	sub	sp, #20
 8004624:	9001      	str	r0, [sp, #4]
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8004626:	9b01      	ldr	r3, [sp, #4]
 8004628:	689b      	ldr	r3, [r3, #8]
 800462a:	3b48      	subs	r3, #72	; 0x48
 800462c:	9303      	str	r3, [sp, #12]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 800462e:	9b01      	ldr	r3, [sp, #4]
 8004630:	685a      	ldr	r2, [r3, #4]
 8004632:	9b03      	ldr	r3, [sp, #12]
 8004634:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8004636:	9b03      	ldr	r3, [sp, #12]
 8004638:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800463c:	9b03      	ldr	r3, [sp, #12]
 800463e:	60da      	str	r2, [r3, #12]
 8004640:	9b01      	ldr	r3, [sp, #4]
 8004642:	691a      	ldr	r2, [r3, #16]
 8004644:	9b03      	ldr	r3, [sp, #12]
 8004646:	68db      	ldr	r3, [r3, #12]
 8004648:	601a      	str	r2, [r3, #0]
 800464a:	9b01      	ldr	r3, [sp, #4]
 800464c:	695a      	ldr	r2, [r3, #20]
 800464e:	9b03      	ldr	r3, [sp, #12]
 8004650:	68db      	ldr	r3, [r3, #12]
 8004652:	605a      	str	r2, [r3, #4]
 8004654:	9b03      	ldr	r3, [sp, #12]
 8004656:	68db      	ldr	r3, [r3, #12]
 8004658:	4a07      	ldr	r2, [pc, #28]	; (8004678 <chThdCreateSuspendedI+0x58>)
 800465a:	621a      	str	r2, [r3, #32]
  if (tdp->instance != NULL) {
    return __thd_object_init(tdp->instance, tp, tdp->name, tdp->prio);
  }
#endif

  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 800465c:	9b01      	ldr	r3, [sp, #4]
 800465e:	681a      	ldr	r2, [r3, #0]
 8004660:	9b01      	ldr	r3, [sp, #4]
 8004662:	68db      	ldr	r3, [r3, #12]
 8004664:	9903      	ldr	r1, [sp, #12]
 8004666:	4805      	ldr	r0, [pc, #20]	; (800467c <chThdCreateSuspendedI+0x5c>)
 8004668:	f7ff ff9a 	bl	80045a0 <__thd_object_init>
 800466c:	4603      	mov	r3, r0
 800466e:	bf00      	nop
}
 8004670:	4618      	mov	r0, r3
 8004672:	b005      	add	sp, #20
 8004674:	f85d fb04 	ldr.w	pc, [sp], #4
 8004678:	080002f1 	.word	0x080002f1
 800467c:	20000d90 	.word	0x20000d90

08004680 <chThdCreateI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(const thread_descriptor_t *tdp) {
 8004680:	b500      	push	{lr}
 8004682:	b083      	sub	sp, #12
 8004684:	9001      	str	r0, [sp, #4]

  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8004686:	9801      	ldr	r0, [sp, #4]
 8004688:	f7ff ffca 	bl	8004620 <chThdCreateSuspendedI>
 800468c:	4603      	mov	r3, r0
 800468e:	4618      	mov	r0, r3
 8004690:	f7ff fce6 	bl	8004060 <chSchReadyI>
 8004694:	4603      	mov	r3, r0
}
 8004696:	4618      	mov	r0, r3
 8004698:	b003      	add	sp, #12
 800469a:	f85d fb04 	ldr.w	pc, [sp], #4
 800469e:	bf00      	nop

080046a0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 80046a0:	b500      	push	{lr}
 80046a2:	b087      	sub	sp, #28
 80046a4:	9003      	str	r0, [sp, #12]
 80046a6:	9102      	str	r1, [sp, #8]
 80046a8:	9201      	str	r2, [sp, #4]
 80046aa:	9300      	str	r3, [sp, #0]
  __thd_memfill((uint8_t *)wsp,
                (uint8_t *)wsp + size,
                CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80046ac:	f7ff ff28 	bl	8004500 <chSysLock.lto_priv.6>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 80046b0:	9b02      	ldr	r3, [sp, #8]
 80046b2:	3b48      	subs	r3, #72	; 0x48
 80046b4:	9a03      	ldr	r2, [sp, #12]
 80046b6:	4413      	add	r3, r2
 80046b8:	9305      	str	r3, [sp, #20]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 80046ba:	9b05      	ldr	r3, [sp, #20]
 80046bc:	9a03      	ldr	r2, [sp, #12]
 80046be:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 80046c0:	9b05      	ldr	r3, [sp, #20]
 80046c2:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 80046c6:	9b05      	ldr	r3, [sp, #20]
 80046c8:	60da      	str	r2, [r3, #12]
 80046ca:	9b05      	ldr	r3, [sp, #20]
 80046cc:	68db      	ldr	r3, [r3, #12]
 80046ce:	9a00      	ldr	r2, [sp, #0]
 80046d0:	601a      	str	r2, [r3, #0]
 80046d2:	9b05      	ldr	r3, [sp, #20]
 80046d4:	68db      	ldr	r3, [r3, #12]
 80046d6:	9a08      	ldr	r2, [sp, #32]
 80046d8:	605a      	str	r2, [r3, #4]
 80046da:	9b05      	ldr	r3, [sp, #20]
 80046dc:	68db      	ldr	r3, [r3, #12]
 80046de:	4a0b      	ldr	r2, [pc, #44]	; (800470c <chThdCreateStatic+0x6c>)
 80046e0:	621a      	str	r2, [r3, #32]

  tp = __thd_object_init(currcore, tp, "noname", prio);
 80046e2:	9b01      	ldr	r3, [sp, #4]
 80046e4:	4a0a      	ldr	r2, [pc, #40]	; (8004710 <chThdCreateStatic+0x70>)
 80046e6:	9905      	ldr	r1, [sp, #20]
 80046e8:	480a      	ldr	r0, [pc, #40]	; (8004714 <chThdCreateStatic+0x74>)
 80046ea:	f7ff ff59 	bl	80045a0 <__thd_object_init>
 80046ee:	9005      	str	r0, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 80046f0:	2100      	movs	r1, #0
 80046f2:	9805      	ldr	r0, [sp, #20]
 80046f4:	f7ff fd24 	bl	8004140 <chSchWakeupS>
  chSysUnlock();
 80046f8:	f7ff ff12 	bl	8004520 <chSysUnlock.lto_priv.6>

  return tp;
 80046fc:	9b05      	ldr	r3, [sp, #20]
 80046fe:	bf00      	nop
 8004700:	bf00      	nop
}
 8004702:	4618      	mov	r0, r3
 8004704:	b007      	add	sp, #28
 8004706:	f85d fb04 	ldr.w	pc, [sp], #4
 800470a:	bf00      	nop
 800470c:	080002f1 	.word	0x080002f1
 8004710:	08007000 	.word	0x08007000
 8004714:	20000d90 	.word	0x20000d90
	...

08004720 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8004720:	b500      	push	{lr}
 8004722:	b083      	sub	sp, #12
 8004724:	9001      	str	r0, [sp, #4]

  chSysLock();
 8004726:	f7ff feeb 	bl	8004500 <chSysLock.lto_priv.6>
  chThdExitS(msg);
 800472a:	9801      	ldr	r0, [sp, #4]
 800472c:	f000 f808 	bl	8004740 <chThdExitS>
  /* The thread never returns here.*/
}
 8004730:	bf00      	nop
 8004732:	b003      	add	sp, #12
 8004734:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004740 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8004740:	b500      	push	{lr}
 8004742:	b085      	sub	sp, #20
 8004744:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8004746:	f7ff fefb 	bl	8004540 <chThdGetSelfX.lto_priv.0>
 800474a:	9003      	str	r0, [sp, #12]

  /* Storing exit message.*/
  currtp->u.exitcode = msg;
 800474c:	9b03      	ldr	r3, [sp, #12]
 800474e:	9a01      	ldr	r2, [sp, #4]
 8004750:	629a      	str	r2, [r3, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8004752:	e008      	b.n	8004766 <chThdExitS+0x26>
    (void) chSchReadyI((thread_t *)ch_list_unlink(&currtp->waiting));
 8004754:	9b03      	ldr	r3, [sp, #12]
 8004756:	332c      	adds	r3, #44	; 0x2c
 8004758:	4618      	mov	r0, r3
 800475a:	f7ff fe61 	bl	8004420 <ch_list_unlink>
 800475e:	4603      	mov	r3, r0
 8004760:	4618      	mov	r0, r3
 8004762:	f7ff fc7d 	bl	8004060 <chSchReadyI>
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8004766:	9b03      	ldr	r3, [sp, #12]
 8004768:	332c      	adds	r3, #44	; 0x2c
 800476a:	4618      	mov	r0, r3
 800476c:	f7ff fe48 	bl	8004400 <ch_list_notempty>
 8004770:	4603      	mov	r3, r0
 8004772:	2b00      	cmp	r3, #0
 8004774:	d1ee      	bne.n	8004754 <chThdExitS+0x14>
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8004776:	9b03      	ldr	r3, [sp, #12]
 8004778:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 800477c:	2b00      	cmp	r3, #0
 800477e:	bf0c      	ite	eq
 8004780:	2301      	moveq	r3, #1
 8004782:	2300      	movne	r3, #0
 8004784:	b2db      	uxtb	r3, r3
 8004786:	2b00      	cmp	r3, #0
 8004788:	d010      	beq.n	80047ac <chThdExitS+0x6c>
#if CH_CFG_USE_DYNAMIC == TRUE
    /* Static threads are immediately removed from the registry because there
       is no memory to recover.*/
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 800478a:	9b03      	ldr	r3, [sp, #12]
 800478c:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8004790:	f003 0303 	and.w	r3, r3, #3
 8004794:	2b00      	cmp	r3, #0
 8004796:	bf0c      	ite	eq
 8004798:	2301      	moveq	r3, #1
 800479a:	2300      	movne	r3, #0
 800479c:	b2db      	uxtb	r3, r3
 800479e:	2b00      	cmp	r3, #0
 80047a0:	d004      	beq.n	80047ac <chThdExitS+0x6c>
      REG_REMOVE(currtp);
 80047a2:	9b03      	ldr	r3, [sp, #12]
 80047a4:	3310      	adds	r3, #16
 80047a6:	4618      	mov	r0, r3
 80047a8:	f7ff fe9a 	bl	80044e0 <ch_queue_dequeue.lto_priv.1>
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 80047ac:	200f      	movs	r0, #15
 80047ae:	f7ff fc67 	bl	8004080 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 80047b2:	bf00      	nop
 80047b4:	b005      	add	sp, #20
 80047b6:	f85d fb04 	ldr.w	pc, [sp], #4
 80047ba:	bf00      	nop
 80047bc:	0000      	movs	r0, r0
	...

080047c0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 80047c0:	b500      	push	{lr}
 80047c2:	b083      	sub	sp, #12
 80047c4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80047c6:	f7ff fe9b 	bl	8004500 <chSysLock.lto_priv.6>
  chThdSleepS(time);
 80047ca:	9801      	ldr	r0, [sp, #4]
 80047cc:	f7ff fec0 	bl	8004550 <chThdSleepS>
  chSysUnlock();
 80047d0:	f7ff fea6 	bl	8004520 <chSysUnlock.lto_priv.6>
}
 80047d4:	bf00      	nop
 80047d6:	b003      	add	sp, #12
 80047d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80047dc:	0000      	movs	r0, r0
	...

080047e0 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 80047e0:	b500      	push	{lr}
 80047e2:	b085      	sub	sp, #20
 80047e4:	9001      	str	r0, [sp, #4]
  thread_t *tp = chThdGetSelfX();
 80047e6:	f7ff feab 	bl	8004540 <chThdGetSelfX.lto_priv.0>
 80047ea:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 80047ec:	9b01      	ldr	r3, [sp, #4]
 80047ee:	9a03      	ldr	r2, [sp, #12]
 80047f0:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 80047f2:	9b03      	ldr	r3, [sp, #12]
 80047f4:	9a01      	ldr	r2, [sp, #4]
 80047f6:	629a      	str	r2, [r3, #40]	; 0x28
  chSchGoSleepS(CH_STATE_SUSPENDED);
 80047f8:	2003      	movs	r0, #3
 80047fa:	f7ff fc41 	bl	8004080 <chSchGoSleepS>

  return chThdGetSelfX()->u.rdymsg;
 80047fe:	f7ff fe9f 	bl	8004540 <chThdGetSelfX.lto_priv.0>
 8004802:	4603      	mov	r3, r0
 8004804:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
 8004806:	4618      	mov	r0, r3
 8004808:	b005      	add	sp, #20
 800480a:	f85d fb04 	ldr.w	pc, [sp], #4
 800480e:	bf00      	nop

08004810 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8004810:	b500      	push	{lr}
 8004812:	b085      	sub	sp, #20
 8004814:	9001      	str	r0, [sp, #4]
 8004816:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8004818:	9b01      	ldr	r3, [sp, #4]
 800481a:	681b      	ldr	r3, [r3, #0]
 800481c:	2b00      	cmp	r3, #0
 800481e:	d00b      	beq.n	8004838 <chThdResumeI+0x28>
    thread_t *tp = *trp;
 8004820:	9b01      	ldr	r3, [sp, #4]
 8004822:	681b      	ldr	r3, [r3, #0]
 8004824:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8004826:	9b01      	ldr	r3, [sp, #4]
 8004828:	2200      	movs	r2, #0
 800482a:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 800482c:	9b03      	ldr	r3, [sp, #12]
 800482e:	9a00      	ldr	r2, [sp, #0]
 8004830:	629a      	str	r2, [r3, #40]	; 0x28
    (void) chSchReadyI(tp);
 8004832:	9803      	ldr	r0, [sp, #12]
 8004834:	f7ff fc14 	bl	8004060 <chSchReadyI>
  }
}
 8004838:	bf00      	nop
 800483a:	b005      	add	sp, #20
 800483c:	f85d fb04 	ldr.w	pc, [sp], #4

08004840 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8004840:	b500      	push	{lr}
 8004842:	b085      	sub	sp, #20
 8004844:	9001      	str	r0, [sp, #4]
 8004846:	9100      	str	r1, [sp, #0]
  thread_t *currtp = chThdGetSelfX();
 8004848:	f7ff fe7a 	bl	8004540 <chThdGetSelfX.lto_priv.0>
 800484c:	9003      	str	r0, [sp, #12]

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 800484e:	9b00      	ldr	r3, [sp, #0]
 8004850:	2b00      	cmp	r3, #0
 8004852:	bf0c      	ite	eq
 8004854:	2301      	moveq	r3, #1
 8004856:	2300      	movne	r3, #0
 8004858:	b2db      	uxtb	r3, r3
 800485a:	2b00      	cmp	r3, #0
 800485c:	d002      	beq.n	8004864 <chThdEnqueueTimeoutS+0x24>
    return MSG_TIMEOUT;
 800485e:	f04f 33ff 	mov.w	r3, #4294967295
 8004862:	e009      	b.n	8004878 <chThdEnqueueTimeoutS+0x38>
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);
 8004864:	9b01      	ldr	r3, [sp, #4]
 8004866:	9903      	ldr	r1, [sp, #12]
 8004868:	4618      	mov	r0, r3
 800486a:	f7ff fe09 	bl	8004480 <ch_queue_insert.lto_priv.0>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800486e:	9900      	ldr	r1, [sp, #0]
 8004870:	2004      	movs	r0, #4
 8004872:	f7ff fc2d 	bl	80040d0 <chSchGoSleepTimeoutS>
 8004876:	4603      	mov	r3, r0
}
 8004878:	4618      	mov	r0, r3
 800487a:	b005      	add	sp, #20
 800487c:	f85d fb04 	ldr.w	pc, [sp], #4

08004880 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8004880:	b500      	push	{lr}
 8004882:	b083      	sub	sp, #12
 8004884:	9001      	str	r0, [sp, #4]
 8004886:	9100      	str	r1, [sp, #0]

  if (ch_queue_notempty(&tqp->queue)) {
 8004888:	9b01      	ldr	r3, [sp, #4]
 800488a:	4618      	mov	r0, r3
 800488c:	f7ff fde8 	bl	8004460 <ch_queue_notempty.lto_priv.0>
 8004890:	4603      	mov	r3, r0
 8004892:	2b00      	cmp	r3, #0
 8004894:	d003      	beq.n	800489e <chThdDequeueNextI+0x1e>
    chThdDoDequeueNextI(tqp, msg);
 8004896:	9900      	ldr	r1, [sp, #0]
 8004898:	9801      	ldr	r0, [sp, #4]
 800489a:	f7ff fe69 	bl	8004570 <chThdDoDequeueNextI>
  }
}
 800489e:	bf00      	nop
 80048a0:	b003      	add	sp, #12
 80048a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80048a6:	bf00      	nop
	...

080048b0 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 80048b0:	b4f0      	push	{r4, r5, r6, r7}
 80048b2:	b084      	sub	sp, #16
 80048b4:	9003      	str	r0, [sp, #12]
 80048b6:	9102      	str	r1, [sp, #8]
 80048b8:	9201      	str	r2, [sp, #4]

  tmp->n++;
 80048ba:	9b03      	ldr	r3, [sp, #12]
 80048bc:	68db      	ldr	r3, [r3, #12]
 80048be:	1c5a      	adds	r2, r3, #1
 80048c0:	9b03      	ldr	r3, [sp, #12]
 80048c2:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 80048c4:	9b03      	ldr	r3, [sp, #12]
 80048c6:	689b      	ldr	r3, [r3, #8]
 80048c8:	9a02      	ldr	r2, [sp, #8]
 80048ca:	1ad2      	subs	r2, r2, r3
 80048cc:	9b01      	ldr	r3, [sp, #4]
 80048ce:	1ad2      	subs	r2, r2, r3
 80048d0:	9b03      	ldr	r3, [sp, #12]
 80048d2:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80048d4:	9b03      	ldr	r3, [sp, #12]
 80048d6:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80048da:	9903      	ldr	r1, [sp, #12]
 80048dc:	6889      	ldr	r1, [r1, #8]
 80048de:	2000      	movs	r0, #0
 80048e0:	460c      	mov	r4, r1
 80048e2:	4605      	mov	r5, r0
 80048e4:	1916      	adds	r6, r2, r4
 80048e6:	eb43 0705 	adc.w	r7, r3, r5
 80048ea:	9b03      	ldr	r3, [sp, #12]
 80048ec:	e9c3 6704 	strd	r6, r7, [r3, #16]
  if (tmp->last > tmp->worst) {
 80048f0:	9b03      	ldr	r3, [sp, #12]
 80048f2:	689a      	ldr	r2, [r3, #8]
 80048f4:	9b03      	ldr	r3, [sp, #12]
 80048f6:	685b      	ldr	r3, [r3, #4]
 80048f8:	429a      	cmp	r2, r3
 80048fa:	d903      	bls.n	8004904 <tm_stop+0x54>
    tmp->worst = tmp->last;
 80048fc:	9b03      	ldr	r3, [sp, #12]
 80048fe:	689a      	ldr	r2, [r3, #8]
 8004900:	9b03      	ldr	r3, [sp, #12]
 8004902:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8004904:	9b03      	ldr	r3, [sp, #12]
 8004906:	689a      	ldr	r2, [r3, #8]
 8004908:	9b03      	ldr	r3, [sp, #12]
 800490a:	681b      	ldr	r3, [r3, #0]
 800490c:	429a      	cmp	r2, r3
 800490e:	d203      	bcs.n	8004918 <tm_stop+0x68>
    tmp->best = tmp->last;
 8004910:	9b03      	ldr	r3, [sp, #12]
 8004912:	689a      	ldr	r2, [r3, #8]
 8004914:	9b03      	ldr	r3, [sp, #12]
 8004916:	601a      	str	r2, [r3, #0]
  }
}
 8004918:	bf00      	nop
 800491a:	b004      	add	sp, #16
 800491c:	bcf0      	pop	{r4, r5, r6, r7}
 800491e:	4770      	bx	lr

08004920 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 8004920:	b082      	sub	sp, #8
 8004922:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 8004924:	9b01      	ldr	r3, [sp, #4]
 8004926:	f04f 32ff 	mov.w	r2, #4294967295
 800492a:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 800492c:	9b01      	ldr	r3, [sp, #4]
 800492e:	2200      	movs	r2, #0
 8004930:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 8004932:	9b01      	ldr	r3, [sp, #4]
 8004934:	2200      	movs	r2, #0
 8004936:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 8004938:	9b01      	ldr	r3, [sp, #4]
 800493a:	2200      	movs	r2, #0
 800493c:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 800493e:	9901      	ldr	r1, [sp, #4]
 8004940:	f04f 0200 	mov.w	r2, #0
 8004944:	f04f 0300 	mov.w	r3, #0
 8004948:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 800494c:	bf00      	nop
 800494e:	b002      	add	sp, #8
 8004950:	4770      	bx	lr
 8004952:	bf00      	nop
	...

08004960 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 8004960:	b082      	sub	sp, #8
 8004962:	9001      	str	r0, [sp, #4]
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8004964:	4b03      	ldr	r3, [pc, #12]	; (8004974 <chTMStartMeasurementX+0x14>)
 8004966:	685a      	ldr	r2, [r3, #4]

  tmp->last = chSysGetRealtimeCounterX();
 8004968:	9b01      	ldr	r3, [sp, #4]
 800496a:	609a      	str	r2, [r3, #8]
}
 800496c:	bf00      	nop
 800496e:	b002      	add	sp, #8
 8004970:	4770      	bx	lr
 8004972:	bf00      	nop
 8004974:	e0001000 	.word	0xe0001000
	...

08004980 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8004980:	b500      	push	{lr}
 8004982:	b083      	sub	sp, #12
 8004984:	9001      	str	r0, [sp, #4]
 8004986:	4b06      	ldr	r3, [pc, #24]	; (80049a0 <chTMStopMeasurementX+0x20>)
 8004988:	685b      	ldr	r3, [r3, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 800498a:	4a06      	ldr	r2, [pc, #24]	; (80049a4 <chTMStopMeasurementX+0x24>)
 800498c:	6892      	ldr	r2, [r2, #8]
 800498e:	4619      	mov	r1, r3
 8004990:	9801      	ldr	r0, [sp, #4]
 8004992:	f7ff ff8d 	bl	80048b0 <tm_stop>
}
 8004996:	bf00      	nop
 8004998:	b003      	add	sp, #12
 800499a:	f85d fb04 	ldr.w	pc, [sp], #4
 800499e:	bf00      	nop
 80049a0:	e0001000 	.word	0xe0001000
 80049a4:	20000d80 	.word	0x20000d80
	...

080049b0 <ch_queue_init.lto_priv.5>:
static inline void ch_queue_init(ch_queue_t *qp) {
 80049b0:	b082      	sub	sp, #8
 80049b2:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 80049b4:	9b01      	ldr	r3, [sp, #4]
 80049b6:	9a01      	ldr	r2, [sp, #4]
 80049b8:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 80049ba:	9b01      	ldr	r3, [sp, #4]
 80049bc:	9a01      	ldr	r2, [sp, #4]
 80049be:	605a      	str	r2, [r3, #4]
}
 80049c0:	bf00      	nop
 80049c2:	b002      	add	sp, #8
 80049c4:	4770      	bx	lr
 80049c6:	bf00      	nop
	...

080049d0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 80049d0:	b500      	push	{lr}
 80049d2:	b083      	sub	sp, #12
 80049d4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  ch_queue_init(&mp->queue);
 80049d6:	9b01      	ldr	r3, [sp, #4]
 80049d8:	4618      	mov	r0, r3
 80049da:	f7ff ffe9 	bl	80049b0 <ch_queue_init.lto_priv.5>
  mp->owner = NULL;
 80049de:	9b01      	ldr	r3, [sp, #4]
 80049e0:	2200      	movs	r2, #0
 80049e2:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 80049e4:	bf00      	nop
 80049e6:	b003      	add	sp, #12
 80049e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80049ec:	0000      	movs	r0, r0
	...

080049f0 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 80049f0:	b500      	push	{lr}
 80049f2:	b083      	sub	sp, #12
 80049f4:	9001      	str	r0, [sp, #4]
 80049f6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 80049f8:	9b01      	ldr	r3, [sp, #4]
 80049fa:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80049fc:	9b00      	ldr	r3, [sp, #0]
 80049fe:	431a      	orrs	r2, r3
 8004a00:	9b01      	ldr	r3, [sp, #4]
 8004a02:	639a      	str	r2, [r3, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8004a04:	9b01      	ldr	r3, [sp, #4]
 8004a06:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8004a0a:	2b0a      	cmp	r3, #10
 8004a0c:	d106      	bne.n	8004a1c <chEvtSignalI+0x2c>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8004a0e:	9b01      	ldr	r3, [sp, #4]
 8004a10:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004a12:	9b01      	ldr	r3, [sp, #4]
 8004a14:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004a16:	4013      	ands	r3, r2
  if (((tp->state == CH_STATE_WTOREVT) &&
 8004a18:	2b00      	cmp	r3, #0
 8004a1a:	d10d      	bne.n	8004a38 <chEvtSignalI+0x48>
      ((tp->state == CH_STATE_WTANDEVT) &&
 8004a1c:	9b01      	ldr	r3, [sp, #4]
 8004a1e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8004a22:	2b0b      	cmp	r3, #11
 8004a24:	d10e      	bne.n	8004a44 <chEvtSignalI+0x54>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8004a26:	9b01      	ldr	r3, [sp, #4]
 8004a28:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004a2a:	9b01      	ldr	r3, [sp, #4]
 8004a2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004a2e:	401a      	ands	r2, r3
 8004a30:	9b01      	ldr	r3, [sp, #4]
 8004a32:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      ((tp->state == CH_STATE_WTANDEVT) &&
 8004a34:	429a      	cmp	r2, r3
 8004a36:	d105      	bne.n	8004a44 <chEvtSignalI+0x54>
    tp->u.rdymsg = MSG_OK;
 8004a38:	9b01      	ldr	r3, [sp, #4]
 8004a3a:	2200      	movs	r2, #0
 8004a3c:	629a      	str	r2, [r3, #40]	; 0x28
    (void) chSchReadyI(tp);
 8004a3e:	9801      	ldr	r0, [sp, #4]
 8004a40:	f7ff fb0e 	bl	8004060 <chSchReadyI>
  }
}
 8004a44:	bf00      	nop
 8004a46:	b003      	add	sp, #12
 8004a48:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a4c:	0000      	movs	r0, r0
	...

08004a50 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8004a50:	b500      	push	{lr}
 8004a52:	b085      	sub	sp, #20
 8004a54:	9001      	str	r0, [sp, #4]
 8004a56:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 8004a58:	9b01      	ldr	r3, [sp, #4]
 8004a5a:	681b      	ldr	r3, [r3, #0]
 8004a5c:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8004a5e:	e019      	b.n	8004a94 <chEvtBroadcastFlagsI+0x44>
  /*lint -restore*/
    elp->flags |= flags;
 8004a60:	9b03      	ldr	r3, [sp, #12]
 8004a62:	68da      	ldr	r2, [r3, #12]
 8004a64:	9b00      	ldr	r3, [sp, #0]
 8004a66:	431a      	orrs	r2, r3
 8004a68:	9b03      	ldr	r3, [sp, #12]
 8004a6a:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8004a6c:	9b00      	ldr	r3, [sp, #0]
 8004a6e:	2b00      	cmp	r3, #0
 8004a70:	d005      	beq.n	8004a7e <chEvtBroadcastFlagsI+0x2e>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 8004a72:	9b03      	ldr	r3, [sp, #12]
 8004a74:	691a      	ldr	r2, [r3, #16]
 8004a76:	9b00      	ldr	r3, [sp, #0]
 8004a78:	4013      	ands	r3, r2
    if ((flags == (eventflags_t)0) ||
 8004a7a:	2b00      	cmp	r3, #0
 8004a7c:	d007      	beq.n	8004a8e <chEvtBroadcastFlagsI+0x3e>
      chEvtSignalI(elp->listener, elp->events);
 8004a7e:	9b03      	ldr	r3, [sp, #12]
 8004a80:	685a      	ldr	r2, [r3, #4]
 8004a82:	9b03      	ldr	r3, [sp, #12]
 8004a84:	689b      	ldr	r3, [r3, #8]
 8004a86:	4619      	mov	r1, r3
 8004a88:	4610      	mov	r0, r2
 8004a8a:	f7ff ffb1 	bl	80049f0 <chEvtSignalI>
    }
    elp = elp->next;
 8004a8e:	9b03      	ldr	r3, [sp, #12]
 8004a90:	681b      	ldr	r3, [r3, #0]
 8004a92:	9303      	str	r3, [sp, #12]
  while (elp != (event_listener_t *)esp) {
 8004a94:	9a03      	ldr	r2, [sp, #12]
 8004a96:	9b01      	ldr	r3, [sp, #4]
 8004a98:	429a      	cmp	r2, r3
 8004a9a:	d1e1      	bne.n	8004a60 <chEvtBroadcastFlagsI+0x10>
  }
}
 8004a9c:	bf00      	nop
 8004a9e:	bf00      	nop
 8004aa0:	b005      	add	sp, #20
 8004aa2:	f85d fb04 	ldr.w	pc, [sp], #4
 8004aa6:	bf00      	nop
	...

08004ab0 <chSysLock.lto_priv.15>:
static inline void chSysLock(void) {
 8004ab0:	b082      	sub	sp, #8
 8004ab2:	2320      	movs	r3, #32
 8004ab4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004ab6:	9b01      	ldr	r3, [sp, #4]
 8004ab8:	f383 8811 	msr	BASEPRI, r3
}
 8004abc:	bf00      	nop
}
 8004abe:	bf00      	nop
}
 8004ac0:	bf00      	nop
 8004ac2:	b002      	add	sp, #8
 8004ac4:	4770      	bx	lr
 8004ac6:	bf00      	nop
	...

08004ad0 <chSysUnlock.lto_priv.15>:
static inline void chSysUnlock(void) {
 8004ad0:	b082      	sub	sp, #8
 8004ad2:	2300      	movs	r3, #0
 8004ad4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004ad6:	9b01      	ldr	r3, [sp, #4]
 8004ad8:	f383 8811 	msr	BASEPRI, r3
}
 8004adc:	bf00      	nop
}
 8004ade:	bf00      	nop
}
 8004ae0:	bf00      	nop
 8004ae2:	b002      	add	sp, #8
 8004ae4:	4770      	bx	lr
 8004ae6:	bf00      	nop
	...

08004af0 <__core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 8004af0:	4b03      	ldr	r3, [pc, #12]	; (8004b00 <__core_init+0x10>)
 8004af2:	4a04      	ldr	r2, [pc, #16]	; (8004b04 <__core_init+0x14>)
 8004af4:	601a      	str	r2, [r3, #0]
  ch_memcore.topmem  = __heap_end__;
 8004af6:	4b02      	ldr	r3, [pc, #8]	; (8004b00 <__core_init+0x10>)
 8004af8:	4a03      	ldr	r2, [pc, #12]	; (8004b08 <__core_init+0x18>)
 8004afa:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.basemem = &static_heap[0];
  ch_memcore.topmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 8004afc:	bf00      	nop
 8004afe:	4770      	bx	lr
 8004b00:	20000f18 	.word	0x20000f18
 8004b04:	200016c0 	.word	0x200016c0
 8004b08:	20018000 	.word	0x20018000
 8004b0c:	00000000 	.word	0x00000000

08004b10 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 8004b10:	b086      	sub	sp, #24
 8004b12:	9003      	str	r0, [sp, #12]
 8004b14:	9102      	str	r1, [sp, #8]
 8004b16:	9201      	str	r2, [sp, #4]
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8004b18:	4b10      	ldr	r3, [pc, #64]	; (8004b5c <chCoreAllocFromTopI+0x4c>)
 8004b1a:	685a      	ldr	r2, [r3, #4]
 8004b1c:	9b03      	ldr	r3, [sp, #12]
 8004b1e:	425b      	negs	r3, r3
 8004b20:	4413      	add	r3, r2
 8004b22:	461a      	mov	r2, r3
 8004b24:	9b02      	ldr	r3, [sp, #8]
 8004b26:	425b      	negs	r3, r3
 8004b28:	4013      	ands	r3, r2
 8004b2a:	9305      	str	r3, [sp, #20]
  prev = p - offset;
 8004b2c:	9b01      	ldr	r3, [sp, #4]
 8004b2e:	425b      	negs	r3, r3
 8004b30:	9a05      	ldr	r2, [sp, #20]
 8004b32:	4413      	add	r3, r2
 8004b34:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8004b36:	4b09      	ldr	r3, [pc, #36]	; (8004b5c <chCoreAllocFromTopI+0x4c>)
 8004b38:	681b      	ldr	r3, [r3, #0]
 8004b3a:	9a04      	ldr	r2, [sp, #16]
 8004b3c:	429a      	cmp	r2, r3
 8004b3e:	d304      	bcc.n	8004b4a <chCoreAllocFromTopI+0x3a>
 8004b40:	4b06      	ldr	r3, [pc, #24]	; (8004b5c <chCoreAllocFromTopI+0x4c>)
 8004b42:	685b      	ldr	r3, [r3, #4]
 8004b44:	9a04      	ldr	r2, [sp, #16]
 8004b46:	429a      	cmp	r2, r3
 8004b48:	d901      	bls.n	8004b4e <chCoreAllocFromTopI+0x3e>
    return NULL;
 8004b4a:	2300      	movs	r3, #0
 8004b4c:	e003      	b.n	8004b56 <chCoreAllocFromTopI+0x46>
  }

  ch_memcore.topmem = prev;
 8004b4e:	4a03      	ldr	r2, [pc, #12]	; (8004b5c <chCoreAllocFromTopI+0x4c>)
 8004b50:	9b04      	ldr	r3, [sp, #16]
 8004b52:	6053      	str	r3, [r2, #4]

  return p;
 8004b54:	9b05      	ldr	r3, [sp, #20]
}
 8004b56:	4618      	mov	r0, r3
 8004b58:	b006      	add	sp, #24
 8004b5a:	4770      	bx	lr
 8004b5c:	20000f18 	.word	0x20000f18

08004b60 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8004b60:	b500      	push	{lr}
 8004b62:	b087      	sub	sp, #28
 8004b64:	9003      	str	r0, [sp, #12]
 8004b66:	9102      	str	r1, [sp, #8]
 8004b68:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
 8004b6a:	f7ff ffa1 	bl	8004ab0 <chSysLock.lto_priv.15>
  p = chCoreAllocFromTopI(size, align, offset);
 8004b6e:	9a01      	ldr	r2, [sp, #4]
 8004b70:	9902      	ldr	r1, [sp, #8]
 8004b72:	9803      	ldr	r0, [sp, #12]
 8004b74:	f7ff ffcc 	bl	8004b10 <chCoreAllocFromTopI>
 8004b78:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8004b7a:	f7ff ffa9 	bl	8004ad0 <chSysUnlock.lto_priv.15>

  return p;
 8004b7e:	9b05      	ldr	r3, [sp, #20]
}
 8004b80:	4618      	mov	r0, r3
 8004b82:	b007      	add	sp, #28
 8004b84:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004b90 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
 8004b90:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8004b92:	4b07      	ldr	r3, [pc, #28]	; (8004bb0 <__heap_init+0x20>)
 8004b94:	4a07      	ldr	r2, [pc, #28]	; (8004bb4 <__heap_init+0x24>)
 8004b96:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 8004b98:	4b05      	ldr	r3, [pc, #20]	; (8004bb0 <__heap_init+0x20>)
 8004b9a:	2200      	movs	r2, #0
 8004b9c:	605a      	str	r2, [r3, #4]
  H_PAGES(&default_heap.header) = 0;
 8004b9e:	4b04      	ldr	r3, [pc, #16]	; (8004bb0 <__heap_init+0x20>)
 8004ba0:	2200      	movs	r2, #0
 8004ba2:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8004ba4:	4804      	ldr	r0, [pc, #16]	; (8004bb8 <__heap_init+0x28>)
 8004ba6:	f7ff ff13 	bl	80049d0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 8004baa:	bf00      	nop
 8004bac:	bd08      	pop	{r3, pc}
 8004bae:	bf00      	nop
 8004bb0:	20000f20 	.word	0x20000f20
 8004bb4:	08004b61 	.word	0x08004b61
 8004bb8:	20000f2c 	.word	0x20000f2c
 8004bbc:	00000000 	.word	0x00000000

08004bc0 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8004bc0:	b084      	sub	sp, #16
 8004bc2:	9003      	str	r0, [sp, #12]
 8004bc4:	9102      	str	r1, [sp, #8]
 8004bc6:	9201      	str	r2, [sp, #4]
 8004bc8:	9300      	str	r3, [sp, #0]
  chDbgCheck((mp != NULL) &&
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8004bca:	9b03      	ldr	r3, [sp, #12]
 8004bcc:	2200      	movs	r2, #0
 8004bce:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 8004bd0:	9b03      	ldr	r3, [sp, #12]
 8004bd2:	9a02      	ldr	r2, [sp, #8]
 8004bd4:	605a      	str	r2, [r3, #4]
  mp->align = align;
 8004bd6:	9b03      	ldr	r3, [sp, #12]
 8004bd8:	9a01      	ldr	r2, [sp, #4]
 8004bda:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
 8004bdc:	9b03      	ldr	r3, [sp, #12]
 8004bde:	9a00      	ldr	r2, [sp, #0]
 8004be0:	60da      	str	r2, [r3, #12]
}
 8004be2:	bf00      	nop
 8004be4:	b004      	add	sp, #16
 8004be6:	4770      	bx	lr
	...

08004bf0 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8004bf0:	b500      	push	{lr}
 8004bf2:	b083      	sub	sp, #12
 8004bf4:	9001      	str	r0, [sp, #4]
 8004bf6:	9100      	str	r1, [sp, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8004bf8:	2200      	movs	r2, #0
 8004bfa:	9900      	ldr	r1, [sp, #0]
 8004bfc:	9801      	ldr	r0, [sp, #4]
 8004bfe:	f7ff ff87 	bl	8004b10 <chCoreAllocFromTopI>
 8004c02:	4603      	mov	r3, r0
}
 8004c04:	4618      	mov	r0, r3
 8004c06:	b003      	add	sp, #12
 8004c08:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c0c:	0000      	movs	r0, r0
	...

08004c10 <chPoolObjectInit>:
 *
 * @init
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {
 8004c10:	b500      	push	{lr}
 8004c12:	b085      	sub	sp, #20
 8004c14:	9003      	str	r0, [sp, #12]
 8004c16:	9102      	str	r1, [sp, #8]
 8004c18:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 8004c1a:	9b01      	ldr	r3, [sp, #4]
 8004c1c:	2204      	movs	r2, #4
 8004c1e:	9902      	ldr	r1, [sp, #8]
 8004c20:	9803      	ldr	r0, [sp, #12]
 8004c22:	f7ff ffcd 	bl	8004bc0 <chPoolObjectInitAligned>
}
 8004c26:	bf00      	nop
 8004c28:	b005      	add	sp, #20
 8004c2a:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c2e:	bf00      	nop

08004c30 <dyn_list_init>:
    *dp++ = c;
    i--;
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {
 8004c30:	b082      	sub	sp, #8
 8004c32:	9001      	str	r0, [sp, #4]

  dlp->next = (dyn_element_t *)dlp;
 8004c34:	9b01      	ldr	r3, [sp, #4]
 8004c36:	9a01      	ldr	r2, [sp, #4]
 8004c38:	601a      	str	r2, [r3, #0]
}
 8004c3a:	bf00      	nop
 8004c3c:	b002      	add	sp, #8
 8004c3e:	4770      	bx	lr

08004c40 <__factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void __factory_init(void) {
 8004c40:	b508      	push	{r3, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8004c42:	4810      	ldr	r0, [pc, #64]	; (8004c84 <__factory_init+0x44>)
 8004c44:	f7ff fec4 	bl	80049d0 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
 8004c48:	480f      	ldr	r0, [pc, #60]	; (8004c88 <__factory_init+0x48>)
 8004c4a:	f7ff fff1 	bl	8004c30 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
 8004c4e:	4a0f      	ldr	r2, [pc, #60]	; (8004c8c <__factory_init+0x4c>)
 8004c50:	2114      	movs	r1, #20
 8004c52:	480f      	ldr	r0, [pc, #60]	; (8004c90 <__factory_init+0x50>)
 8004c54:	f7ff ffdc 	bl	8004c10 <chPoolObjectInit>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
 8004c58:	480e      	ldr	r0, [pc, #56]	; (8004c94 <__factory_init+0x54>)
 8004c5a:	f7ff ffe9 	bl	8004c30 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
 8004c5e:	480e      	ldr	r0, [pc, #56]	; (8004c98 <__factory_init+0x58>)
 8004c60:	f7ff ffe6 	bl	8004c30 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
 8004c64:	4a09      	ldr	r2, [pc, #36]	; (8004c8c <__factory_init+0x4c>)
 8004c66:	211c      	movs	r1, #28
 8004c68:	480c      	ldr	r0, [pc, #48]	; (8004c9c <__factory_init+0x5c>)
 8004c6a:	f7ff ffd1 	bl	8004c10 <chPoolObjectInit>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
 8004c6e:	480c      	ldr	r0, [pc, #48]	; (8004ca0 <__factory_init+0x60>)
 8004c70:	f7ff ffde 	bl	8004c30 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
 8004c74:	480b      	ldr	r0, [pc, #44]	; (8004ca4 <__factory_init+0x64>)
 8004c76:	f7ff ffdb 	bl	8004c30 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
 8004c7a:	480b      	ldr	r0, [pc, #44]	; (8004ca8 <__factory_init+0x68>)
 8004c7c:	f7ff ffd8 	bl	8004c30 <dyn_list_init>
#endif
}
 8004c80:	bf00      	nop
 8004c82:	bd08      	pop	{r3, pc}
 8004c84:	20000f3c 	.word	0x20000f3c
 8004c88:	20000f4c 	.word	0x20000f4c
 8004c8c:	08004bf1 	.word	0x08004bf1
 8004c90:	20000f50 	.word	0x20000f50
 8004c94:	20000f60 	.word	0x20000f60
 8004c98:	20000f64 	.word	0x20000f64
 8004c9c:	20000f68 	.word	0x20000f68
 8004ca0:	20000f78 	.word	0x20000f78
 8004ca4:	20000f7c 	.word	0x20000f7c
 8004ca8:	20000f80 	.word	0x20000f80
 8004cac:	00000000 	.word	0x00000000

08004cb0 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8004cb0:	b084      	sub	sp, #16
 8004cb2:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8004cb4:	9b01      	ldr	r3, [sp, #4]
 8004cb6:	f003 0307 	and.w	r3, r3, #7
 8004cba:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8004cbc:	4b0b      	ldr	r3, [pc, #44]	; (8004cec <__NVIC_SetPriorityGrouping+0x3c>)
 8004cbe:	68db      	ldr	r3, [r3, #12]
 8004cc0:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8004cc2:	9a02      	ldr	r2, [sp, #8]
 8004cc4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8004cc8:	4013      	ands	r3, r2
 8004cca:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8004ccc:	9b03      	ldr	r3, [sp, #12]
 8004cce:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8004cd0:	9b02      	ldr	r3, [sp, #8]
 8004cd2:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8004cd4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8004cd8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8004cdc:	9302      	str	r3, [sp, #8]
  SCB->AIRCR =  reg_value;
 8004cde:	4a03      	ldr	r2, [pc, #12]	; (8004cec <__NVIC_SetPriorityGrouping+0x3c>)
 8004ce0:	9b02      	ldr	r3, [sp, #8]
 8004ce2:	60d3      	str	r3, [r2, #12]
}
 8004ce4:	bf00      	nop
 8004ce6:	b004      	add	sp, #16
 8004ce8:	4770      	bx	lr
 8004cea:	bf00      	nop
 8004cec:	e000ed00 	.word	0xe000ed00

08004cf0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8004cf0:	b082      	sub	sp, #8
 8004cf2:	4603      	mov	r3, r0
 8004cf4:	9100      	str	r1, [sp, #0]
 8004cf6:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
 8004cfa:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8004cfe:	2b00      	cmp	r3, #0
 8004d00:	db0a      	blt.n	8004d18 <__NVIC_SetPriority+0x28>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004d02:	9b00      	ldr	r3, [sp, #0]
 8004d04:	b2da      	uxtb	r2, r3
 8004d06:	490c      	ldr	r1, [pc, #48]	; (8004d38 <__NVIC_SetPriority+0x48>)
 8004d08:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8004d0c:	0112      	lsls	r2, r2, #4
 8004d0e:	b2d2      	uxtb	r2, r2
 8004d10:	440b      	add	r3, r1
 8004d12:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8004d16:	e00b      	b.n	8004d30 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004d18:	9b00      	ldr	r3, [sp, #0]
 8004d1a:	b2da      	uxtb	r2, r3
 8004d1c:	4907      	ldr	r1, [pc, #28]	; (8004d3c <__NVIC_SetPriority+0x4c>)
 8004d1e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004d22:	f003 030f 	and.w	r3, r3, #15
 8004d26:	3b04      	subs	r3, #4
 8004d28:	0112      	lsls	r2, r2, #4
 8004d2a:	b2d2      	uxtb	r2, r2
 8004d2c:	440b      	add	r3, r1
 8004d2e:	761a      	strb	r2, [r3, #24]
}
 8004d30:	bf00      	nop
 8004d32:	b002      	add	sp, #8
 8004d34:	4770      	bx	lr
 8004d36:	bf00      	nop
 8004d38:	e000e100 	.word	0xe000e100
 8004d3c:	e000ed00 	.word	0xe000ed00

08004d40 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch and, optionally, for system calls.
 * @note    The SVC vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8004d40:	b084      	sub	sp, #16
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004d42:	f3ef 8309 	mrs	r3, PSP
 8004d46:	9300      	str	r3, [sp, #0]
  return(result);
 8004d48:	9b00      	ldr	r3, [sp, #0]
/*lint -restore*/
  uint32_t psp = __get_PSP();
 8004d4a:	9303      	str	r3, [sp, #12]
    /* From privileged mode, it is used for context discarding in the
       preemption code.*/

    /* Unstacking procedure, discarding the current exception context and
       positioning the stack to point to the real one.*/
    psp += sizeof (struct port_extctx);
 8004d4c:	9b03      	ldr	r3, [sp, #12]
 8004d4e:	3320      	adds	r3, #32
 8004d50:	9303      	str	r3, [sp, #12]
 8004d52:	9b03      	ldr	r3, [sp, #12]
 8004d54:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004d56:	9b01      	ldr	r3, [sp, #4]
 8004d58:	f383 8809 	msr	PSP, r3
}
 8004d5c:	bf00      	nop
 8004d5e:	2300      	movs	r3, #0
 8004d60:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004d62:	9b02      	ldr	r3, [sp, #8]
 8004d64:	f383 8811 	msr	BASEPRI, r3
}
 8004d68:	bf00      	nop
 8004d6a:	bf00      	nop
}
 8004d6c:	bf00      	nop
#endif

    /* Restoring the normal interrupts status.*/
    port_unlock_from_isr();
  }
}
 8004d6e:	bf00      	nop
 8004d70:	b004      	add	sp, #16
 8004d72:	4770      	bx	lr
	...

08004d80 <port_init>:
 *
 * @param[in, out] oip  pointer to the @p os_instance_t structure
 *
 * @notapi
 */
void port_init(os_instance_t *oip) {
 8004d80:	b500      	push	{lr}
 8004d82:	b085      	sub	sp, #20
 8004d84:	9001      	str	r0, [sp, #4]
 8004d86:	2320      	movs	r3, #32
 8004d88:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004d8a:	9b03      	ldr	r3, [sp, #12]
 8004d8c:	f383 8811 	msr	BASEPRI, r3
}
 8004d90:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
 8004d92:	b662      	cpsie	i
}
 8004d94:	bf00      	nop
}
 8004d96:	bf00      	nop

  /* Starting in a known IRQ configuration.*/
  port_suspend();

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8004d98:	2003      	movs	r0, #3
 8004d9a:	f7ff ff89 	bl	8004cb0 <__NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8004d9e:	4b0d      	ldr	r3, [pc, #52]	; (8004dd4 <port_init+0x54>)
 8004da0:	68db      	ldr	r3, [r3, #12]
 8004da2:	4a0c      	ldr	r2, [pc, #48]	; (8004dd4 <port_init+0x54>)
 8004da4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8004da8:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8004daa:	4b0b      	ldr	r3, [pc, #44]	; (8004dd8 <port_init+0x58>)
 8004dac:	681b      	ldr	r3, [r3, #0]
 8004dae:	4a0a      	ldr	r2, [pc, #40]	; (8004dd8 <port_init+0x58>)
 8004db0:	f043 0301 	orr.w	r3, r3, #1
 8004db4:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8004db6:	2101      	movs	r1, #1
 8004db8:	f06f 0004 	mvn.w	r0, #4
 8004dbc:	f7ff ff98 	bl	8004cf0 <__NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8004dc0:	2102      	movs	r1, #2
 8004dc2:	f06f 0001 	mvn.w	r0, #1
 8004dc6:	f7ff ff93 	bl	8004cf0 <__NVIC_SetPriority>

#if PORT_USE_SYSCALL == TRUE
  /* MPU is enabled.*/
  mpuEnable(MPU_CTRL_PRIVDEFENA);
#endif
}
 8004dca:	bf00      	nop
 8004dcc:	b005      	add	sp, #20
 8004dce:	f85d fb04 	ldr.w	pc, [sp], #4
 8004dd2:	bf00      	nop
 8004dd4:	e000edf0 	.word	0xe000edf0
 8004dd8:	e0001000 	.word	0xe0001000
 8004ddc:	00000000 	.word	0x00000000

08004de0 <__port_irq_epilogue>:
#endif

/**
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {
 8004de0:	b500      	push	{lr}
 8004de2:	b087      	sub	sp, #28
 8004de4:	2320      	movs	r3, #32
 8004de6:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004de8:	9b03      	ldr	r3, [sp, #12]
 8004dea:	f383 8811 	msr	BASEPRI, r3
}
 8004dee:	bf00      	nop
}
 8004df0:	bf00      	nop
}
 8004df2:	bf00      	nop

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8004df4:	4b18      	ldr	r3, [pc, #96]	; (8004e58 <__port_irq_epilogue+0x78>)
 8004df6:	685b      	ldr	r3, [r3, #4]
 8004df8:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8004dfc:	2b00      	cmp	r3, #0
 8004dfe:	d020      	beq.n	8004e42 <__port_irq_epilogue+0x62>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004e00:	f3ef 8309 	mrs	r3, PSP
 8004e04:	9301      	str	r3, [sp, #4]
  return(result);
 8004e06:	9b01      	ldr	r3, [sp, #4]
        lctxp->control = control;
        lctxp->ectxp   = (struct port_extctx *)psp;
      }
    }
#else
    s_psp = __get_PSP();
 8004e08:	9305      	str	r3, [sp, #20]
#endif

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    s_psp -= sizeof (struct port_extctx);
 8004e0a:	9b05      	ldr	r3, [sp, #20]
 8004e0c:	3b20      	subs	r3, #32
 8004e0e:	9305      	str	r3, [sp, #20]

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)s_psp;
 8004e10:	9b05      	ldr	r3, [sp, #20]
 8004e12:	9304      	str	r3, [sp, #16]

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8004e14:	9b04      	ldr	r3, [sp, #16]
 8004e16:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8004e1a:	61da      	str	r2, [r3, #28]
 8004e1c:	9b05      	ldr	r3, [sp, #20]
 8004e1e:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004e20:	9b02      	ldr	r3, [sp, #8]
 8004e22:	f383 8809 	msr	PSP, r3
}
 8004e26:	bf00      	nop
    /* Writing back the modified S-PSP value.*/
    __set_PSP(s_psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8004e28:	f7ff f9ba 	bl	80041a0 <chSchIsPreemptionRequired>
 8004e2c:	4603      	mov	r3, r0
 8004e2e:	2b00      	cmp	r3, #0
 8004e30:	d003      	beq.n	8004e3a <__port_irq_epilogue+0x5a>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 8004e32:	4a0a      	ldr	r2, [pc, #40]	; (8004e5c <__port_irq_epilogue+0x7c>)
 8004e34:	9b04      	ldr	r3, [sp, #16]
 8004e36:	619a      	str	r2, [r3, #24]
      ectxp->pc = (uint32_t)__port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8004e38:	e00b      	b.n	8004e52 <__port_irq_epilogue+0x72>
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 8004e3a:	4a09      	ldr	r2, [pc, #36]	; (8004e60 <__port_irq_epilogue+0x80>)
 8004e3c:	9b04      	ldr	r3, [sp, #16]
 8004e3e:	619a      	str	r2, [r3, #24]
    return;
 8004e40:	e007      	b.n	8004e52 <__port_irq_epilogue+0x72>
 8004e42:	2300      	movs	r3, #0
 8004e44:	9300      	str	r3, [sp, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004e46:	9b00      	ldr	r3, [sp, #0]
 8004e48:	f383 8811 	msr	BASEPRI, r3
}
 8004e4c:	bf00      	nop
}
 8004e4e:	bf00      	nop
}
 8004e50:	bf00      	nop
  }
  port_unlock_from_isr();
}
 8004e52:	b007      	add	sp, #28
 8004e54:	f85d fb04 	ldr.w	pc, [sp], #4
 8004e58:	e000ed00 	.word	0xe000ed00
 8004e5c:	08000303 	.word	0x08000303
 8004e60:	08000306 	.word	0x08000306
	...

08004e70 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8004e70:	b088      	sub	sp, #32
 8004e72:	9003      	str	r0, [sp, #12]
 8004e74:	9102      	str	r1, [sp, #8]
 8004e76:	9201      	str	r2, [sp, #4]
 8004e78:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 8004e7a:	9b02      	ldr	r3, [sp, #8]
 8004e7c:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 8004e7e:	9b00      	ldr	r3, [sp, #0]
 8004e80:	2b00      	cmp	r3, #0
 8004e82:	d102      	bne.n	8004e8a <long_to_string_with_divisor+0x1a>
    ll = num;
 8004e84:	9b02      	ldr	r3, [sp, #8]
 8004e86:	9304      	str	r3, [sp, #16]
 8004e88:	e001      	b.n	8004e8e <long_to_string_with_divisor+0x1e>
  } else {
    ll = divisor;
 8004e8a:	9b00      	ldr	r3, [sp, #0]
 8004e8c:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 8004e8e:	9b03      	ldr	r3, [sp, #12]
 8004e90:	330b      	adds	r3, #11
 8004e92:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 8004e94:	9b05      	ldr	r3, [sp, #20]
 8004e96:	9a01      	ldr	r2, [sp, #4]
 8004e98:	fbb3 f2f2 	udiv	r2, r3, r2
 8004e9c:	9901      	ldr	r1, [sp, #4]
 8004e9e:	fb01 f202 	mul.w	r2, r1, r2
 8004ea2:	1a9b      	subs	r3, r3, r2
 8004ea4:	9307      	str	r3, [sp, #28]
    i += '0';
 8004ea6:	9b07      	ldr	r3, [sp, #28]
 8004ea8:	3330      	adds	r3, #48	; 0x30
 8004eaa:	9307      	str	r3, [sp, #28]
    if (i > '9') {
 8004eac:	9b07      	ldr	r3, [sp, #28]
 8004eae:	2b39      	cmp	r3, #57	; 0x39
 8004eb0:	dd02      	ble.n	8004eb8 <long_to_string_with_divisor+0x48>
      i += 'A' - '0' - 10;
 8004eb2:	9b07      	ldr	r3, [sp, #28]
 8004eb4:	3307      	adds	r3, #7
 8004eb6:	9307      	str	r3, [sp, #28]
    }
    *--q = i;
 8004eb8:	9b06      	ldr	r3, [sp, #24]
 8004eba:	3b01      	subs	r3, #1
 8004ebc:	9306      	str	r3, [sp, #24]
 8004ebe:	9b07      	ldr	r3, [sp, #28]
 8004ec0:	b2da      	uxtb	r2, r3
 8004ec2:	9b06      	ldr	r3, [sp, #24]
 8004ec4:	701a      	strb	r2, [r3, #0]
    l /= radix;
 8004ec6:	9a05      	ldr	r2, [sp, #20]
 8004ec8:	9b01      	ldr	r3, [sp, #4]
 8004eca:	fbb2 f3f3 	udiv	r3, r2, r3
 8004ece:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 8004ed0:	9a04      	ldr	r2, [sp, #16]
 8004ed2:	9b01      	ldr	r3, [sp, #4]
 8004ed4:	fbb2 f3f3 	udiv	r3, r2, r3
 8004ed8:	9304      	str	r3, [sp, #16]
 8004eda:	9b04      	ldr	r3, [sp, #16]
 8004edc:	2b00      	cmp	r3, #0
 8004ede:	d1d9      	bne.n	8004e94 <long_to_string_with_divisor+0x24>

  i = (int)(p + MAX_FILLER - q);
 8004ee0:	9b03      	ldr	r3, [sp, #12]
 8004ee2:	f103 020b 	add.w	r2, r3, #11
 8004ee6:	9b06      	ldr	r3, [sp, #24]
 8004ee8:	1ad3      	subs	r3, r2, r3
 8004eea:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 8004eec:	9a06      	ldr	r2, [sp, #24]
 8004eee:	1c53      	adds	r3, r2, #1
 8004ef0:	9306      	str	r3, [sp, #24]
 8004ef2:	9b03      	ldr	r3, [sp, #12]
 8004ef4:	1c59      	adds	r1, r3, #1
 8004ef6:	9103      	str	r1, [sp, #12]
 8004ef8:	7812      	ldrb	r2, [r2, #0]
 8004efa:	701a      	strb	r2, [r3, #0]
  while (--i);
 8004efc:	9b07      	ldr	r3, [sp, #28]
 8004efe:	3b01      	subs	r3, #1
 8004f00:	9307      	str	r3, [sp, #28]
 8004f02:	9b07      	ldr	r3, [sp, #28]
 8004f04:	2b00      	cmp	r3, #0
 8004f06:	d1f1      	bne.n	8004eec <long_to_string_with_divisor+0x7c>

  return p;
 8004f08:	9b03      	ldr	r3, [sp, #12]
}
 8004f0a:	4618      	mov	r0, r3
 8004f0c:	b008      	add	sp, #32
 8004f0e:	4770      	bx	lr

08004f10 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8004f10:	b500      	push	{lr}
 8004f12:	b085      	sub	sp, #20
 8004f14:	9003      	str	r0, [sp, #12]
 8004f16:	9102      	str	r1, [sp, #8]
 8004f18:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 8004f1a:	2300      	movs	r3, #0
 8004f1c:	9a01      	ldr	r2, [sp, #4]
 8004f1e:	9902      	ldr	r1, [sp, #8]
 8004f20:	9803      	ldr	r0, [sp, #12]
 8004f22:	f7ff ffa5 	bl	8004e70 <long_to_string_with_divisor>
 8004f26:	4603      	mov	r3, r0
}
 8004f28:	4618      	mov	r0, r3
 8004f2a:	b005      	add	sp, #20
 8004f2c:	f85d fb04 	ldr.w	pc, [sp], #4

08004f30 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8004f30:	b500      	push	{lr}
 8004f32:	b091      	sub	sp, #68	; 0x44
 8004f34:	9003      	str	r0, [sp, #12]
 8004f36:	9102      	str	r1, [sp, #8]
 8004f38:	9201      	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8004f3a:	2300      	movs	r3, #0
 8004f3c:	9309      	str	r3, [sp, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8004f3e:	9b02      	ldr	r3, [sp, #8]
 8004f40:	1c5a      	adds	r2, r3, #1
 8004f42:	9202      	str	r2, [sp, #8]
 8004f44:	781b      	ldrb	r3, [r3, #0]
 8004f46:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    if (c == 0) {
 8004f4a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8004f4e:	2b00      	cmp	r3, #0
 8004f50:	d101      	bne.n	8004f56 <chvprintf+0x26>
      return n;
 8004f52:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004f54:	e24d      	b.n	80053f2 <chvprintf+0x4c2>
    }
    
    if (c != '%') {
 8004f56:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8004f5a:	2b25      	cmp	r3, #37	; 0x25
 8004f5c:	d00b      	beq.n	8004f76 <chvprintf+0x46>
      streamPut(chp, (uint8_t)c);
 8004f5e:	9b03      	ldr	r3, [sp, #12]
 8004f60:	681b      	ldr	r3, [r3, #0]
 8004f62:	68db      	ldr	r3, [r3, #12]
 8004f64:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 8004f68:	4611      	mov	r1, r2
 8004f6a:	9803      	ldr	r0, [sp, #12]
 8004f6c:	4798      	blx	r3
      n++;
 8004f6e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004f70:	3301      	adds	r3, #1
 8004f72:	9309      	str	r3, [sp, #36]	; 0x24
      continue;
 8004f74:	e23c      	b.n	80053f0 <chvprintf+0x4c0>
    }
    
    p = tmpbuf;
 8004f76:	ab04      	add	r3, sp, #16
 8004f78:	930f      	str	r3, [sp, #60]	; 0x3c
    s = tmpbuf;
 8004f7a:	ab04      	add	r3, sp, #16
 8004f7c:	930e      	str	r3, [sp, #56]	; 0x38

    /* Alignment mode.*/
    left_align = false;
 8004f7e:	2300      	movs	r3, #0
 8004f80:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    if (*fmt == '-') {
 8004f84:	9b02      	ldr	r3, [sp, #8]
 8004f86:	781b      	ldrb	r3, [r3, #0]
 8004f88:	2b2d      	cmp	r3, #45	; 0x2d
 8004f8a:	d105      	bne.n	8004f98 <chvprintf+0x68>
      fmt++;
 8004f8c:	9b02      	ldr	r3, [sp, #8]
 8004f8e:	3301      	adds	r3, #1
 8004f90:	9302      	str	r3, [sp, #8]
      left_align = true;
 8004f92:	2301      	movs	r3, #1
 8004f94:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    }

    /* Sign mode.*/
    do_sign = false;
 8004f98:	2300      	movs	r3, #0
 8004f9a:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    if (*fmt == '+') {
 8004f9e:	9b02      	ldr	r3, [sp, #8]
 8004fa0:	781b      	ldrb	r3, [r3, #0]
 8004fa2:	2b2b      	cmp	r3, #43	; 0x2b
 8004fa4:	d105      	bne.n	8004fb2 <chvprintf+0x82>
      fmt++;
 8004fa6:	9b02      	ldr	r3, [sp, #8]
 8004fa8:	3301      	adds	r3, #1
 8004faa:	9302      	str	r3, [sp, #8]
      do_sign = true;
 8004fac:	2301      	movs	r3, #1
 8004fae:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    }

    /* Filler mode.*/
    filler = ' ';
 8004fb2:	2320      	movs	r3, #32
 8004fb4:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    if (*fmt == '0') {
 8004fb8:	9b02      	ldr	r3, [sp, #8]
 8004fba:	781b      	ldrb	r3, [r3, #0]
 8004fbc:	2b30      	cmp	r3, #48	; 0x30
 8004fbe:	d105      	bne.n	8004fcc <chvprintf+0x9c>
      fmt++;
 8004fc0:	9b02      	ldr	r3, [sp, #8]
 8004fc2:	3301      	adds	r3, #1
 8004fc4:	9302      	str	r3, [sp, #8]
      filler = '0';
 8004fc6:	2330      	movs	r3, #48	; 0x30
 8004fc8:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    }
    
    /* Width modifier.*/
    if ( *fmt == '*') {
 8004fcc:	9b02      	ldr	r3, [sp, #8]
 8004fce:	781b      	ldrb	r3, [r3, #0]
 8004fd0:	2b2a      	cmp	r3, #42	; 0x2a
 8004fd2:	d10e      	bne.n	8004ff2 <chvprintf+0xc2>
      width = va_arg(ap, int);
 8004fd4:	9b01      	ldr	r3, [sp, #4]
 8004fd6:	1d1a      	adds	r2, r3, #4
 8004fd8:	9201      	str	r2, [sp, #4]
 8004fda:	681b      	ldr	r3, [r3, #0]
 8004fdc:	930a      	str	r3, [sp, #40]	; 0x28
      ++fmt;
 8004fde:	9b02      	ldr	r3, [sp, #8]
 8004fe0:	3301      	adds	r3, #1
 8004fe2:	9302      	str	r3, [sp, #8]
      c = *fmt++;
 8004fe4:	9b02      	ldr	r3, [sp, #8]
 8004fe6:	1c5a      	adds	r2, r3, #1
 8004fe8:	9202      	str	r2, [sp, #8]
 8004fea:	781b      	ldrb	r3, [r3, #0]
 8004fec:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8004ff0:	e025      	b.n	800503e <chvprintf+0x10e>
    }
    else {
      width = 0;
 8004ff2:	2300      	movs	r3, #0
 8004ff4:	930a      	str	r3, [sp, #40]	; 0x28
      while (true) {
        c = *fmt++;
 8004ff6:	9b02      	ldr	r3, [sp, #8]
 8004ff8:	1c5a      	adds	r2, r3, #1
 8004ffa:	9202      	str	r2, [sp, #8]
 8004ffc:	781b      	ldrb	r3, [r3, #0]
 8004ffe:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        if (c == 0) {
 8005002:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8005006:	2b00      	cmp	r3, #0
 8005008:	d101      	bne.n	800500e <chvprintf+0xde>
          return n;
 800500a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800500c:	e1f1      	b.n	80053f2 <chvprintf+0x4c2>
        }
        if (c >= '0' && c <= '9') {
 800500e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8005012:	2b2f      	cmp	r3, #47	; 0x2f
 8005014:	d913      	bls.n	800503e <chvprintf+0x10e>
 8005016:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800501a:	2b39      	cmp	r3, #57	; 0x39
 800501c:	d80f      	bhi.n	800503e <chvprintf+0x10e>
          c -= '0';
 800501e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8005022:	3b30      	subs	r3, #48	; 0x30
 8005024:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
          width = width * 10 + c;
 8005028:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800502a:	4613      	mov	r3, r2
 800502c:	009b      	lsls	r3, r3, #2
 800502e:	4413      	add	r3, r2
 8005030:	005b      	lsls	r3, r3, #1
 8005032:	461a      	mov	r2, r3
 8005034:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8005038:	4413      	add	r3, r2
 800503a:	930a      	str	r3, [sp, #40]	; 0x28
        c = *fmt++;
 800503c:	e7db      	b.n	8004ff6 <chvprintf+0xc6>
        }
      }
    }
    
    /* Precision modifier.*/
    precision = 0;
 800503e:	2300      	movs	r3, #0
 8005040:	930b      	str	r3, [sp, #44]	; 0x2c
    if (c == '.') {
 8005042:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8005046:	2b2e      	cmp	r3, #46	; 0x2e
 8005048:	d13e      	bne.n	80050c8 <chvprintf+0x198>
      c = *fmt++;
 800504a:	9b02      	ldr	r3, [sp, #8]
 800504c:	1c5a      	adds	r2, r3, #1
 800504e:	9202      	str	r2, [sp, #8]
 8005050:	781b      	ldrb	r3, [r3, #0]
 8005052:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      if (c == 0) {
 8005056:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800505a:	2b00      	cmp	r3, #0
 800505c:	d101      	bne.n	8005062 <chvprintf+0x132>
        return n;
 800505e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005060:	e1c7      	b.n	80053f2 <chvprintf+0x4c2>
      }
      if (c == '*') {
 8005062:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8005066:	2b2a      	cmp	r3, #42	; 0x2a
 8005068:	d126      	bne.n	80050b8 <chvprintf+0x188>
        precision = va_arg(ap, int);
 800506a:	9b01      	ldr	r3, [sp, #4]
 800506c:	1d1a      	adds	r2, r3, #4
 800506e:	9201      	str	r2, [sp, #4]
 8005070:	681b      	ldr	r3, [r3, #0]
 8005072:	930b      	str	r3, [sp, #44]	; 0x2c
        c = *fmt++;
 8005074:	9b02      	ldr	r3, [sp, #8]
 8005076:	1c5a      	adds	r2, r3, #1
 8005078:	9202      	str	r2, [sp, #8]
 800507a:	781b      	ldrb	r3, [r3, #0]
 800507c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8005080:	e022      	b.n	80050c8 <chvprintf+0x198>
      }
      else {
        while (c >= '0' && c <= '9') {
          c -= '0';
 8005082:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8005086:	3b30      	subs	r3, #48	; 0x30
 8005088:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
          precision = precision * 10 + c;
 800508c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800508e:	4613      	mov	r3, r2
 8005090:	009b      	lsls	r3, r3, #2
 8005092:	4413      	add	r3, r2
 8005094:	005b      	lsls	r3, r3, #1
 8005096:	461a      	mov	r2, r3
 8005098:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800509c:	4413      	add	r3, r2
 800509e:	930b      	str	r3, [sp, #44]	; 0x2c
          c = *fmt++;
 80050a0:	9b02      	ldr	r3, [sp, #8]
 80050a2:	1c5a      	adds	r2, r3, #1
 80050a4:	9202      	str	r2, [sp, #8]
 80050a6:	781b      	ldrb	r3, [r3, #0]
 80050a8:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
          if (c == 0) {
 80050ac:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80050b0:	2b00      	cmp	r3, #0
 80050b2:	d101      	bne.n	80050b8 <chvprintf+0x188>
            return n;
 80050b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80050b6:	e19c      	b.n	80053f2 <chvprintf+0x4c2>
        while (c >= '0' && c <= '9') {
 80050b8:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80050bc:	2b2f      	cmp	r3, #47	; 0x2f
 80050be:	d903      	bls.n	80050c8 <chvprintf+0x198>
 80050c0:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80050c4:	2b39      	cmp	r3, #57	; 0x39
 80050c6:	d9dc      	bls.n	8005082 <chvprintf+0x152>
        }
      }
    }
    
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80050c8:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80050cc:	2b6c      	cmp	r3, #108	; 0x6c
 80050ce:	d003      	beq.n	80050d8 <chvprintf+0x1a8>
 80050d0:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80050d4:	2b4c      	cmp	r3, #76	; 0x4c
 80050d6:	d10e      	bne.n	80050f6 <chvprintf+0x1c6>
      is_long = true;
 80050d8:	2301      	movs	r3, #1
 80050da:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
      c = *fmt++;
 80050de:	9b02      	ldr	r3, [sp, #8]
 80050e0:	1c5a      	adds	r2, r3, #1
 80050e2:	9202      	str	r2, [sp, #8]
 80050e4:	781b      	ldrb	r3, [r3, #0]
 80050e6:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      if (c == 0) {
 80050ea:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80050ee:	2b00      	cmp	r3, #0
 80050f0:	d115      	bne.n	800511e <chvprintf+0x1ee>
        return n;
 80050f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80050f4:	e17d      	b.n	80053f2 <chvprintf+0x4c2>
      }
    }
    else {
      is_long = (c >= 'A') && (c <= 'Z');
 80050f6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80050fa:	2b40      	cmp	r3, #64	; 0x40
 80050fc:	d905      	bls.n	800510a <chvprintf+0x1da>
 80050fe:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8005102:	2b5a      	cmp	r3, #90	; 0x5a
 8005104:	d801      	bhi.n	800510a <chvprintf+0x1da>
 8005106:	2301      	movs	r3, #1
 8005108:	e000      	b.n	800510c <chvprintf+0x1dc>
 800510a:	2300      	movs	r3, #0
 800510c:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 8005110:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 8005114:	f003 0301 	and.w	r3, r3, #1
 8005118:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 800511c:	e000      	b.n	8005120 <chvprintf+0x1f0>
      if (c == 0) {
 800511e:	bf00      	nop
    }

    /* Command decoding.*/
    switch (c) {
 8005120:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8005124:	3b44      	subs	r3, #68	; 0x44
 8005126:	2b34      	cmp	r3, #52	; 0x34
 8005128:	f200 80ed 	bhi.w	8005306 <chvprintf+0x3d6>
 800512c:	a201      	add	r2, pc, #4	; (adr r2, 8005134 <chvprintf+0x204>)
 800512e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005132:	bf00      	nop
 8005134:	0800526b 	.word	0x0800526b
 8005138:	08005307 	.word	0x08005307
 800513c:	08005307 	.word	0x08005307
 8005140:	08005307 	.word	0x08005307
 8005144:	08005307 	.word	0x08005307
 8005148:	0800526b 	.word	0x0800526b
 800514c:	08005307 	.word	0x08005307
 8005150:	08005307 	.word	0x08005307
 8005154:	08005307 	.word	0x08005307
 8005158:	08005307 	.word	0x08005307
 800515c:	08005307 	.word	0x08005307
 8005160:	080052d1 	.word	0x080052d1
 8005164:	080052c1 	.word	0x080052c1
 8005168:	08005307 	.word	0x08005307
 800516c:	08005307 	.word	0x08005307
 8005170:	08005307 	.word	0x08005307
 8005174:	08005307 	.word	0x08005307
 8005178:	080052c9 	.word	0x080052c9
 800517c:	08005307 	.word	0x08005307
 8005180:	08005307 	.word	0x08005307
 8005184:	080052c1 	.word	0x080052c1
 8005188:	08005307 	.word	0x08005307
 800518c:	08005307 	.word	0x08005307
 8005190:	08005307 	.word	0x08005307
 8005194:	08005307 	.word	0x08005307
 8005198:	08005307 	.word	0x08005307
 800519c:	08005307 	.word	0x08005307
 80051a0:	08005307 	.word	0x08005307
 80051a4:	08005307 	.word	0x08005307
 80051a8:	08005307 	.word	0x08005307
 80051ac:	08005307 	.word	0x08005307
 80051b0:	08005209 	.word	0x08005209
 80051b4:	0800526b 	.word	0x0800526b
 80051b8:	08005307 	.word	0x08005307
 80051bc:	08005307 	.word	0x08005307
 80051c0:	08005307 	.word	0x08005307
 80051c4:	08005307 	.word	0x08005307
 80051c8:	0800526b 	.word	0x0800526b
 80051cc:	08005307 	.word	0x08005307
 80051d0:	08005307 	.word	0x08005307
 80051d4:	08005307 	.word	0x08005307
 80051d8:	08005307 	.word	0x08005307
 80051dc:	08005307 	.word	0x08005307
 80051e0:	080052d1 	.word	0x080052d1
 80051e4:	080052c1 	.word	0x080052c1
 80051e8:	08005307 	.word	0x08005307
 80051ec:	08005307 	.word	0x08005307
 80051f0:	08005223 	.word	0x08005223
 80051f4:	08005307 	.word	0x08005307
 80051f8:	080052c9 	.word	0x080052c9
 80051fc:	08005307 	.word	0x08005307
 8005200:	08005307 	.word	0x08005307
 8005204:	080052c1 	.word	0x080052c1
    case 'c':
      filler = ' ';
 8005208:	2320      	movs	r3, #32
 800520a:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      *p++ = va_arg(ap, int);
 800520e:	9b01      	ldr	r3, [sp, #4]
 8005210:	1d1a      	adds	r2, r3, #4
 8005212:	9201      	str	r2, [sp, #4]
 8005214:	6819      	ldr	r1, [r3, #0]
 8005216:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8005218:	1c5a      	adds	r2, r3, #1
 800521a:	920f      	str	r2, [sp, #60]	; 0x3c
 800521c:	b2ca      	uxtb	r2, r1
 800521e:	701a      	strb	r2, [r3, #0]
      break;
 8005220:	e079      	b.n	8005316 <chvprintf+0x3e6>
    case 's':
      filler = ' ';
 8005222:	2320      	movs	r3, #32
 8005224:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0) {
 8005228:	9b01      	ldr	r3, [sp, #4]
 800522a:	1d1a      	adds	r2, r3, #4
 800522c:	9201      	str	r2, [sp, #4]
 800522e:	681b      	ldr	r3, [r3, #0]
 8005230:	930e      	str	r3, [sp, #56]	; 0x38
 8005232:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8005234:	2b00      	cmp	r3, #0
 8005236:	d101      	bne.n	800523c <chvprintf+0x30c>
        s = "(null)";
 8005238:	4b70      	ldr	r3, [pc, #448]	; (80053fc <chvprintf+0x4cc>)
 800523a:	930e      	str	r3, [sp, #56]	; 0x38
      }
      if (precision == 0) {
 800523c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800523e:	2b00      	cmp	r3, #0
 8005240:	d102      	bne.n	8005248 <chvprintf+0x318>
        precision = 32767;
 8005242:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8005246:	930b      	str	r3, [sp, #44]	; 0x2c
      }
      for (p = s; *p && (--precision >= 0); p++)
 8005248:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800524a:	930f      	str	r3, [sp, #60]	; 0x3c
 800524c:	e002      	b.n	8005254 <chvprintf+0x324>
 800524e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8005250:	3301      	adds	r3, #1
 8005252:	930f      	str	r3, [sp, #60]	; 0x3c
 8005254:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8005256:	781b      	ldrb	r3, [r3, #0]
 8005258:	2b00      	cmp	r3, #0
 800525a:	d05b      	beq.n	8005314 <chvprintf+0x3e4>
 800525c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800525e:	3b01      	subs	r3, #1
 8005260:	930b      	str	r3, [sp, #44]	; 0x2c
 8005262:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8005264:	2b00      	cmp	r3, #0
 8005266:	daf2      	bge.n	800524e <chvprintf+0x31e>
        ;
      break;
 8005268:	e054      	b.n	8005314 <chvprintf+0x3e4>
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long) {
 800526a:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 800526e:	2b00      	cmp	r3, #0
 8005270:	d005      	beq.n	800527e <chvprintf+0x34e>
        l = va_arg(ap, long);
 8005272:	9b01      	ldr	r3, [sp, #4]
 8005274:	1d1a      	adds	r2, r3, #4
 8005276:	9201      	str	r2, [sp, #4]
 8005278:	681b      	ldr	r3, [r3, #0]
 800527a:	9307      	str	r3, [sp, #28]
 800527c:	e004      	b.n	8005288 <chvprintf+0x358>
      }
      else {
        l = va_arg(ap, int);
 800527e:	9b01      	ldr	r3, [sp, #4]
 8005280:	1d1a      	adds	r2, r3, #4
 8005282:	9201      	str	r2, [sp, #4]
 8005284:	681b      	ldr	r3, [r3, #0]
 8005286:	9307      	str	r3, [sp, #28]
      }
      if (l < 0) {
 8005288:	9b07      	ldr	r3, [sp, #28]
 800528a:	2b00      	cmp	r3, #0
 800528c:	da08      	bge.n	80052a0 <chvprintf+0x370>
        *p++ = '-';
 800528e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8005290:	1c5a      	adds	r2, r3, #1
 8005292:	920f      	str	r2, [sp, #60]	; 0x3c
 8005294:	222d      	movs	r2, #45	; 0x2d
 8005296:	701a      	strb	r2, [r3, #0]
        l = -l;
 8005298:	9b07      	ldr	r3, [sp, #28]
 800529a:	425b      	negs	r3, r3
 800529c:	9307      	str	r3, [sp, #28]
 800529e:	e008      	b.n	80052b2 <chvprintf+0x382>
      }
      else
        if (do_sign) {
 80052a0:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
 80052a4:	2b00      	cmp	r3, #0
 80052a6:	d004      	beq.n	80052b2 <chvprintf+0x382>
          *p++ = '+';
 80052a8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80052aa:	1c5a      	adds	r2, r3, #1
 80052ac:	920f      	str	r2, [sp, #60]	; 0x3c
 80052ae:	222b      	movs	r2, #43	; 0x2b
 80052b0:	701a      	strb	r2, [r3, #0]
        }
      p = ch_ltoa(p, l, 10);
 80052b2:	220a      	movs	r2, #10
 80052b4:	9907      	ldr	r1, [sp, #28]
 80052b6:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80052b8:	f7ff fe2a 	bl	8004f10 <ch_ltoa>
 80052bc:	900f      	str	r0, [sp, #60]	; 0x3c
      break;
 80052be:	e02a      	b.n	8005316 <chvprintf+0x3e6>
#endif
    case 'X':
    case 'x':
    case 'P':
    case 'p':
      c = 16;
 80052c0:	2310      	movs	r3, #16
 80052c2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      goto unsigned_common;
 80052c6:	e006      	b.n	80052d6 <chvprintf+0x3a6>
    case 'U':
    case 'u':
      c = 10;
 80052c8:	230a      	movs	r3, #10
 80052ca:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      goto unsigned_common;
 80052ce:	e002      	b.n	80052d6 <chvprintf+0x3a6>
    case 'O':
    case 'o':
      c = 8;
 80052d0:	2308      	movs	r3, #8
 80052d2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
unsigned_common:
      if (is_long) {
 80052d6:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 80052da:	2b00      	cmp	r3, #0
 80052dc:	d005      	beq.n	80052ea <chvprintf+0x3ba>
        l = va_arg(ap, unsigned long);
 80052de:	9b01      	ldr	r3, [sp, #4]
 80052e0:	1d1a      	adds	r2, r3, #4
 80052e2:	9201      	str	r2, [sp, #4]
 80052e4:	681b      	ldr	r3, [r3, #0]
 80052e6:	9307      	str	r3, [sp, #28]
 80052e8:	e004      	b.n	80052f4 <chvprintf+0x3c4>
      }
      else {
        l = va_arg(ap, unsigned int);
 80052ea:	9b01      	ldr	r3, [sp, #4]
 80052ec:	1d1a      	adds	r2, r3, #4
 80052ee:	9201      	str	r2, [sp, #4]
 80052f0:	681b      	ldr	r3, [r3, #0]
 80052f2:	9307      	str	r3, [sp, #28]
      }
      p = ch_ltoa(p, l, c);
 80052f4:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80052f8:	461a      	mov	r2, r3
 80052fa:	9907      	ldr	r1, [sp, #28]
 80052fc:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80052fe:	f7ff fe07 	bl	8004f10 <ch_ltoa>
 8005302:	900f      	str	r0, [sp, #60]	; 0x3c
      break;
 8005304:	e007      	b.n	8005316 <chvprintf+0x3e6>
    default:
      *p++ = c;
 8005306:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8005308:	1c5a      	adds	r2, r3, #1
 800530a:	920f      	str	r2, [sp, #60]	; 0x3c
 800530c:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 8005310:	701a      	strb	r2, [r3, #0]
      break;
 8005312:	e000      	b.n	8005316 <chvprintf+0x3e6>
      break;
 8005314:	bf00      	nop
    }
    i = (int)(p - s);
 8005316:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8005318:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800531a:	1ad3      	subs	r3, r2, r3
 800531c:	930c      	str	r3, [sp, #48]	; 0x30
    if ((width -= i) < 0) {
 800531e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8005320:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8005322:	1ad3      	subs	r3, r2, r3
 8005324:	930a      	str	r3, [sp, #40]	; 0x28
 8005326:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8005328:	2b00      	cmp	r3, #0
 800532a:	da01      	bge.n	8005330 <chvprintf+0x400>
      width = 0;
 800532c:	2300      	movs	r3, #0
 800532e:	930a      	str	r3, [sp, #40]	; 0x28
    }
    if (left_align == false) {
 8005330:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
 8005334:	f083 0301 	eor.w	r3, r3, #1
 8005338:	b2db      	uxtb	r3, r3
 800533a:	2b00      	cmp	r3, #0
 800533c:	d002      	beq.n	8005344 <chvprintf+0x414>
      width = -width;
 800533e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8005340:	425b      	negs	r3, r3
 8005342:	930a      	str	r3, [sp, #40]	; 0x28
    }
    if (width < 0) {
 8005344:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8005346:	2b00      	cmp	r3, #0
 8005348:	da3a      	bge.n	80053c0 <chvprintf+0x490>
      if ((*s == '-' || *s == '+') && filler == '0') {
 800534a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800534c:	781b      	ldrb	r3, [r3, #0]
 800534e:	2b2d      	cmp	r3, #45	; 0x2d
 8005350:	d003      	beq.n	800535a <chvprintf+0x42a>
 8005352:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8005354:	781b      	ldrb	r3, [r3, #0]
 8005356:	2b2b      	cmp	r3, #43	; 0x2b
 8005358:	d113      	bne.n	8005382 <chvprintf+0x452>
 800535a:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 800535e:	2b30      	cmp	r3, #48	; 0x30
 8005360:	d10f      	bne.n	8005382 <chvprintf+0x452>
        streamPut(chp, (uint8_t)*s++);
 8005362:	9b03      	ldr	r3, [sp, #12]
 8005364:	681b      	ldr	r3, [r3, #0]
 8005366:	68da      	ldr	r2, [r3, #12]
 8005368:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800536a:	1c59      	adds	r1, r3, #1
 800536c:	910e      	str	r1, [sp, #56]	; 0x38
 800536e:	781b      	ldrb	r3, [r3, #0]
 8005370:	4619      	mov	r1, r3
 8005372:	9803      	ldr	r0, [sp, #12]
 8005374:	4790      	blx	r2
        n++;
 8005376:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005378:	3301      	adds	r3, #1
 800537a:	9309      	str	r3, [sp, #36]	; 0x24
        i--;
 800537c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800537e:	3b01      	subs	r3, #1
 8005380:	930c      	str	r3, [sp, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8005382:	9b03      	ldr	r3, [sp, #12]
 8005384:	681b      	ldr	r3, [r3, #0]
 8005386:	68db      	ldr	r3, [r3, #12]
 8005388:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 800538c:	4611      	mov	r1, r2
 800538e:	9803      	ldr	r0, [sp, #12]
 8005390:	4798      	blx	r3
        n++;
 8005392:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005394:	3301      	adds	r3, #1
 8005396:	9309      	str	r3, [sp, #36]	; 0x24
      } while (++width != 0);
 8005398:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800539a:	3301      	adds	r3, #1
 800539c:	930a      	str	r3, [sp, #40]	; 0x28
 800539e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80053a0:	2b00      	cmp	r3, #0
 80053a2:	d1ee      	bne.n	8005382 <chvprintf+0x452>
    }
    while (--i >= 0) {
 80053a4:	e00c      	b.n	80053c0 <chvprintf+0x490>
      streamPut(chp, (uint8_t)*s++);
 80053a6:	9b03      	ldr	r3, [sp, #12]
 80053a8:	681b      	ldr	r3, [r3, #0]
 80053aa:	68da      	ldr	r2, [r3, #12]
 80053ac:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80053ae:	1c59      	adds	r1, r3, #1
 80053b0:	910e      	str	r1, [sp, #56]	; 0x38
 80053b2:	781b      	ldrb	r3, [r3, #0]
 80053b4:	4619      	mov	r1, r3
 80053b6:	9803      	ldr	r0, [sp, #12]
 80053b8:	4790      	blx	r2
      n++;
 80053ba:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80053bc:	3301      	adds	r3, #1
 80053be:	9309      	str	r3, [sp, #36]	; 0x24
    while (--i >= 0) {
 80053c0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80053c2:	3b01      	subs	r3, #1
 80053c4:	930c      	str	r3, [sp, #48]	; 0x30
 80053c6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80053c8:	2b00      	cmp	r3, #0
 80053ca:	daec      	bge.n	80053a6 <chvprintf+0x476>
    }

    while (width) {
 80053cc:	e00d      	b.n	80053ea <chvprintf+0x4ba>
      streamPut(chp, (uint8_t)filler);
 80053ce:	9b03      	ldr	r3, [sp, #12]
 80053d0:	681b      	ldr	r3, [r3, #0]
 80053d2:	68db      	ldr	r3, [r3, #12]
 80053d4:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 80053d8:	4611      	mov	r1, r2
 80053da:	9803      	ldr	r0, [sp, #12]
 80053dc:	4798      	blx	r3
      n++;
 80053de:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80053e0:	3301      	adds	r3, #1
 80053e2:	9309      	str	r3, [sp, #36]	; 0x24
      width--;
 80053e4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80053e6:	3b01      	subs	r3, #1
 80053e8:	930a      	str	r3, [sp, #40]	; 0x28
    while (width) {
 80053ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80053ec:	2b00      	cmp	r3, #0
 80053ee:	d1ee      	bne.n	80053ce <chvprintf+0x49e>
    c = *fmt++;
 80053f0:	e5a5      	b.n	8004f3e <chvprintf+0xe>
    }
  }
}
 80053f2:	4618      	mov	r0, r3
 80053f4:	b011      	add	sp, #68	; 0x44
 80053f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80053fa:	bf00      	nop
 80053fc:	08007020 	.word	0x08007020

08005400 <chprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8005400:	b40e      	push	{r1, r2, r3}
 8005402:	b500      	push	{lr}
 8005404:	b084      	sub	sp, #16
 8005406:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8005408:	ab06      	add	r3, sp, #24
 800540a:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800540c:	9a02      	ldr	r2, [sp, #8]
 800540e:	9905      	ldr	r1, [sp, #20]
 8005410:	9801      	ldr	r0, [sp, #4]
 8005412:	f7ff fd8d 	bl	8004f30 <chvprintf>
 8005416:	9003      	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 8005418:	9b03      	ldr	r3, [sp, #12]
 800541a:	bf00      	nop
}
 800541c:	4618      	mov	r0, r3
 800541e:	b004      	add	sp, #16
 8005420:	f85d eb04 	ldr.w	lr, [sp], #4
 8005424:	b003      	add	sp, #12
 8005426:	4770      	bx	lr
	...

08005430 <hex2int>:
#include <time.h>

#define boolstr(s) ((s) ? "true" : "false")

static int hex2int(char c)
{
 8005430:	b082      	sub	sp, #8
 8005432:	4603      	mov	r3, r0
 8005434:	f88d 3007 	strb.w	r3, [sp, #7]
    if (c >= '0' && c <= '9')
 8005438:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800543c:	2b2f      	cmp	r3, #47	; 0x2f
 800543e:	d907      	bls.n	8005450 <hex2int+0x20>
 8005440:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005444:	2b39      	cmp	r3, #57	; 0x39
 8005446:	d803      	bhi.n	8005450 <hex2int+0x20>
        return c - '0';
 8005448:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800544c:	3b30      	subs	r3, #48	; 0x30
 800544e:	e019      	b.n	8005484 <hex2int+0x54>
    if (c >= 'A' && c <= 'F')
 8005450:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005454:	2b40      	cmp	r3, #64	; 0x40
 8005456:	d907      	bls.n	8005468 <hex2int+0x38>
 8005458:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800545c:	2b46      	cmp	r3, #70	; 0x46
 800545e:	d803      	bhi.n	8005468 <hex2int+0x38>
        return c - 'A' + 10;
 8005460:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005464:	3b37      	subs	r3, #55	; 0x37
 8005466:	e00d      	b.n	8005484 <hex2int+0x54>
    if (c >= 'a' && c <= 'f')
 8005468:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800546c:	2b60      	cmp	r3, #96	; 0x60
 800546e:	d907      	bls.n	8005480 <hex2int+0x50>
 8005470:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005474:	2b66      	cmp	r3, #102	; 0x66
 8005476:	d803      	bhi.n	8005480 <hex2int+0x50>
        return c - 'a' + 10;
 8005478:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800547c:	3b57      	subs	r3, #87	; 0x57
 800547e:	e001      	b.n	8005484 <hex2int+0x54>
    return -1;
 8005480:	f04f 33ff 	mov.w	r3, #4294967295
}
 8005484:	4618      	mov	r0, r3
 8005486:	b002      	add	sp, #8
 8005488:	4770      	bx	lr
 800548a:	bf00      	nop
 800548c:	0000      	movs	r0, r0
	...

08005490 <minmea_check>:

    return checksum;
}

bool minmea_check(const char *sentence, bool strict)
{
 8005490:	b500      	push	{lr}
 8005492:	b087      	sub	sp, #28
 8005494:	9001      	str	r0, [sp, #4]
 8005496:	460b      	mov	r3, r1
 8005498:	f88d 3003 	strb.w	r3, [sp, #3]
    uint8_t checksum = 0x00;
 800549c:	2300      	movs	r3, #0
 800549e:	f88d 3017 	strb.w	r3, [sp, #23]

    // Sequence length is limited.
    if (strlen(sentence) > MINMEA_MAX_LENGTH + 3)
 80054a2:	9801      	ldr	r0, [sp, #4]
 80054a4:	f7fb f94c 	bl	8000740 <strlen>
 80054a8:	4603      	mov	r3, r0
 80054aa:	2b53      	cmp	r3, #83	; 0x53
 80054ac:	d901      	bls.n	80054b2 <minmea_check+0x22>
        return false;
 80054ae:	2300      	movs	r3, #0
 80054b0:	e06d      	b.n	800558e <minmea_check+0xfe>

    // A valid sentence starts with "$".
    if (*sentence++ != '$')
 80054b2:	9b01      	ldr	r3, [sp, #4]
 80054b4:	1c5a      	adds	r2, r3, #1
 80054b6:	9201      	str	r2, [sp, #4]
 80054b8:	781b      	ldrb	r3, [r3, #0]
 80054ba:	2b24      	cmp	r3, #36	; 0x24
 80054bc:	d00a      	beq.n	80054d4 <minmea_check+0x44>
        return false;
 80054be:	2300      	movs	r3, #0
 80054c0:	e065      	b.n	800558e <minmea_check+0xfe>

    // The optional checksum is an XOR of all bytes between "$" and "*".
    while (*sentence && *sentence != '*' && isprint((unsigned char) *sentence))
        checksum ^= *sentence++;
 80054c2:	9b01      	ldr	r3, [sp, #4]
 80054c4:	1c5a      	adds	r2, r3, #1
 80054c6:	9201      	str	r2, [sp, #4]
 80054c8:	781a      	ldrb	r2, [r3, #0]
 80054ca:	f89d 3017 	ldrb.w	r3, [sp, #23]
 80054ce:	4053      	eors	r3, r2
 80054d0:	f88d 3017 	strb.w	r3, [sp, #23]
    while (*sentence && *sentence != '*' && isprint((unsigned char) *sentence))
 80054d4:	9b01      	ldr	r3, [sp, #4]
 80054d6:	781b      	ldrb	r3, [r3, #0]
 80054d8:	2b00      	cmp	r3, #0
 80054da:	d00d      	beq.n	80054f8 <minmea_check+0x68>
 80054dc:	9b01      	ldr	r3, [sp, #4]
 80054de:	781b      	ldrb	r3, [r3, #0]
 80054e0:	2b2a      	cmp	r3, #42	; 0x2a
 80054e2:	d009      	beq.n	80054f8 <minmea_check+0x68>
 80054e4:	9b01      	ldr	r3, [sp, #4]
 80054e6:	781b      	ldrb	r3, [r3, #0]
 80054e8:	3301      	adds	r3, #1
 80054ea:	4a2b      	ldr	r2, [pc, #172]	; (8005598 <minmea_check+0x108>)
 80054ec:	4413      	add	r3, r2
 80054ee:	781b      	ldrb	r3, [r3, #0]
 80054f0:	f003 0397 	and.w	r3, r3, #151	; 0x97
 80054f4:	2b00      	cmp	r3, #0
 80054f6:	d1e4      	bne.n	80054c2 <minmea_check+0x32>

    // If checksum is present...
    if (*sentence == '*') {
 80054f8:	9b01      	ldr	r3, [sp, #4]
 80054fa:	781b      	ldrb	r3, [r3, #0]
 80054fc:	2b2a      	cmp	r3, #42	; 0x2a
 80054fe:	d12a      	bne.n	8005556 <minmea_check+0xc6>
        // Extract checksum.
        sentence++;
 8005500:	9b01      	ldr	r3, [sp, #4]
 8005502:	3301      	adds	r3, #1
 8005504:	9301      	str	r3, [sp, #4]
        int upper = hex2int(*sentence++);
 8005506:	9b01      	ldr	r3, [sp, #4]
 8005508:	1c5a      	adds	r2, r3, #1
 800550a:	9201      	str	r2, [sp, #4]
 800550c:	781b      	ldrb	r3, [r3, #0]
 800550e:	4618      	mov	r0, r3
 8005510:	f7ff ff8e 	bl	8005430 <hex2int>
 8005514:	9004      	str	r0, [sp, #16]
        if (upper == -1)
 8005516:	9b04      	ldr	r3, [sp, #16]
 8005518:	f1b3 3fff 	cmp.w	r3, #4294967295
 800551c:	d101      	bne.n	8005522 <minmea_check+0x92>
            return false;
 800551e:	2300      	movs	r3, #0
 8005520:	e035      	b.n	800558e <minmea_check+0xfe>
        int lower = hex2int(*sentence++);
 8005522:	9b01      	ldr	r3, [sp, #4]
 8005524:	1c5a      	adds	r2, r3, #1
 8005526:	9201      	str	r2, [sp, #4]
 8005528:	781b      	ldrb	r3, [r3, #0]
 800552a:	4618      	mov	r0, r3
 800552c:	f7ff ff80 	bl	8005430 <hex2int>
 8005530:	9003      	str	r0, [sp, #12]
        if (lower == -1)
 8005532:	9b03      	ldr	r3, [sp, #12]
 8005534:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005538:	d101      	bne.n	800553e <minmea_check+0xae>
            return false;
 800553a:	2300      	movs	r3, #0
 800553c:	e027      	b.n	800558e <minmea_check+0xfe>
        int expected = upper << 4 | lower;
 800553e:	9b04      	ldr	r3, [sp, #16]
 8005540:	011b      	lsls	r3, r3, #4
 8005542:	9a03      	ldr	r2, [sp, #12]
 8005544:	4313      	orrs	r3, r2
 8005546:	9302      	str	r3, [sp, #8]

        // Check for checksum mismatch.
        if (checksum != expected)
 8005548:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800554c:	9a02      	ldr	r2, [sp, #8]
 800554e:	429a      	cmp	r2, r3
 8005550:	d007      	beq.n	8005562 <minmea_check+0xd2>
            return false;
 8005552:	2300      	movs	r3, #0
 8005554:	e01b      	b.n	800558e <minmea_check+0xfe>
    } else if (strict) {
 8005556:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800555a:	2b00      	cmp	r3, #0
 800555c:	d001      	beq.n	8005562 <minmea_check+0xd2>
        // Discard non-checksummed frames in strict mode.
        return false;
 800555e:	2300      	movs	r3, #0
 8005560:	e015      	b.n	800558e <minmea_check+0xfe>
    }

    // The only stuff allowed at this point is a newline.
    if (*sentence && strcmp(sentence, "\n") && strcmp(sentence, "\r\n"))
 8005562:	9b01      	ldr	r3, [sp, #4]
 8005564:	781b      	ldrb	r3, [r3, #0]
 8005566:	2b00      	cmp	r3, #0
 8005568:	d00f      	beq.n	800558a <minmea_check+0xfa>
 800556a:	490c      	ldr	r1, [pc, #48]	; (800559c <minmea_check+0x10c>)
 800556c:	9801      	ldr	r0, [sp, #4]
 800556e:	f7fa ff6b 	bl	8000448 <strcmp>
 8005572:	4603      	mov	r3, r0
 8005574:	2b00      	cmp	r3, #0
 8005576:	d008      	beq.n	800558a <minmea_check+0xfa>
 8005578:	4909      	ldr	r1, [pc, #36]	; (80055a0 <minmea_check+0x110>)
 800557a:	9801      	ldr	r0, [sp, #4]
 800557c:	f7fa ff64 	bl	8000448 <strcmp>
 8005580:	4603      	mov	r3, r0
 8005582:	2b00      	cmp	r3, #0
 8005584:	d001      	beq.n	800558a <minmea_check+0xfa>
        return false;
 8005586:	2300      	movs	r3, #0
 8005588:	e001      	b.n	800558e <minmea_check+0xfe>

    return true;
 800558a:	2301      	movs	r3, #1
 800558c:	bf00      	nop
}
 800558e:	4618      	mov	r0, r3
 8005590:	b007      	add	sp, #28
 8005592:	f85d fb04 	ldr.w	pc, [sp], #4
 8005596:	bf00      	nop
 8005598:	08007608 	.word	0x08007608
 800559c:	080075b8 	.word	0x080075b8
 80055a0:	08007040 	.word	0x08007040
	...

080055b0 <minmea_isfield>:

static inline bool minmea_isfield(char c) {
 80055b0:	b082      	sub	sp, #8
 80055b2:	4603      	mov	r3, r0
 80055b4:	f88d 3007 	strb.w	r3, [sp, #7]
    return isprint((unsigned char) c) && c != ',' && c != '*';
 80055b8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80055bc:	3301      	adds	r3, #1
 80055be:	4a0c      	ldr	r2, [pc, #48]	; (80055f0 <minmea_isfield+0x40>)
 80055c0:	4413      	add	r3, r2
 80055c2:	781b      	ldrb	r3, [r3, #0]
 80055c4:	f003 0397 	and.w	r3, r3, #151	; 0x97
 80055c8:	2b00      	cmp	r3, #0
 80055ca:	d009      	beq.n	80055e0 <minmea_isfield+0x30>
 80055cc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80055d0:	2b2c      	cmp	r3, #44	; 0x2c
 80055d2:	d005      	beq.n	80055e0 <minmea_isfield+0x30>
 80055d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80055d8:	2b2a      	cmp	r3, #42	; 0x2a
 80055da:	d001      	beq.n	80055e0 <minmea_isfield+0x30>
 80055dc:	2301      	movs	r3, #1
 80055de:	e000      	b.n	80055e2 <minmea_isfield+0x32>
 80055e0:	2300      	movs	r3, #0
 80055e2:	f003 0301 	and.w	r3, r3, #1
 80055e6:	b2db      	uxtb	r3, r3
}
 80055e8:	4618      	mov	r0, r3
 80055ea:	b002      	add	sp, #8
 80055ec:	4770      	bx	lr
 80055ee:	bf00      	nop
 80055f0:	08007608 	.word	0x08007608
	...

08005600 <minmea_scan>:

bool minmea_scan(const char *sentence, const char *format, ...)
{
 8005600:	b40e      	push	{r1, r2, r3}
 8005602:	b500      	push	{lr}
 8005604:	b0a6      	sub	sp, #152	; 0x98
 8005606:	9001      	str	r0, [sp, #4]
    bool result = false;
 8005608:	2300      	movs	r3, #0
 800560a:	f88d 3097 	strb.w	r3, [sp, #151]	; 0x97
    bool optional = false;
 800560e:	2300      	movs	r3, #0
 8005610:	f88d 3096 	strb.w	r3, [sp, #150]	; 0x96
    va_list ap;
    va_start(ap, format);
 8005614:	ab28      	add	r3, sp, #160	; 0xa0
 8005616:	930b      	str	r3, [sp, #44]	; 0x2c

    const char *field = sentence;
 8005618:	9b01      	ldr	r3, [sp, #4]
 800561a:	9324      	str	r3, [sp, #144]	; 0x90
        } else { \
            field = NULL; \
        } \
    } while (0)

    while (*format) {
 800561c:	e341      	b.n	8005ca2 <minmea_scan+0x6a2>
        char type = *format++;
 800561e:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8005620:	1c5a      	adds	r2, r3, #1
 8005622:	9227      	str	r2, [sp, #156]	; 0x9c
 8005624:	781b      	ldrb	r3, [r3, #0]
 8005626:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43

        if (type == ';') {
 800562a:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
 800562e:	2b3b      	cmp	r3, #59	; 0x3b
 8005630:	d103      	bne.n	800563a <minmea_scan+0x3a>
            // All further fields are optional.
            optional = true;
 8005632:	2301      	movs	r3, #1
 8005634:	f88d 3096 	strb.w	r3, [sp, #150]	; 0x96
            continue;
 8005638:	e333      	b.n	8005ca2 <minmea_scan+0x6a2>
        }

        if (!field && !optional) {
 800563a:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800563c:	2b00      	cmp	r3, #0
 800563e:	d107      	bne.n	8005650 <minmea_scan+0x50>
 8005640:	f89d 3096 	ldrb.w	r3, [sp, #150]	; 0x96
 8005644:	f083 0301 	eor.w	r3, r3, #1
 8005648:	b2db      	uxtb	r3, r3
 800564a:	2b00      	cmp	r3, #0
 800564c:	f040 8332 	bne.w	8005cb4 <minmea_scan+0x6b4>
            // Field requested but we ran out if input. Bail out.
            goto parse_error;
        }

        switch (type) {
 8005650:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
 8005654:	3b44      	subs	r3, #68	; 0x44
 8005656:	2b30      	cmp	r3, #48	; 0x30
 8005658:	f200 832e 	bhi.w	8005cb8 <minmea_scan+0x6b8>
 800565c:	a201      	add	r2, pc, #4	; (adr r2, 8005664 <minmea_scan+0x64>)
 800565e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005662:	bf00      	nop
 8005664:	08005a2f 	.word	0x08005a2f
 8005668:	08005cb9 	.word	0x08005cb9
 800566c:	08005cb9 	.word	0x08005cb9
 8005670:	08005cb9 	.word	0x08005cb9
 8005674:	08005cb9 	.word	0x08005cb9
 8005678:	08005cb9 	.word	0x08005cb9
 800567c:	08005cb9 	.word	0x08005cb9
 8005680:	08005cb9 	.word	0x08005cb9
 8005684:	08005cb9 	.word	0x08005cb9
 8005688:	08005cb9 	.word	0x08005cb9
 800568c:	08005cb9 	.word	0x08005cb9
 8005690:	08005cb9 	.word	0x08005cb9
 8005694:	08005cb9 	.word	0x08005cb9
 8005698:	08005cb9 	.word	0x08005cb9
 800569c:	08005cb9 	.word	0x08005cb9
 80056a0:	08005cb9 	.word	0x08005cb9
 80056a4:	08005b17 	.word	0x08005b17
 80056a8:	08005cb9 	.word	0x08005cb9
 80056ac:	08005cb9 	.word	0x08005cb9
 80056b0:	08005cb9 	.word	0x08005cb9
 80056b4:	08005cb9 	.word	0x08005cb9
 80056b8:	08005cb9 	.word	0x08005cb9
 80056bc:	08005cb9 	.word	0x08005cb9
 80056c0:	08005cb9 	.word	0x08005cb9
 80056c4:	08005cb9 	.word	0x08005cb9
 80056c8:	08005cb9 	.word	0x08005cb9
 80056cc:	08005cb9 	.word	0x08005cb9
 80056d0:	08005c71 	.word	0x08005c71
 80056d4:	08005cb9 	.word	0x08005cb9
 80056d8:	08005cb9 	.word	0x08005cb9
 80056dc:	08005cb9 	.word	0x08005cb9
 80056e0:	08005729 	.word	0x08005729
 80056e4:	0800575d 	.word	0x0800575d
 80056e8:	08005cb9 	.word	0x08005cb9
 80056ec:	080057f3 	.word	0x080057f3
 80056f0:	08005cb9 	.word	0x08005cb9
 80056f4:	08005cb9 	.word	0x08005cb9
 80056f8:	08005957 	.word	0x08005957
 80056fc:	08005cb9 	.word	0x08005cb9
 8005700:	08005cb9 	.word	0x08005cb9
 8005704:	08005cb9 	.word	0x08005cb9
 8005708:	08005cb9 	.word	0x08005cb9
 800570c:	08005cb9 	.word	0x08005cb9
 8005710:	08005cb9 	.word	0x08005cb9
 8005714:	08005cb9 	.word	0x08005cb9
 8005718:	08005cb9 	.word	0x08005cb9
 800571c:	08005cb9 	.word	0x08005cb9
 8005720:	0800598f 	.word	0x0800598f
 8005724:	080059c9 	.word	0x080059c9
            case 'c': { // Single character field (char).
                char value = '\0';
 8005728:	2300      	movs	r3, #0
 800572a:	f88d 308f 	strb.w	r3, [sp, #143]	; 0x8f

                if (field && minmea_isfield(*field))
 800572e:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005730:	2b00      	cmp	r3, #0
 8005732:	d00b      	beq.n	800574c <minmea_scan+0x14c>
 8005734:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005736:	781b      	ldrb	r3, [r3, #0]
 8005738:	4618      	mov	r0, r3
 800573a:	f7ff ff39 	bl	80055b0 <minmea_isfield>
 800573e:	4603      	mov	r3, r0
 8005740:	2b00      	cmp	r3, #0
 8005742:	d003      	beq.n	800574c <minmea_scan+0x14c>
                    value = *field;
 8005744:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005746:	781b      	ldrb	r3, [r3, #0]
 8005748:	f88d 308f 	strb.w	r3, [sp, #143]	; 0x8f

                *va_arg(ap, char *) = value;
 800574c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800574e:	1d1a      	adds	r2, r3, #4
 8005750:	920b      	str	r2, [sp, #44]	; 0x2c
 8005752:	681b      	ldr	r3, [r3, #0]
 8005754:	f89d 208f 	ldrb.w	r2, [sp, #143]	; 0x8f
 8005758:	701a      	strb	r2, [r3, #0]
            } break;
 800575a:	e28a      	b.n	8005c72 <minmea_scan+0x672>

            case 'd': { // Single character direction field (int).
                int value = 0;
 800575c:	2300      	movs	r3, #0
 800575e:	9322      	str	r3, [sp, #136]	; 0x88

                if (field && minmea_isfield(*field)) {
 8005760:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005762:	2b00      	cmp	r3, #0
 8005764:	d03d      	beq.n	80057e2 <minmea_scan+0x1e2>
 8005766:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005768:	781b      	ldrb	r3, [r3, #0]
 800576a:	4618      	mov	r0, r3
 800576c:	f7ff ff20 	bl	80055b0 <minmea_isfield>
 8005770:	4603      	mov	r3, r0
 8005772:	2b00      	cmp	r3, #0
 8005774:	d035      	beq.n	80057e2 <minmea_scan+0x1e2>
                    switch (*field) {
 8005776:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005778:	781b      	ldrb	r3, [r3, #0]
 800577a:	3b45      	subs	r3, #69	; 0x45
 800577c:	2b12      	cmp	r3, #18
 800577e:	f200 829d 	bhi.w	8005cbc <minmea_scan+0x6bc>
 8005782:	a201      	add	r2, pc, #4	; (adr r2, 8005788 <minmea_scan+0x188>)
 8005784:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005788:	080057d5 	.word	0x080057d5
 800578c:	08005cbd 	.word	0x08005cbd
 8005790:	08005cbd 	.word	0x08005cbd
 8005794:	08005cbd 	.word	0x08005cbd
 8005798:	08005cbd 	.word	0x08005cbd
 800579c:	08005cbd 	.word	0x08005cbd
 80057a0:	08005cbd 	.word	0x08005cbd
 80057a4:	08005cbd 	.word	0x08005cbd
 80057a8:	08005cbd 	.word	0x08005cbd
 80057ac:	080057d5 	.word	0x080057d5
 80057b0:	08005cbd 	.word	0x08005cbd
 80057b4:	08005cbd 	.word	0x08005cbd
 80057b8:	08005cbd 	.word	0x08005cbd
 80057bc:	08005cbd 	.word	0x08005cbd
 80057c0:	080057db 	.word	0x080057db
 80057c4:	08005cbd 	.word	0x08005cbd
 80057c8:	08005cbd 	.word	0x08005cbd
 80057cc:	08005cbd 	.word	0x08005cbd
 80057d0:	080057db 	.word	0x080057db
                        case 'N':
                        case 'E':
                            value = 1;
 80057d4:	2301      	movs	r3, #1
 80057d6:	9322      	str	r3, [sp, #136]	; 0x88
                            break;
 80057d8:	e004      	b.n	80057e4 <minmea_scan+0x1e4>
                        case 'S':
                        case 'W':
                            value = -1;
 80057da:	f04f 33ff 	mov.w	r3, #4294967295
 80057de:	9322      	str	r3, [sp, #136]	; 0x88
                            break;
 80057e0:	e000      	b.n	80057e4 <minmea_scan+0x1e4>
                        default:
                            goto parse_error;
                    }
                }
 80057e2:	bf00      	nop

                *va_arg(ap, int *) = value;
 80057e4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80057e6:	1d1a      	adds	r2, r3, #4
 80057e8:	920b      	str	r2, [sp, #44]	; 0x2c
 80057ea:	681b      	ldr	r3, [r3, #0]
 80057ec:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80057ee:	601a      	str	r2, [r3, #0]
            } break;
 80057f0:	e23f      	b.n	8005c72 <minmea_scan+0x672>

            case 'f': { // Fractional value with scale (struct minmea_float).
                int sign = 0;
 80057f2:	2300      	movs	r3, #0
 80057f4:	9321      	str	r3, [sp, #132]	; 0x84
                int_least32_t value = -1;
 80057f6:	f04f 33ff 	mov.w	r3, #4294967295
 80057fa:	9320      	str	r3, [sp, #128]	; 0x80
                int_least32_t scale = 0;
 80057fc:	2300      	movs	r3, #0
 80057fe:	931f      	str	r3, [sp, #124]	; 0x7c

                if (field) {
 8005800:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005802:	2b00      	cmp	r3, #0
 8005804:	d07d      	beq.n	8005902 <minmea_scan+0x302>
                    while (minmea_isfield(*field)) {
 8005806:	e074      	b.n	80058f2 <minmea_scan+0x2f2>
                        if (*field == '+' && !sign && value == -1) {
 8005808:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800580a:	781b      	ldrb	r3, [r3, #0]
 800580c:	2b2b      	cmp	r3, #43	; 0x2b
 800580e:	d109      	bne.n	8005824 <minmea_scan+0x224>
 8005810:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8005812:	2b00      	cmp	r3, #0
 8005814:	d106      	bne.n	8005824 <minmea_scan+0x224>
 8005816:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8005818:	f1b3 3fff 	cmp.w	r3, #4294967295
 800581c:	d102      	bne.n	8005824 <minmea_scan+0x224>
                            sign = 1;
 800581e:	2301      	movs	r3, #1
 8005820:	9321      	str	r3, [sp, #132]	; 0x84
 8005822:	e063      	b.n	80058ec <minmea_scan+0x2ec>
                        } else if (*field == '-' && !sign && value == -1) {
 8005824:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005826:	781b      	ldrb	r3, [r3, #0]
 8005828:	2b2d      	cmp	r3, #45	; 0x2d
 800582a:	d10a      	bne.n	8005842 <minmea_scan+0x242>
 800582c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800582e:	2b00      	cmp	r3, #0
 8005830:	d107      	bne.n	8005842 <minmea_scan+0x242>
 8005832:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8005834:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005838:	d103      	bne.n	8005842 <minmea_scan+0x242>
                            sign = -1;
 800583a:	f04f 33ff 	mov.w	r3, #4294967295
 800583e:	9321      	str	r3, [sp, #132]	; 0x84
 8005840:	e054      	b.n	80058ec <minmea_scan+0x2ec>
                        } else if (isdigit((unsigned char) *field)) {
 8005842:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005844:	781b      	ldrb	r3, [r3, #0]
 8005846:	3301      	adds	r3, #1
 8005848:	4a87      	ldr	r2, [pc, #540]	; (8005a68 <minmea_scan+0x468>)
 800584a:	4413      	add	r3, r2
 800584c:	781b      	ldrb	r3, [r3, #0]
 800584e:	f003 0304 	and.w	r3, r3, #4
 8005852:	2b00      	cmp	r3, #0
 8005854:	d02e      	beq.n	80058b4 <minmea_scan+0x2b4>
                            int digit = *field - '0';
 8005856:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005858:	781b      	ldrb	r3, [r3, #0]
 800585a:	3b30      	subs	r3, #48	; 0x30
 800585c:	930e      	str	r3, [sp, #56]	; 0x38
                            if (value == -1)
 800585e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8005860:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005864:	d101      	bne.n	800586a <minmea_scan+0x26a>
                                value = 0;
 8005866:	2300      	movs	r3, #0
 8005868:	9320      	str	r3, [sp, #128]	; 0x80
                            if (value > (INT_LEAST32_MAX-digit) / 10) {
 800586a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800586c:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 8005870:	1a9b      	subs	r3, r3, r2
 8005872:	4a7e      	ldr	r2, [pc, #504]	; (8005a6c <minmea_scan+0x46c>)
 8005874:	fb82 1203 	smull	r1, r2, r2, r3
 8005878:	1092      	asrs	r2, r2, #2
 800587a:	17db      	asrs	r3, r3, #31
 800587c:	1ad3      	subs	r3, r2, r3
 800587e:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8005880:	429a      	cmp	r2, r3
 8005882:	dd04      	ble.n	800588e <minmea_scan+0x28e>
                                /* we ran out of bits, what do we do? */
                                if (scale) {
 8005884:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8005886:	2b00      	cmp	r3, #0
 8005888:	f000 821a 	beq.w	8005cc0 <minmea_scan+0x6c0>
                                    /* truncate extra precision */
                                    break;
 800588c:	e039      	b.n	8005902 <minmea_scan+0x302>
                                } else {
                                    /* integer overflow. bail out. */
                                    goto parse_error;
                                }
                            }
                            value = (10 * value) + digit;
 800588e:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8005890:	4613      	mov	r3, r2
 8005892:	009b      	lsls	r3, r3, #2
 8005894:	4413      	add	r3, r2
 8005896:	005b      	lsls	r3, r3, #1
 8005898:	461a      	mov	r2, r3
 800589a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800589c:	4413      	add	r3, r2
 800589e:	9320      	str	r3, [sp, #128]	; 0x80
                            if (scale)
 80058a0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80058a2:	2b00      	cmp	r3, #0
 80058a4:	d022      	beq.n	80058ec <minmea_scan+0x2ec>
                                scale *= 10;
 80058a6:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 80058a8:	4613      	mov	r3, r2
 80058aa:	009b      	lsls	r3, r3, #2
 80058ac:	4413      	add	r3, r2
 80058ae:	005b      	lsls	r3, r3, #1
 80058b0:	931f      	str	r3, [sp, #124]	; 0x7c
 80058b2:	e01b      	b.n	80058ec <minmea_scan+0x2ec>
                        } else if (*field == '.' && scale == 0) {
 80058b4:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80058b6:	781b      	ldrb	r3, [r3, #0]
 80058b8:	2b2e      	cmp	r3, #46	; 0x2e
 80058ba:	d105      	bne.n	80058c8 <minmea_scan+0x2c8>
 80058bc:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80058be:	2b00      	cmp	r3, #0
 80058c0:	d102      	bne.n	80058c8 <minmea_scan+0x2c8>
                            scale = 1;
 80058c2:	2301      	movs	r3, #1
 80058c4:	931f      	str	r3, [sp, #124]	; 0x7c
 80058c6:	e011      	b.n	80058ec <minmea_scan+0x2ec>
                        } else if (*field == ' ') {
 80058c8:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80058ca:	781b      	ldrb	r3, [r3, #0]
 80058cc:	2b20      	cmp	r3, #32
 80058ce:	f040 81f9 	bne.w	8005cc4 <minmea_scan+0x6c4>
                            /* Allow spaces at the start of the field. Not NMEA
                             * conformant, but some modules do this. */
                            if (sign != 0 || value != -1 || scale != 0)
 80058d2:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80058d4:	2b00      	cmp	r3, #0
 80058d6:	f040 81f7 	bne.w	8005cc8 <minmea_scan+0x6c8>
 80058da:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80058dc:	f1b3 3fff 	cmp.w	r3, #4294967295
 80058e0:	f040 81f2 	bne.w	8005cc8 <minmea_scan+0x6c8>
 80058e4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80058e6:	2b00      	cmp	r3, #0
 80058e8:	f040 81ee 	bne.w	8005cc8 <minmea_scan+0x6c8>
                                goto parse_error;
                        } else {
                            goto parse_error;
                        }
                        field++;
 80058ec:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80058ee:	3301      	adds	r3, #1
 80058f0:	9324      	str	r3, [sp, #144]	; 0x90
                    while (minmea_isfield(*field)) {
 80058f2:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80058f4:	781b      	ldrb	r3, [r3, #0]
 80058f6:	4618      	mov	r0, r3
 80058f8:	f7ff fe5a 	bl	80055b0 <minmea_isfield>
 80058fc:	4603      	mov	r3, r0
 80058fe:	2b00      	cmp	r3, #0
 8005900:	d182      	bne.n	8005808 <minmea_scan+0x208>
                    }
                }

                if ((sign || scale) && value == -1)
 8005902:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8005904:	2b00      	cmp	r3, #0
 8005906:	d102      	bne.n	800590e <minmea_scan+0x30e>
 8005908:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800590a:	2b00      	cmp	r3, #0
 800590c:	d004      	beq.n	8005918 <minmea_scan+0x318>
 800590e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8005910:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005914:	f000 81da 	beq.w	8005ccc <minmea_scan+0x6cc>
                    goto parse_error;

                if (value == -1) {
 8005918:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800591a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800591e:	d104      	bne.n	800592a <minmea_scan+0x32a>
                    /* No digits were scanned. */
                    value = 0;
 8005920:	2300      	movs	r3, #0
 8005922:	9320      	str	r3, [sp, #128]	; 0x80
                    scale = 0;
 8005924:	2300      	movs	r3, #0
 8005926:	931f      	str	r3, [sp, #124]	; 0x7c
 8005928:	e004      	b.n	8005934 <minmea_scan+0x334>
                } else if (scale == 0) {
 800592a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800592c:	2b00      	cmp	r3, #0
 800592e:	d101      	bne.n	8005934 <minmea_scan+0x334>
                    /* No decimal point. */
                    scale = 1;
 8005930:	2301      	movs	r3, #1
 8005932:	931f      	str	r3, [sp, #124]	; 0x7c
                }
                if (sign)
 8005934:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8005936:	2b00      	cmp	r3, #0
 8005938:	d004      	beq.n	8005944 <minmea_scan+0x344>
                    value *= sign;
 800593a:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800593c:	9a21      	ldr	r2, [sp, #132]	; 0x84
 800593e:	fb02 f303 	mul.w	r3, r2, r3
 8005942:	9320      	str	r3, [sp, #128]	; 0x80

                *va_arg(ap, struct minmea_float *) = (struct minmea_float) {value, scale};
 8005944:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8005946:	1d1a      	adds	r2, r3, #4
 8005948:	920b      	str	r2, [sp, #44]	; 0x2c
 800594a:	681b      	ldr	r3, [r3, #0]
 800594c:	9a20      	ldr	r2, [sp, #128]	; 0x80
 800594e:	601a      	str	r2, [r3, #0]
 8005950:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 8005952:	605a      	str	r2, [r3, #4]
            } break;
 8005954:	e18d      	b.n	8005c72 <minmea_scan+0x672>

            case 'i': { // Integer value, default 0 (int).
                int value = 0;
 8005956:	2300      	movs	r3, #0
 8005958:	931e      	str	r3, [sp, #120]	; 0x78

                if (field) {
 800595a:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800595c:	2b00      	cmp	r3, #0
 800595e:	d00f      	beq.n	8005980 <minmea_scan+0x380>
                    char *endptr;
                    value = strtol(field, &endptr, 10);
 8005960:	ab04      	add	r3, sp, #16
 8005962:	220a      	movs	r2, #10
 8005964:	4619      	mov	r1, r3
 8005966:	9824      	ldr	r0, [sp, #144]	; 0x90
 8005968:	f001 f980 	bl	8006c6c <strtol>
 800596c:	901e      	str	r0, [sp, #120]	; 0x78
                    if (minmea_isfield(*endptr))
 800596e:	9b04      	ldr	r3, [sp, #16]
 8005970:	781b      	ldrb	r3, [r3, #0]
 8005972:	4618      	mov	r0, r3
 8005974:	f7ff fe1c 	bl	80055b0 <minmea_isfield>
 8005978:	4603      	mov	r3, r0
 800597a:	2b00      	cmp	r3, #0
 800597c:	f040 81a8 	bne.w	8005cd0 <minmea_scan+0x6d0>
                        goto parse_error;
                }

                *va_arg(ap, int *) = value;
 8005980:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8005982:	1d1a      	adds	r2, r3, #4
 8005984:	920b      	str	r2, [sp, #44]	; 0x2c
 8005986:	681b      	ldr	r3, [r3, #0]
 8005988:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 800598a:	601a      	str	r2, [r3, #0]
            } break;
 800598c:	e171      	b.n	8005c72 <minmea_scan+0x672>

            case 's': { // String value (char *).
                char *buf = va_arg(ap, char *);
 800598e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8005990:	1d1a      	adds	r2, r3, #4
 8005992:	920b      	str	r2, [sp, #44]	; 0x2c
 8005994:	681b      	ldr	r3, [r3, #0]
 8005996:	931d      	str	r3, [sp, #116]	; 0x74

                if (field) {
 8005998:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800599a:	2b00      	cmp	r3, #0
 800599c:	d010      	beq.n	80059c0 <minmea_scan+0x3c0>
                    while (minmea_isfield(*field))
 800599e:	e007      	b.n	80059b0 <minmea_scan+0x3b0>
                        *buf++ = *field++;
 80059a0:	9a24      	ldr	r2, [sp, #144]	; 0x90
 80059a2:	1c53      	adds	r3, r2, #1
 80059a4:	9324      	str	r3, [sp, #144]	; 0x90
 80059a6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80059a8:	1c59      	adds	r1, r3, #1
 80059aa:	911d      	str	r1, [sp, #116]	; 0x74
 80059ac:	7812      	ldrb	r2, [r2, #0]
 80059ae:	701a      	strb	r2, [r3, #0]
                    while (minmea_isfield(*field))
 80059b0:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80059b2:	781b      	ldrb	r3, [r3, #0]
 80059b4:	4618      	mov	r0, r3
 80059b6:	f7ff fdfb 	bl	80055b0 <minmea_isfield>
 80059ba:	4603      	mov	r3, r0
 80059bc:	2b00      	cmp	r3, #0
 80059be:	d1ef      	bne.n	80059a0 <minmea_scan+0x3a0>
                }

                *buf = '\0';
 80059c0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80059c2:	2200      	movs	r2, #0
 80059c4:	701a      	strb	r2, [r3, #0]
            } break;
 80059c6:	e154      	b.n	8005c72 <minmea_scan+0x672>

            case 't': { // NMEA talker+sentence identifier (char *).
                // This field is always mandatory.
                if (!field)
 80059c8:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80059ca:	2b00      	cmp	r3, #0
 80059cc:	f000 8182 	beq.w	8005cd4 <minmea_scan+0x6d4>
                    goto parse_error;

                if (field[0] != '$')
 80059d0:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80059d2:	781b      	ldrb	r3, [r3, #0]
 80059d4:	2b24      	cmp	r3, #36	; 0x24
 80059d6:	f040 817f 	bne.w	8005cd8 <minmea_scan+0x6d8>
                    goto parse_error;
                for (int f=0; f<5; f++)
 80059da:	2300      	movs	r3, #0
 80059dc:	931c      	str	r3, [sp, #112]	; 0x70
 80059de:	e012      	b.n	8005a06 <minmea_scan+0x406>
                    if (!minmea_isfield(field[1+f]))
 80059e0:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 80059e2:	3301      	adds	r3, #1
 80059e4:	461a      	mov	r2, r3
 80059e6:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80059e8:	4413      	add	r3, r2
 80059ea:	781b      	ldrb	r3, [r3, #0]
 80059ec:	4618      	mov	r0, r3
 80059ee:	f7ff fddf 	bl	80055b0 <minmea_isfield>
 80059f2:	4603      	mov	r3, r0
 80059f4:	f083 0301 	eor.w	r3, r3, #1
 80059f8:	b2db      	uxtb	r3, r3
 80059fa:	2b00      	cmp	r3, #0
 80059fc:	f040 816e 	bne.w	8005cdc <minmea_scan+0x6dc>
                for (int f=0; f<5; f++)
 8005a00:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8005a02:	3301      	adds	r3, #1
 8005a04:	931c      	str	r3, [sp, #112]	; 0x70
 8005a06:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8005a08:	2b04      	cmp	r3, #4
 8005a0a:	dde9      	ble.n	80059e0 <minmea_scan+0x3e0>
                        goto parse_error;

                char *buf = va_arg(ap, char *);
 8005a0c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8005a0e:	1d1a      	adds	r2, r3, #4
 8005a10:	920b      	str	r2, [sp, #44]	; 0x2c
 8005a12:	681b      	ldr	r3, [r3, #0]
 8005a14:	930f      	str	r3, [sp, #60]	; 0x3c
                memcpy(buf, field+1, 5);
 8005a16:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005a18:	3301      	adds	r3, #1
 8005a1a:	2205      	movs	r2, #5
 8005a1c:	4619      	mov	r1, r3
 8005a1e:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8005a20:	f7fa fc74 	bl	800030c <memcpy>
                buf[5] = '\0';
 8005a24:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8005a26:	3305      	adds	r3, #5
 8005a28:	2200      	movs	r2, #0
 8005a2a:	701a      	strb	r2, [r3, #0]
            } break;
 8005a2c:	e121      	b.n	8005c72 <minmea_scan+0x672>

            case 'D': { // Date (int, int, int), -1 if empty.
                struct minmea_date *date = va_arg(ap, struct minmea_date *);
 8005a2e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8005a30:	1d1a      	adds	r2, r3, #4
 8005a32:	920b      	str	r2, [sp, #44]	; 0x2c
 8005a34:	681b      	ldr	r3, [r3, #0]
 8005a36:	930c      	str	r3, [sp, #48]	; 0x30

                int d = -1, m = -1, y = -1;
 8005a38:	f04f 33ff 	mov.w	r3, #4294967295
 8005a3c:	931b      	str	r3, [sp, #108]	; 0x6c
 8005a3e:	f04f 33ff 	mov.w	r3, #4294967295
 8005a42:	931a      	str	r3, [sp, #104]	; 0x68
 8005a44:	f04f 33ff 	mov.w	r3, #4294967295
 8005a48:	9319      	str	r3, [sp, #100]	; 0x64

                if (field && minmea_isfield(*field)) {
 8005a4a:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005a4c:	2b00      	cmp	r3, #0
 8005a4e:	d058      	beq.n	8005b02 <minmea_scan+0x502>
 8005a50:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005a52:	781b      	ldrb	r3, [r3, #0]
 8005a54:	4618      	mov	r0, r3
 8005a56:	f7ff fdab 	bl	80055b0 <minmea_isfield>
 8005a5a:	4603      	mov	r3, r0
 8005a5c:	2b00      	cmp	r3, #0
 8005a5e:	d050      	beq.n	8005b02 <minmea_scan+0x502>
                    // Always six digits.
                    for (int f=0; f<6; f++)
 8005a60:	2300      	movs	r3, #0
 8005a62:	9318      	str	r3, [sp, #96]	; 0x60
 8005a64:	e014      	b.n	8005a90 <minmea_scan+0x490>
 8005a66:	bf00      	nop
 8005a68:	08007608 	.word	0x08007608
 8005a6c:	66666667 	.word	0x66666667
                        if (!isdigit((unsigned char) field[f]))
 8005a70:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8005a72:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8005a74:	4413      	add	r3, r2
 8005a76:	781b      	ldrb	r3, [r3, #0]
 8005a78:	3301      	adds	r3, #1
 8005a7a:	4a9f      	ldr	r2, [pc, #636]	; (8005cf8 <minmea_scan+0x6f8>)
 8005a7c:	4413      	add	r3, r2
 8005a7e:	781b      	ldrb	r3, [r3, #0]
 8005a80:	f003 0304 	and.w	r3, r3, #4
 8005a84:	2b00      	cmp	r3, #0
 8005a86:	f000 812b 	beq.w	8005ce0 <minmea_scan+0x6e0>
                    for (int f=0; f<6; f++)
 8005a8a:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8005a8c:	3301      	adds	r3, #1
 8005a8e:	9318      	str	r3, [sp, #96]	; 0x60
 8005a90:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8005a92:	2b05      	cmp	r3, #5
 8005a94:	ddec      	ble.n	8005a70 <minmea_scan+0x470>
                            goto parse_error;

                    char dArr[] = {field[0], field[1], '\0'};
 8005a96:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005a98:	781b      	ldrb	r3, [r3, #0]
 8005a9a:	f88d 301c 	strb.w	r3, [sp, #28]
 8005a9e:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005aa0:	785b      	ldrb	r3, [r3, #1]
 8005aa2:	f88d 301d 	strb.w	r3, [sp, #29]
 8005aa6:	2300      	movs	r3, #0
 8005aa8:	f88d 301e 	strb.w	r3, [sp, #30]
                    char mArr[] = {field[2], field[3], '\0'};
 8005aac:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005aae:	789b      	ldrb	r3, [r3, #2]
 8005ab0:	f88d 3018 	strb.w	r3, [sp, #24]
 8005ab4:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005ab6:	78db      	ldrb	r3, [r3, #3]
 8005ab8:	f88d 3019 	strb.w	r3, [sp, #25]
 8005abc:	2300      	movs	r3, #0
 8005abe:	f88d 301a 	strb.w	r3, [sp, #26]
                    char yArr[] = {field[4], field[5], '\0'};
 8005ac2:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005ac4:	791b      	ldrb	r3, [r3, #4]
 8005ac6:	f88d 3014 	strb.w	r3, [sp, #20]
 8005aca:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005acc:	795b      	ldrb	r3, [r3, #5]
 8005ace:	f88d 3015 	strb.w	r3, [sp, #21]
 8005ad2:	2300      	movs	r3, #0
 8005ad4:	f88d 3016 	strb.w	r3, [sp, #22]
                    d = strtol(dArr, NULL, 10);
 8005ad8:	ab07      	add	r3, sp, #28
 8005ada:	220a      	movs	r2, #10
 8005adc:	2100      	movs	r1, #0
 8005ade:	4618      	mov	r0, r3
 8005ae0:	f001 f8c4 	bl	8006c6c <strtol>
 8005ae4:	901b      	str	r0, [sp, #108]	; 0x6c
                    m = strtol(mArr, NULL, 10);
 8005ae6:	ab06      	add	r3, sp, #24
 8005ae8:	220a      	movs	r2, #10
 8005aea:	2100      	movs	r1, #0
 8005aec:	4618      	mov	r0, r3
 8005aee:	f001 f8bd 	bl	8006c6c <strtol>
 8005af2:	901a      	str	r0, [sp, #104]	; 0x68
                    y = strtol(yArr, NULL, 10);
 8005af4:	ab05      	add	r3, sp, #20
 8005af6:	220a      	movs	r2, #10
 8005af8:	2100      	movs	r1, #0
 8005afa:	4618      	mov	r0, r3
 8005afc:	f001 f8b6 	bl	8006c6c <strtol>
 8005b00:	9019      	str	r0, [sp, #100]	; 0x64
                }

                date->day = d;
 8005b02:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8005b04:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8005b06:	601a      	str	r2, [r3, #0]
                date->month = m;
 8005b08:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8005b0a:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8005b0c:	605a      	str	r2, [r3, #4]
                date->year = y;
 8005b0e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8005b10:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8005b12:	609a      	str	r2, [r3, #8]
            } break;
 8005b14:	e0ad      	b.n	8005c72 <minmea_scan+0x672>

            case 'T': { // Time (int, int, int, int), -1 if empty.
                struct minmea_time *time_ = va_arg(ap, struct minmea_time *);
 8005b16:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8005b18:	1d1a      	adds	r2, r3, #4
 8005b1a:	920b      	str	r2, [sp, #44]	; 0x2c
 8005b1c:	681b      	ldr	r3, [r3, #0]
 8005b1e:	930d      	str	r3, [sp, #52]	; 0x34

                int h = -1, i = -1, s = -1, u = -1;
 8005b20:	f04f 33ff 	mov.w	r3, #4294967295
 8005b24:	9317      	str	r3, [sp, #92]	; 0x5c
 8005b26:	f04f 33ff 	mov.w	r3, #4294967295
 8005b2a:	9316      	str	r3, [sp, #88]	; 0x58
 8005b2c:	f04f 33ff 	mov.w	r3, #4294967295
 8005b30:	9315      	str	r3, [sp, #84]	; 0x54
 8005b32:	f04f 33ff 	mov.w	r3, #4294967295
 8005b36:	9314      	str	r3, [sp, #80]	; 0x50

                if (field && minmea_isfield(*field)) {
 8005b38:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005b3a:	2b00      	cmp	r3, #0
 8005b3c:	f000 808b 	beq.w	8005c56 <minmea_scan+0x656>
 8005b40:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005b42:	781b      	ldrb	r3, [r3, #0]
 8005b44:	4618      	mov	r0, r3
 8005b46:	f7ff fd33 	bl	80055b0 <minmea_isfield>
 8005b4a:	4603      	mov	r3, r0
 8005b4c:	2b00      	cmp	r3, #0
 8005b4e:	f000 8082 	beq.w	8005c56 <minmea_scan+0x656>
                    // Minimum required: integer time.
                    for (int f=0; f<6; f++)
 8005b52:	2300      	movs	r3, #0
 8005b54:	9313      	str	r3, [sp, #76]	; 0x4c
 8005b56:	e00f      	b.n	8005b78 <minmea_scan+0x578>
                        if (!isdigit((unsigned char) field[f]))
 8005b58:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8005b5a:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8005b5c:	4413      	add	r3, r2
 8005b5e:	781b      	ldrb	r3, [r3, #0]
 8005b60:	3301      	adds	r3, #1
 8005b62:	4a65      	ldr	r2, [pc, #404]	; (8005cf8 <minmea_scan+0x6f8>)
 8005b64:	4413      	add	r3, r2
 8005b66:	781b      	ldrb	r3, [r3, #0]
 8005b68:	f003 0304 	and.w	r3, r3, #4
 8005b6c:	2b00      	cmp	r3, #0
 8005b6e:	f000 80b9 	beq.w	8005ce4 <minmea_scan+0x6e4>
                    for (int f=0; f<6; f++)
 8005b72:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8005b74:	3301      	adds	r3, #1
 8005b76:	9313      	str	r3, [sp, #76]	; 0x4c
 8005b78:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8005b7a:	2b05      	cmp	r3, #5
 8005b7c:	ddec      	ble.n	8005b58 <minmea_scan+0x558>
                            goto parse_error;

                    char hArr[] = {field[0], field[1], '\0'};
 8005b7e:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005b80:	781b      	ldrb	r3, [r3, #0]
 8005b82:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
 8005b86:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005b88:	785b      	ldrb	r3, [r3, #1]
 8005b8a:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8005b8e:	2300      	movs	r3, #0
 8005b90:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
                    char iArr[] = {field[2], field[3], '\0'};
 8005b94:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005b96:	789b      	ldrb	r3, [r3, #2]
 8005b98:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 8005b9c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005b9e:	78db      	ldrb	r3, [r3, #3]
 8005ba0:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
 8005ba4:	2300      	movs	r3, #0
 8005ba6:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
                    char sArr[] = {field[4], field[5], '\0'};
 8005baa:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005bac:	791b      	ldrb	r3, [r3, #4]
 8005bae:	f88d 3020 	strb.w	r3, [sp, #32]
 8005bb2:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005bb4:	795b      	ldrb	r3, [r3, #5]
 8005bb6:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
 8005bba:	2300      	movs	r3, #0
 8005bbc:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
                    h = strtol(hArr, NULL, 10);
 8005bc0:	ab0a      	add	r3, sp, #40	; 0x28
 8005bc2:	220a      	movs	r2, #10
 8005bc4:	2100      	movs	r1, #0
 8005bc6:	4618      	mov	r0, r3
 8005bc8:	f001 f850 	bl	8006c6c <strtol>
 8005bcc:	9017      	str	r0, [sp, #92]	; 0x5c
                    i = strtol(iArr, NULL, 10);
 8005bce:	ab09      	add	r3, sp, #36	; 0x24
 8005bd0:	220a      	movs	r2, #10
 8005bd2:	2100      	movs	r1, #0
 8005bd4:	4618      	mov	r0, r3
 8005bd6:	f001 f849 	bl	8006c6c <strtol>
 8005bda:	9016      	str	r0, [sp, #88]	; 0x58
                    s = strtol(sArr, NULL, 10);
 8005bdc:	ab08      	add	r3, sp, #32
 8005bde:	220a      	movs	r2, #10
 8005be0:	2100      	movs	r1, #0
 8005be2:	4618      	mov	r0, r3
 8005be4:	f001 f842 	bl	8006c6c <strtol>
 8005be8:	9015      	str	r0, [sp, #84]	; 0x54
                    field += 6;
 8005bea:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005bec:	3306      	adds	r3, #6
 8005bee:	9324      	str	r3, [sp, #144]	; 0x90

                    // Extra: fractional time. Saved as microseconds.
                    if (*field++ == '.') {
 8005bf0:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005bf2:	1c5a      	adds	r2, r3, #1
 8005bf4:	9224      	str	r2, [sp, #144]	; 0x90
 8005bf6:	781b      	ldrb	r3, [r3, #0]
 8005bf8:	2b2e      	cmp	r3, #46	; 0x2e
 8005bfa:	d12a      	bne.n	8005c52 <minmea_scan+0x652>
                        uint32_t value = 0;
 8005bfc:	2300      	movs	r3, #0
 8005bfe:	9312      	str	r3, [sp, #72]	; 0x48
                        uint32_t scale = 1000000LU;
 8005c00:	4b3e      	ldr	r3, [pc, #248]	; (8005cfc <minmea_scan+0x6fc>)
 8005c02:	9311      	str	r3, [sp, #68]	; 0x44
                        while (isdigit((unsigned char) *field) && scale > 1) {
 8005c04:	e012      	b.n	8005c2c <minmea_scan+0x62c>
                            value = (value * 10) + (*field++ - '0');
 8005c06:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8005c08:	4613      	mov	r3, r2
 8005c0a:	009b      	lsls	r3, r3, #2
 8005c0c:	4413      	add	r3, r2
 8005c0e:	005b      	lsls	r3, r3, #1
 8005c10:	4619      	mov	r1, r3
 8005c12:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005c14:	1c5a      	adds	r2, r3, #1
 8005c16:	9224      	str	r2, [sp, #144]	; 0x90
 8005c18:	781b      	ldrb	r3, [r3, #0]
 8005c1a:	440b      	add	r3, r1
 8005c1c:	3b30      	subs	r3, #48	; 0x30
 8005c1e:	9312      	str	r3, [sp, #72]	; 0x48
                            scale /= 10;
 8005c20:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8005c22:	4a37      	ldr	r2, [pc, #220]	; (8005d00 <minmea_scan+0x700>)
 8005c24:	fba2 2303 	umull	r2, r3, r2, r3
 8005c28:	08db      	lsrs	r3, r3, #3
 8005c2a:	9311      	str	r3, [sp, #68]	; 0x44
                        while (isdigit((unsigned char) *field) && scale > 1) {
 8005c2c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8005c2e:	781b      	ldrb	r3, [r3, #0]
 8005c30:	3301      	adds	r3, #1
 8005c32:	4a31      	ldr	r2, [pc, #196]	; (8005cf8 <minmea_scan+0x6f8>)
 8005c34:	4413      	add	r3, r2
 8005c36:	781b      	ldrb	r3, [r3, #0]
 8005c38:	f003 0304 	and.w	r3, r3, #4
 8005c3c:	2b00      	cmp	r3, #0
 8005c3e:	d002      	beq.n	8005c46 <minmea_scan+0x646>
 8005c40:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8005c42:	2b01      	cmp	r3, #1
 8005c44:	d8df      	bhi.n	8005c06 <minmea_scan+0x606>
                        }
                        u = value * scale;
 8005c46:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8005c48:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8005c4a:	fb02 f303 	mul.w	r3, r2, r3
 8005c4e:	9314      	str	r3, [sp, #80]	; 0x50
 8005c50:	e001      	b.n	8005c56 <minmea_scan+0x656>
                    } else {
                        u = 0;
 8005c52:	2300      	movs	r3, #0
 8005c54:	9314      	str	r3, [sp, #80]	; 0x50
                    }
                }

                time_->hours = h;
 8005c56:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005c58:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8005c5a:	601a      	str	r2, [r3, #0]
                time_->minutes = i;
 8005c5c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005c5e:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8005c60:	605a      	str	r2, [r3, #4]
                time_->seconds = s;
 8005c62:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005c64:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8005c66:	609a      	str	r2, [r3, #8]
                time_->microseconds = u;
 8005c68:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005c6a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8005c6c:	60da      	str	r2, [r3, #12]
            } break;
 8005c6e:	e000      	b.n	8005c72 <minmea_scan+0x672>

            case '_': { // Ignore the field.
            } break;
 8005c70:	bf00      	nop
            default: { // Unknown.
                goto parse_error;
            }
        }

        next_field();
 8005c72:	e002      	b.n	8005c7a <minmea_scan+0x67a>
 8005c74:	9b01      	ldr	r3, [sp, #4]
 8005c76:	3301      	adds	r3, #1
 8005c78:	9301      	str	r3, [sp, #4]
 8005c7a:	9b01      	ldr	r3, [sp, #4]
 8005c7c:	781b      	ldrb	r3, [r3, #0]
 8005c7e:	4618      	mov	r0, r3
 8005c80:	f7ff fc96 	bl	80055b0 <minmea_isfield>
 8005c84:	4603      	mov	r3, r0
 8005c86:	2b00      	cmp	r3, #0
 8005c88:	d1f4      	bne.n	8005c74 <minmea_scan+0x674>
 8005c8a:	9b01      	ldr	r3, [sp, #4]
 8005c8c:	781b      	ldrb	r3, [r3, #0]
 8005c8e:	2b2c      	cmp	r3, #44	; 0x2c
 8005c90:	d105      	bne.n	8005c9e <minmea_scan+0x69e>
 8005c92:	9b01      	ldr	r3, [sp, #4]
 8005c94:	3301      	adds	r3, #1
 8005c96:	9301      	str	r3, [sp, #4]
 8005c98:	9b01      	ldr	r3, [sp, #4]
 8005c9a:	9324      	str	r3, [sp, #144]	; 0x90
 8005c9c:	e001      	b.n	8005ca2 <minmea_scan+0x6a2>
 8005c9e:	2300      	movs	r3, #0
 8005ca0:	9324      	str	r3, [sp, #144]	; 0x90
    while (*format) {
 8005ca2:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8005ca4:	781b      	ldrb	r3, [r3, #0]
 8005ca6:	2b00      	cmp	r3, #0
 8005ca8:	f47f acb9 	bne.w	800561e <minmea_scan+0x1e>
    }

    result = true;
 8005cac:	2301      	movs	r3, #1
 8005cae:	f88d 3097 	strb.w	r3, [sp, #151]	; 0x97
 8005cb2:	e018      	b.n	8005ce6 <minmea_scan+0x6e6>
            goto parse_error;
 8005cb4:	bf00      	nop
 8005cb6:	e016      	b.n	8005ce6 <minmea_scan+0x6e6>
                goto parse_error;
 8005cb8:	bf00      	nop
 8005cba:	e014      	b.n	8005ce6 <minmea_scan+0x6e6>
                            goto parse_error;
 8005cbc:	bf00      	nop
 8005cbe:	e012      	b.n	8005ce6 <minmea_scan+0x6e6>
                                    goto parse_error;
 8005cc0:	bf00      	nop
 8005cc2:	e010      	b.n	8005ce6 <minmea_scan+0x6e6>
                            goto parse_error;
 8005cc4:	bf00      	nop
 8005cc6:	e00e      	b.n	8005ce6 <minmea_scan+0x6e6>
                                goto parse_error;
 8005cc8:	bf00      	nop
 8005cca:	e00c      	b.n	8005ce6 <minmea_scan+0x6e6>
                    goto parse_error;
 8005ccc:	bf00      	nop
 8005cce:	e00a      	b.n	8005ce6 <minmea_scan+0x6e6>
                        goto parse_error;
 8005cd0:	bf00      	nop
 8005cd2:	e008      	b.n	8005ce6 <minmea_scan+0x6e6>
                    goto parse_error;
 8005cd4:	bf00      	nop
 8005cd6:	e006      	b.n	8005ce6 <minmea_scan+0x6e6>
                    goto parse_error;
 8005cd8:	bf00      	nop
 8005cda:	e004      	b.n	8005ce6 <minmea_scan+0x6e6>
                        goto parse_error;
 8005cdc:	bf00      	nop
 8005cde:	e002      	b.n	8005ce6 <minmea_scan+0x6e6>
                            goto parse_error;
 8005ce0:	bf00      	nop
 8005ce2:	e000      	b.n	8005ce6 <minmea_scan+0x6e6>
                            goto parse_error;
 8005ce4:	bf00      	nop

parse_error:
    va_end(ap);
    return result;
 8005ce6:	f89d 3097 	ldrb.w	r3, [sp, #151]	; 0x97
 8005cea:	bf00      	nop
}
 8005cec:	4618      	mov	r0, r3
 8005cee:	b026      	add	sp, #152	; 0x98
 8005cf0:	f85d eb04 	ldr.w	lr, [sp], #4
 8005cf4:	b003      	add	sp, #12
 8005cf6:	4770      	bx	lr
 8005cf8:	08007608 	.word	0x08007608
 8005cfc:	000f4240 	.word	0x000f4240
 8005d00:	cccccccd 	.word	0xcccccccd
	...

08005d10 <minmea_sentence_id>:

    return true;
}

enum minmea_sentence_id minmea_sentence_id(const char *sentence, bool strict)
{
 8005d10:	b500      	push	{lr}
 8005d12:	b09f      	sub	sp, #124	; 0x7c
 8005d14:	9001      	str	r0, [sp, #4]
 8005d16:	460b      	mov	r3, r1
 8005d18:	f88d 3003 	strb.w	r3, [sp, #3]
   char buffer[100];

    if (!minmea_check(sentence, strict))
 8005d1c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005d20:	4619      	mov	r1, r3
 8005d22:	9801      	ldr	r0, [sp, #4]
 8005d24:	f7ff fbb4 	bl	8005490 <minmea_check>
 8005d28:	4603      	mov	r3, r0
 8005d2a:	f083 0301 	eor.w	r3, r3, #1
 8005d2e:	b2db      	uxtb	r3, r3
 8005d30:	2b00      	cmp	r3, #0
 8005d32:	d002      	beq.n	8005d3a <minmea_sentence_id+0x2a>
        return MINMEA_INVALID;
 8005d34:	f04f 33ff 	mov.w	r3, #4294967295
 8005d38:	e069      	b.n	8005e0e <minmea_sentence_id+0xfe>

   char type[6];
    if (!minmea_scan(sentence, "t", buffer))
 8005d3a:	ab05      	add	r3, sp, #20
 8005d3c:	461a      	mov	r2, r3
 8005d3e:	4936      	ldr	r1, [pc, #216]	; (8005e18 <minmea_sentence_id+0x108>)
 8005d40:	9801      	ldr	r0, [sp, #4]
 8005d42:	f7ff fc5d 	bl	8005600 <minmea_scan>
 8005d46:	4603      	mov	r3, r0
 8005d48:	f083 0301 	eor.w	r3, r3, #1
 8005d4c:	b2db      	uxtb	r3, r3
 8005d4e:	2b00      	cmp	r3, #0
 8005d50:	d002      	beq.n	8005d58 <minmea_sentence_id+0x48>
       return MINMEA_INVALID;
 8005d52:	f04f 33ff 	mov.w	r3, #4294967295
 8005d56:	e05a      	b.n	8005e0e <minmea_sentence_id+0xfe>


    if (!strcmp(buffer +2, "RMC"))
 8005d58:	ab05      	add	r3, sp, #20
 8005d5a:	3302      	adds	r3, #2
 8005d5c:	492f      	ldr	r1, [pc, #188]	; (8005e1c <minmea_sentence_id+0x10c>)
 8005d5e:	4618      	mov	r0, r3
 8005d60:	f7fa fb72 	bl	8000448 <strcmp>
 8005d64:	4603      	mov	r3, r0
 8005d66:	2b00      	cmp	r3, #0
 8005d68:	d101      	bne.n	8005d6e <minmea_sentence_id+0x5e>
        return MINMEA_SENTENCE_RMC;
 8005d6a:	2301      	movs	r3, #1
 8005d6c:	e04f      	b.n	8005e0e <minmea_sentence_id+0xfe>
    if (!strcmp(buffer +2, "GGA"))
 8005d6e:	ab05      	add	r3, sp, #20
 8005d70:	3302      	adds	r3, #2
 8005d72:	492b      	ldr	r1, [pc, #172]	; (8005e20 <minmea_sentence_id+0x110>)
 8005d74:	4618      	mov	r0, r3
 8005d76:	f7fa fb67 	bl	8000448 <strcmp>
 8005d7a:	4603      	mov	r3, r0
 8005d7c:	2b00      	cmp	r3, #0
 8005d7e:	d101      	bne.n	8005d84 <minmea_sentence_id+0x74>
        return MINMEA_SENTENCE_GGA;
 8005d80:	2302      	movs	r3, #2
 8005d82:	e044      	b.n	8005e0e <minmea_sentence_id+0xfe>
    if (!strcmp(buffer +2, "GSA"))
 8005d84:	ab05      	add	r3, sp, #20
 8005d86:	3302      	adds	r3, #2
 8005d88:	4926      	ldr	r1, [pc, #152]	; (8005e24 <minmea_sentence_id+0x114>)
 8005d8a:	4618      	mov	r0, r3
 8005d8c:	f7fa fb5c 	bl	8000448 <strcmp>
 8005d90:	4603      	mov	r3, r0
 8005d92:	2b00      	cmp	r3, #0
 8005d94:	d101      	bne.n	8005d9a <minmea_sentence_id+0x8a>
        return MINMEA_SENTENCE_GSA;
 8005d96:	2303      	movs	r3, #3
 8005d98:	e039      	b.n	8005e0e <minmea_sentence_id+0xfe>
    if (!strcmp(buffer +2, "GLL"))
 8005d9a:	ab05      	add	r3, sp, #20
 8005d9c:	3302      	adds	r3, #2
 8005d9e:	4922      	ldr	r1, [pc, #136]	; (8005e28 <minmea_sentence_id+0x118>)
 8005da0:	4618      	mov	r0, r3
 8005da2:	f7fa fb51 	bl	8000448 <strcmp>
 8005da6:	4603      	mov	r3, r0
 8005da8:	2b00      	cmp	r3, #0
 8005daa:	d101      	bne.n	8005db0 <minmea_sentence_id+0xa0>
        return MINMEA_SENTENCE_GLL;
 8005dac:	2304      	movs	r3, #4
 8005dae:	e02e      	b.n	8005e0e <minmea_sentence_id+0xfe>
    if (!strcmp(buffer +2, "GST"))
 8005db0:	ab05      	add	r3, sp, #20
 8005db2:	3302      	adds	r3, #2
 8005db4:	491d      	ldr	r1, [pc, #116]	; (8005e2c <minmea_sentence_id+0x11c>)
 8005db6:	4618      	mov	r0, r3
 8005db8:	f7fa fb46 	bl	8000448 <strcmp>
 8005dbc:	4603      	mov	r3, r0
 8005dbe:	2b00      	cmp	r3, #0
 8005dc0:	d101      	bne.n	8005dc6 <minmea_sentence_id+0xb6>
        return MINMEA_SENTENCE_GST;
 8005dc2:	2305      	movs	r3, #5
 8005dc4:	e023      	b.n	8005e0e <minmea_sentence_id+0xfe>
    if (!strcmp(buffer +2, "GSV"))
 8005dc6:	ab05      	add	r3, sp, #20
 8005dc8:	3302      	adds	r3, #2
 8005dca:	4919      	ldr	r1, [pc, #100]	; (8005e30 <minmea_sentence_id+0x120>)
 8005dcc:	4618      	mov	r0, r3
 8005dce:	f7fa fb3b 	bl	8000448 <strcmp>
 8005dd2:	4603      	mov	r3, r0
 8005dd4:	2b00      	cmp	r3, #0
 8005dd6:	d101      	bne.n	8005ddc <minmea_sentence_id+0xcc>
        return MINMEA_SENTENCE_GSV;
 8005dd8:	2306      	movs	r3, #6
 8005dda:	e018      	b.n	8005e0e <minmea_sentence_id+0xfe>
    if (!strcmp(buffer +2, "VTG"))
 8005ddc:	ab05      	add	r3, sp, #20
 8005dde:	3302      	adds	r3, #2
 8005de0:	4914      	ldr	r1, [pc, #80]	; (8005e34 <minmea_sentence_id+0x124>)
 8005de2:	4618      	mov	r0, r3
 8005de4:	f7fa fb30 	bl	8000448 <strcmp>
 8005de8:	4603      	mov	r3, r0
 8005dea:	2b00      	cmp	r3, #0
 8005dec:	d101      	bne.n	8005df2 <minmea_sentence_id+0xe2>
        return MINMEA_SENTENCE_VTG;
 8005dee:	2307      	movs	r3, #7
 8005df0:	e00d      	b.n	8005e0e <minmea_sentence_id+0xfe>
    if (!strcmp(buffer +2, "ZDA"))
 8005df2:	ab05      	add	r3, sp, #20
 8005df4:	3302      	adds	r3, #2
 8005df6:	4910      	ldr	r1, [pc, #64]	; (8005e38 <minmea_sentence_id+0x128>)
 8005df8:	4618      	mov	r0, r3
 8005dfa:	f7fa fb25 	bl	8000448 <strcmp>
 8005dfe:	4603      	mov	r3, r0
 8005e00:	2b00      	cmp	r3, #0
 8005e02:	d101      	bne.n	8005e08 <minmea_sentence_id+0xf8>
        return MINMEA_SENTENCE_ZDA;
 8005e04:	2308      	movs	r3, #8
 8005e06:	e002      	b.n	8005e0e <minmea_sentence_id+0xfe>

    return MINMEA_INVALID;
 8005e08:	f04f 33ff 	mov.w	r3, #4294967295
 8005e0c:	bf00      	nop
}
 8005e0e:	4618      	mov	r0, r3
 8005e10:	b01f      	add	sp, #124	; 0x7c
 8005e12:	f85d fb04 	ldr.w	pc, [sp], #4
 8005e16:	bf00      	nop
 8005e18:	0800709c 	.word	0x0800709c
 8005e1c:	080070a0 	.word	0x080070a0
 8005e20:	080070a4 	.word	0x080070a4
 8005e24:	080070a8 	.word	0x080070a8
 8005e28:	080070ac 	.word	0x080070ac
 8005e2c:	080070b0 	.word	0x080070b0
 8005e30:	080070b4 	.word	0x080070b4
 8005e34:	080070b8 	.word	0x080070b8
 8005e38:	080070bc 	.word	0x080070bc
 8005e3c:	00000000 	.word	0x00000000

08005e40 <minmea_parse_rmc>:

bool minmea_parse_rmc(struct minmea_sentence_rmc *frame, const char *sentence)
{
 8005e40:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005e42:	b095      	sub	sp, #84	; 0x54
 8005e44:	900d      	str	r0, [sp, #52]	; 0x34
 8005e46:	910c      	str	r1, [sp, #48]	; 0x30
    char type[6];
    char validity;
    int latitude_direction;
    int longitude_direction;
    int variation_direction;
    if (!minmea_scan(sentence, "tTcfdfdffDfd",
 8005e48:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005e4a:	930b      	str	r3, [sp, #44]	; 0x2c
 8005e4c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005e4e:	3314      	adds	r3, #20
 8005e50:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8005e52:	321c      	adds	r2, #28
 8005e54:	990d      	ldr	r1, [sp, #52]	; 0x34
 8005e56:	3124      	adds	r1, #36	; 0x24
 8005e58:	980d      	ldr	r0, [sp, #52]	; 0x34
 8005e5a:	302c      	adds	r0, #44	; 0x2c
 8005e5c:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8005e5e:	3434      	adds	r4, #52	; 0x34
 8005e60:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 8005e62:	3540      	adds	r5, #64	; 0x40
 8005e64:	af12      	add	r7, sp, #72	; 0x48
 8005e66:	ae0e      	add	r6, sp, #56	; 0x38
 8005e68:	9609      	str	r6, [sp, #36]	; 0x24
 8005e6a:	9508      	str	r5, [sp, #32]
 8005e6c:	9407      	str	r4, [sp, #28]
 8005e6e:	9006      	str	r0, [sp, #24]
 8005e70:	9105      	str	r1, [sp, #20]
 8005e72:	a90f      	add	r1, sp, #60	; 0x3c
 8005e74:	9104      	str	r1, [sp, #16]
 8005e76:	9203      	str	r2, [sp, #12]
 8005e78:	aa10      	add	r2, sp, #64	; 0x40
 8005e7a:	9202      	str	r2, [sp, #8]
 8005e7c:	9301      	str	r3, [sp, #4]
 8005e7e:	f10d 0347 	add.w	r3, sp, #71	; 0x47
 8005e82:	9300      	str	r3, [sp, #0]
 8005e84:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8005e86:	463a      	mov	r2, r7
 8005e88:	491d      	ldr	r1, [pc, #116]	; (8005f00 <minmea_parse_rmc+0xc0>)
 8005e8a:	980c      	ldr	r0, [sp, #48]	; 0x30
 8005e8c:	f7ff fbb8 	bl	8005600 <minmea_scan>
 8005e90:	4603      	mov	r3, r0
 8005e92:	f083 0301 	eor.w	r3, r3, #1
 8005e96:	b2db      	uxtb	r3, r3
 8005e98:	2b00      	cmp	r3, #0
 8005e9a:	d001      	beq.n	8005ea0 <minmea_parse_rmc+0x60>
            &frame->longitude, &longitude_direction,
            &frame->speed,
            &frame->course,
            &frame->date,
            &frame->variation, &variation_direction))
        return false;
 8005e9c:	2300      	movs	r3, #0
 8005e9e:	e02b      	b.n	8005ef8 <minmea_parse_rmc+0xb8>
    if (strncmp(sentence +3, "RMC",3))
 8005ea0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8005ea2:	3303      	adds	r3, #3
 8005ea4:	2203      	movs	r2, #3
 8005ea6:	4917      	ldr	r1, [pc, #92]	; (8005f04 <minmea_parse_rmc+0xc4>)
 8005ea8:	4618      	mov	r0, r3
 8005eaa:	f000 fefb 	bl	8006ca4 <strncmp>
 8005eae:	4603      	mov	r3, r0
 8005eb0:	2b00      	cmp	r3, #0
 8005eb2:	d001      	beq.n	8005eb8 <minmea_parse_rmc+0x78>
        return false;
 8005eb4:	2300      	movs	r3, #0
 8005eb6:	e01f      	b.n	8005ef8 <minmea_parse_rmc+0xb8>

    frame->valid = (validity == 'A');
 8005eb8:	f89d 3047 	ldrb.w	r3, [sp, #71]	; 0x47
 8005ebc:	2b41      	cmp	r3, #65	; 0x41
 8005ebe:	bf0c      	ite	eq
 8005ec0:	2301      	moveq	r3, #1
 8005ec2:	2300      	movne	r3, #0
 8005ec4:	b2da      	uxtb	r2, r3
 8005ec6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005ec8:	741a      	strb	r2, [r3, #16]
    frame->latitude.value *= latitude_direction;
 8005eca:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005ecc:	695b      	ldr	r3, [r3, #20]
 8005ece:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8005ed0:	fb03 f202 	mul.w	r2, r3, r2
 8005ed4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005ed6:	615a      	str	r2, [r3, #20]
    frame->longitude.value *= longitude_direction;
 8005ed8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005eda:	69db      	ldr	r3, [r3, #28]
 8005edc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8005ede:	fb03 f202 	mul.w	r2, r3, r2
 8005ee2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005ee4:	61da      	str	r2, [r3, #28]
    frame->variation.value *= variation_direction;
 8005ee6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005ee8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005eea:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8005eec:	fb03 f202 	mul.w	r2, r3, r2
 8005ef0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005ef2:	641a      	str	r2, [r3, #64]	; 0x40

    return true;
 8005ef4:	2301      	movs	r3, #1
 8005ef6:	bf00      	nop
}
 8005ef8:	4618      	mov	r0, r3
 8005efa:	b015      	add	sp, #84	; 0x54
 8005efc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005efe:	bf00      	nop
 8005f00:	080070c0 	.word	0x080070c0
 8005f04:	080070a0 	.word	0x080070a0
	...

08005f10 <minmea_parse_gga>:

bool minmea_parse_gga(struct minmea_sentence_gga *frame, const char *sentence)
{
 8005f10:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005f12:	b097      	sub	sp, #92	; 0x5c
 8005f14:	9011      	str	r0, [sp, #68]	; 0x44
 8005f16:	9110      	str	r1, [sp, #64]	; 0x40
    // $GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47
    char type[6];
    int latitude_direction;
    int longitude_direction;

    if (!minmea_scan(sentence, "tTfdfdiiffcfcf_",
 8005f18:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8005f1a:	930d      	str	r3, [sp, #52]	; 0x34
 8005f1c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8005f1e:	3310      	adds	r3, #16
 8005f20:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8005f22:	3218      	adds	r2, #24
 8005f24:	9911      	ldr	r1, [sp, #68]	; 0x44
 8005f26:	3120      	adds	r1, #32
 8005f28:	9811      	ldr	r0, [sp, #68]	; 0x44
 8005f2a:	3024      	adds	r0, #36	; 0x24
 8005f2c:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8005f2e:	3428      	adds	r4, #40	; 0x28
 8005f30:	9d11      	ldr	r5, [sp, #68]	; 0x44
 8005f32:	3530      	adds	r5, #48	; 0x30
 8005f34:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8005f36:	3638      	adds	r6, #56	; 0x38
 8005f38:	9f11      	ldr	r7, [sp, #68]	; 0x44
 8005f3a:	373c      	adds	r7, #60	; 0x3c
 8005f3c:	f8dd c044 	ldr.w	ip, [sp, #68]	; 0x44
 8005f40:	f10c 0c44 	add.w	ip, ip, #68	; 0x44
 8005f44:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
 8005f48:	f8dd e044 	ldr.w	lr, [sp, #68]	; 0x44
 8005f4c:	f10e 0e48 	add.w	lr, lr, #72	; 0x48
 8005f50:	f8cd e03c 	str.w	lr, [sp, #60]	; 0x3c
 8005f54:	f10d 0c50 	add.w	ip, sp, #80	; 0x50
 8005f58:	f8dd e03c 	ldr.w	lr, [sp, #60]	; 0x3c
 8005f5c:	f8cd e02c 	str.w	lr, [sp, #44]	; 0x2c
 8005f60:	f8dd e038 	ldr.w	lr, [sp, #56]	; 0x38
 8005f64:	f8cd e028 	str.w	lr, [sp, #40]	; 0x28
 8005f68:	9709      	str	r7, [sp, #36]	; 0x24
 8005f6a:	9608      	str	r6, [sp, #32]
 8005f6c:	9507      	str	r5, [sp, #28]
 8005f6e:	9406      	str	r4, [sp, #24]
 8005f70:	9005      	str	r0, [sp, #20]
 8005f72:	9104      	str	r1, [sp, #16]
 8005f74:	a912      	add	r1, sp, #72	; 0x48
 8005f76:	9103      	str	r1, [sp, #12]
 8005f78:	9202      	str	r2, [sp, #8]
 8005f7a:	aa13      	add	r2, sp, #76	; 0x4c
 8005f7c:	9201      	str	r2, [sp, #4]
 8005f7e:	9300      	str	r3, [sp, #0]
 8005f80:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005f82:	4662      	mov	r2, ip
 8005f84:	4915      	ldr	r1, [pc, #84]	; (8005fdc <minmea_parse_gga+0xcc>)
 8005f86:	9810      	ldr	r0, [sp, #64]	; 0x40
 8005f88:	f7ff fb3a 	bl	8005600 <minmea_scan>
 8005f8c:	4603      	mov	r3, r0
 8005f8e:	f083 0301 	eor.w	r3, r3, #1
 8005f92:	b2db      	uxtb	r3, r3
 8005f94:	2b00      	cmp	r3, #0
 8005f96:	d001      	beq.n	8005f9c <minmea_parse_gga+0x8c>
            &frame->satellites_tracked,
            &frame->hdop,
            &frame->altitude, &frame->altitude_units,
            &frame->height, &frame->height_units,
            &frame->dgps_age))
        return false;
 8005f98:	2300      	movs	r3, #0
 8005f9a:	e01b      	b.n	8005fd4 <minmea_parse_gga+0xc4>
    if (strncmp(sentence +3, "GGA",3))
 8005f9c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8005f9e:	3303      	adds	r3, #3
 8005fa0:	2203      	movs	r2, #3
 8005fa2:	490f      	ldr	r1, [pc, #60]	; (8005fe0 <minmea_parse_gga+0xd0>)
 8005fa4:	4618      	mov	r0, r3
 8005fa6:	f000 fe7d 	bl	8006ca4 <strncmp>
 8005faa:	4603      	mov	r3, r0
 8005fac:	2b00      	cmp	r3, #0
 8005fae:	d001      	beq.n	8005fb4 <minmea_parse_gga+0xa4>
        return false;
 8005fb0:	2300      	movs	r3, #0
 8005fb2:	e00f      	b.n	8005fd4 <minmea_parse_gga+0xc4>

    frame->latitude.value *= latitude_direction;
 8005fb4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8005fb6:	691b      	ldr	r3, [r3, #16]
 8005fb8:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8005fba:	fb03 f202 	mul.w	r2, r3, r2
 8005fbe:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8005fc0:	611a      	str	r2, [r3, #16]
    frame->longitude.value *= longitude_direction;
 8005fc2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8005fc4:	699b      	ldr	r3, [r3, #24]
 8005fc6:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8005fc8:	fb03 f202 	mul.w	r2, r3, r2
 8005fcc:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8005fce:	619a      	str	r2, [r3, #24]

    return true;
 8005fd0:	2301      	movs	r3, #1
 8005fd2:	bf00      	nop
}
 8005fd4:	4618      	mov	r0, r3
 8005fd6:	b017      	add	sp, #92	; 0x5c
 8005fd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005fda:	bf00      	nop
 8005fdc:	080070d0 	.word	0x080070d0
 8005fe0:	080070a4 	.word	0x080070a4
	...

08005ff0 <minmea_parse_gll>:

    return true;
}

bool minmea_parse_gll(struct minmea_sentence_gll *frame, const char *sentence)
{
 8005ff0:	b530      	push	{r4, r5, lr}
 8005ff2:	b08d      	sub	sp, #52	; 0x34
 8005ff4:	9007      	str	r0, [sp, #28]
 8005ff6:	9106      	str	r1, [sp, #24]
    // $GPGLL,3723.2475,N,12158.3416,W,161229.487,A,A*41$;
    char type[6];
    int latitude_direction;
    int longitude_direction;

    if (!minmea_scan(sentence, "tfdfdTc;c",
 8005ff8:	9d07      	ldr	r5, [sp, #28]
 8005ffa:	9b07      	ldr	r3, [sp, #28]
 8005ffc:	3308      	adds	r3, #8
 8005ffe:	9a07      	ldr	r2, [sp, #28]
 8006000:	3210      	adds	r2, #16
 8006002:	9907      	ldr	r1, [sp, #28]
 8006004:	3120      	adds	r1, #32
 8006006:	9807      	ldr	r0, [sp, #28]
 8006008:	3021      	adds	r0, #33	; 0x21
 800600a:	ac0a      	add	r4, sp, #40	; 0x28
 800600c:	9005      	str	r0, [sp, #20]
 800600e:	9104      	str	r1, [sp, #16]
 8006010:	9203      	str	r2, [sp, #12]
 8006012:	aa08      	add	r2, sp, #32
 8006014:	9202      	str	r2, [sp, #8]
 8006016:	9301      	str	r3, [sp, #4]
 8006018:	ab09      	add	r3, sp, #36	; 0x24
 800601a:	9300      	str	r3, [sp, #0]
 800601c:	462b      	mov	r3, r5
 800601e:	4622      	mov	r2, r4
 8006020:	4915      	ldr	r1, [pc, #84]	; (8006078 <minmea_parse_gll+0x88>)
 8006022:	9806      	ldr	r0, [sp, #24]
 8006024:	f7ff faec 	bl	8005600 <minmea_scan>
 8006028:	4603      	mov	r3, r0
 800602a:	f083 0301 	eor.w	r3, r3, #1
 800602e:	b2db      	uxtb	r3, r3
 8006030:	2b00      	cmp	r3, #0
 8006032:	d001      	beq.n	8006038 <minmea_parse_gll+0x48>
            &frame->latitude, &latitude_direction,
            &frame->longitude, &longitude_direction,
            &frame->time,
            &frame->status,
            &frame->mode))
        return false;
 8006034:	2300      	movs	r3, #0
 8006036:	e01b      	b.n	8006070 <minmea_parse_gll+0x80>
    if (strncmp(sentence +3, "GLL", 3))
 8006038:	9b06      	ldr	r3, [sp, #24]
 800603a:	3303      	adds	r3, #3
 800603c:	2203      	movs	r2, #3
 800603e:	490f      	ldr	r1, [pc, #60]	; (800607c <minmea_parse_gll+0x8c>)
 8006040:	4618      	mov	r0, r3
 8006042:	f000 fe2f 	bl	8006ca4 <strncmp>
 8006046:	4603      	mov	r3, r0
 8006048:	2b00      	cmp	r3, #0
 800604a:	d001      	beq.n	8006050 <minmea_parse_gll+0x60>
        return false;
 800604c:	2300      	movs	r3, #0
 800604e:	e00f      	b.n	8006070 <minmea_parse_gll+0x80>

    frame->latitude.value *= latitude_direction;
 8006050:	9b07      	ldr	r3, [sp, #28]
 8006052:	681b      	ldr	r3, [r3, #0]
 8006054:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8006056:	fb03 f202 	mul.w	r2, r3, r2
 800605a:	9b07      	ldr	r3, [sp, #28]
 800605c:	601a      	str	r2, [r3, #0]
    frame->longitude.value *= longitude_direction;
 800605e:	9b07      	ldr	r3, [sp, #28]
 8006060:	689b      	ldr	r3, [r3, #8]
 8006062:	9a08      	ldr	r2, [sp, #32]
 8006064:	fb03 f202 	mul.w	r2, r3, r2
 8006068:	9b07      	ldr	r3, [sp, #28]
 800606a:	609a      	str	r2, [r3, #8]

    return true;
 800606c:	2301      	movs	r3, #1
 800606e:	bf00      	nop
}
 8006070:	4618      	mov	r0, r3
 8006072:	b00d      	add	sp, #52	; 0x34
 8006074:	bd30      	pop	{r4, r5, pc}
 8006076:	bf00      	nop
 8006078:	080070e0 	.word	0x080070e0
 800607c:	080070ac 	.word	0x080070ac

08006080 <minmea_parse_gst>:

bool minmea_parse_gst(struct minmea_sentence_gst *frame, const char *sentence)
{
 8006080:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006082:	b08f      	sub	sp, #60	; 0x3c
 8006084:	900b      	str	r0, [sp, #44]	; 0x2c
 8006086:	910a      	str	r1, [sp, #40]	; 0x28
    // $GPGST,024603.00,3.2,6.6,4.7,47.3,5.8,5.6,22.0*58
    char type[6];

    if (!minmea_scan(sentence, "tTfffffff",
 8006088:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800608a:	9309      	str	r3, [sp, #36]	; 0x24
 800608c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800608e:	3310      	adds	r3, #16
 8006090:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8006092:	3218      	adds	r2, #24
 8006094:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8006096:	3120      	adds	r1, #32
 8006098:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800609a:	3028      	adds	r0, #40	; 0x28
 800609c:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 800609e:	3430      	adds	r4, #48	; 0x30
 80060a0:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80060a2:	3538      	adds	r5, #56	; 0x38
 80060a4:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 80060a6:	3640      	adds	r6, #64	; 0x40
 80060a8:	af0c      	add	r7, sp, #48	; 0x30
 80060aa:	9606      	str	r6, [sp, #24]
 80060ac:	9505      	str	r5, [sp, #20]
 80060ae:	9404      	str	r4, [sp, #16]
 80060b0:	9003      	str	r0, [sp, #12]
 80060b2:	9102      	str	r1, [sp, #8]
 80060b4:	9201      	str	r2, [sp, #4]
 80060b6:	9300      	str	r3, [sp, #0]
 80060b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80060ba:	463a      	mov	r2, r7
 80060bc:	490e      	ldr	r1, [pc, #56]	; (80060f8 <minmea_parse_gst+0x78>)
 80060be:	980a      	ldr	r0, [sp, #40]	; 0x28
 80060c0:	f7ff fa9e 	bl	8005600 <minmea_scan>
 80060c4:	4603      	mov	r3, r0
 80060c6:	f083 0301 	eor.w	r3, r3, #1
 80060ca:	b2db      	uxtb	r3, r3
 80060cc:	2b00      	cmp	r3, #0
 80060ce:	d001      	beq.n	80060d4 <minmea_parse_gst+0x54>
            &frame->semi_minor_deviation,
            &frame->semi_major_orientation,
            &frame->latitude_error_deviation,
            &frame->longitude_error_deviation,
            &frame->altitude_error_deviation))
        return false;
 80060d0:	2300      	movs	r3, #0
 80060d2:	e00d      	b.n	80060f0 <minmea_parse_gst+0x70>
    if (strncmp(sentence +3, "GST", 3))
 80060d4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80060d6:	3303      	adds	r3, #3
 80060d8:	2203      	movs	r2, #3
 80060da:	4908      	ldr	r1, [pc, #32]	; (80060fc <minmea_parse_gst+0x7c>)
 80060dc:	4618      	mov	r0, r3
 80060de:	f000 fde1 	bl	8006ca4 <strncmp>
 80060e2:	4603      	mov	r3, r0
 80060e4:	2b00      	cmp	r3, #0
 80060e6:	d001      	beq.n	80060ec <minmea_parse_gst+0x6c>
        return false;
 80060e8:	2300      	movs	r3, #0
 80060ea:	e001      	b.n	80060f0 <minmea_parse_gst+0x70>

    return true;
 80060ec:	2301      	movs	r3, #1
 80060ee:	bf00      	nop
}
 80060f0:	4618      	mov	r0, r3
 80060f2:	b00f      	add	sp, #60	; 0x3c
 80060f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80060f6:	bf00      	nop
 80060f8:	080070ec 	.word	0x080070ec
 80060fc:	080070b0 	.word	0x080070b0

08006100 <minmea_parse_gsv>:

bool minmea_parse_gsv(struct minmea_sentence_gsv *frame, const char *sentence)
{
 8006100:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006102:	b0a3      	sub	sp, #140	; 0x8c
 8006104:	901f      	str	r0, [sp, #124]	; 0x7c
 8006106:	911e      	str	r1, [sp, #120]	; 0x78
    // $GPGSV,4,2,11,08,51,203,30,09,45,215,28*75
    // $GPGSV,4,4,13,39,31,170,27*40
    // $GPGSV,4,4,13*7B
    char type[6];

    if (!minmea_scan(sentence, "tiii;iiiiiiiiiiiiiiii",
 8006108:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800610a:	9312      	str	r3, [sp, #72]	; 0x48
 800610c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800610e:	1d1e      	adds	r6, r3, #4
 8006110:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8006112:	f103 0708 	add.w	r7, r3, #8
 8006116:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8006118:	f103 020c 	add.w	r2, r3, #12
 800611c:	9213      	str	r2, [sp, #76]	; 0x4c
 800611e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8006120:	f103 0110 	add.w	r1, r3, #16
 8006124:	9114      	str	r1, [sp, #80]	; 0x50
 8006126:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8006128:	f103 0014 	add.w	r0, r3, #20
 800612c:	9015      	str	r0, [sp, #84]	; 0x54
 800612e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8006130:	f103 0418 	add.w	r4, r3, #24
 8006134:	9416      	str	r4, [sp, #88]	; 0x58
 8006136:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8006138:	f103 051c 	add.w	r5, r3, #28
 800613c:	9517      	str	r5, [sp, #92]	; 0x5c
 800613e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8006140:	f103 0c20 	add.w	ip, r3, #32
 8006144:	f8cd c060 	str.w	ip, [sp, #96]	; 0x60
 8006148:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800614a:	f103 0e24 	add.w	lr, r3, #36	; 0x24
 800614e:	f8cd e064 	str.w	lr, [sp, #100]	; 0x64
 8006152:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8006154:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8006158:	921a      	str	r2, [sp, #104]	; 0x68
 800615a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800615c:	f103 012c 	add.w	r1, r3, #44	; 0x2c
 8006160:	911b      	str	r1, [sp, #108]	; 0x6c
 8006162:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8006164:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8006168:	901c      	str	r0, [sp, #112]	; 0x70
 800616a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800616c:	f103 0434 	add.w	r4, r3, #52	; 0x34
 8006170:	941d      	str	r4, [sp, #116]	; 0x74
 8006172:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8006174:	f103 0538 	add.w	r5, r3, #56	; 0x38
 8006178:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800617a:	f103 043c 	add.w	r4, r3, #60	; 0x3c
 800617e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8006180:	f103 0040 	add.w	r0, r3, #64	; 0x40
 8006184:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8006186:	f103 0244 	add.w	r2, r3, #68	; 0x44
 800618a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800618c:	3348      	adds	r3, #72	; 0x48
 800618e:	a920      	add	r1, sp, #128	; 0x80
 8006190:	9311      	str	r3, [sp, #68]	; 0x44
 8006192:	9210      	str	r2, [sp, #64]	; 0x40
 8006194:	900f      	str	r0, [sp, #60]	; 0x3c
 8006196:	940e      	str	r4, [sp, #56]	; 0x38
 8006198:	950d      	str	r5, [sp, #52]	; 0x34
 800619a:	9c1d      	ldr	r4, [sp, #116]	; 0x74
 800619c:	940c      	str	r4, [sp, #48]	; 0x30
 800619e:	981c      	ldr	r0, [sp, #112]	; 0x70
 80061a0:	900b      	str	r0, [sp, #44]	; 0x2c
 80061a2:	981b      	ldr	r0, [sp, #108]	; 0x6c
 80061a4:	900a      	str	r0, [sp, #40]	; 0x28
 80061a6:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 80061a8:	9209      	str	r2, [sp, #36]	; 0x24
 80061aa:	f8dd e064 	ldr.w	lr, [sp, #100]	; 0x64
 80061ae:	f8cd e020 	str.w	lr, [sp, #32]
 80061b2:	f8dd c060 	ldr.w	ip, [sp, #96]	; 0x60
 80061b6:	f8cd c01c 	str.w	ip, [sp, #28]
 80061ba:	9d17      	ldr	r5, [sp, #92]	; 0x5c
 80061bc:	9506      	str	r5, [sp, #24]
 80061be:	9c16      	ldr	r4, [sp, #88]	; 0x58
 80061c0:	9405      	str	r4, [sp, #20]
 80061c2:	9815      	ldr	r0, [sp, #84]	; 0x54
 80061c4:	9004      	str	r0, [sp, #16]
 80061c6:	9814      	ldr	r0, [sp, #80]	; 0x50
 80061c8:	9003      	str	r0, [sp, #12]
 80061ca:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80061cc:	9202      	str	r2, [sp, #8]
 80061ce:	9701      	str	r7, [sp, #4]
 80061d0:	9600      	str	r6, [sp, #0]
 80061d2:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80061d4:	460a      	mov	r2, r1
 80061d6:	490e      	ldr	r1, [pc, #56]	; (8006210 <minmea_parse_gsv+0x110>)
 80061d8:	981e      	ldr	r0, [sp, #120]	; 0x78
 80061da:	f7ff fa11 	bl	8005600 <minmea_scan>
 80061de:	4603      	mov	r3, r0
 80061e0:	f083 0301 	eor.w	r3, r3, #1
 80061e4:	b2db      	uxtb	r3, r3
 80061e6:	2b00      	cmp	r3, #0
 80061e8:	d001      	beq.n	80061ee <minmea_parse_gsv+0xee>
            &frame->sats[3].nr,
            &frame->sats[3].elevation,
            &frame->sats[3].azimuth,
            &frame->sats[3].snr
            )) {
        return false;
 80061ea:	2300      	movs	r3, #0
 80061ec:	e00d      	b.n	800620a <minmea_parse_gsv+0x10a>
    }
    if (strncmp(sentence +3, "GSV", 3))
 80061ee:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 80061f0:	3303      	adds	r3, #3
 80061f2:	2203      	movs	r2, #3
 80061f4:	4907      	ldr	r1, [pc, #28]	; (8006214 <minmea_parse_gsv+0x114>)
 80061f6:	4618      	mov	r0, r3
 80061f8:	f000 fd54 	bl	8006ca4 <strncmp>
 80061fc:	4603      	mov	r3, r0
 80061fe:	2b00      	cmp	r3, #0
 8006200:	d001      	beq.n	8006206 <minmea_parse_gsv+0x106>
        return false;
 8006202:	2300      	movs	r3, #0
 8006204:	e001      	b.n	800620a <minmea_parse_gsv+0x10a>

    return true;
 8006206:	2301      	movs	r3, #1
 8006208:	bf00      	nop
}
 800620a:	4618      	mov	r0, r3
 800620c:	b023      	add	sp, #140	; 0x8c
 800620e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006210:	080070f8 	.word	0x080070f8
 8006214:	080070b4 	.word	0x080070b4
	...

08006220 <minmea_parse_vtg>:

bool minmea_parse_vtg(struct minmea_sentence_vtg *frame, const char *sentence)
{
 8006220:	b530      	push	{r4, r5, lr}
 8006222:	b08f      	sub	sp, #60	; 0x3c
 8006224:	9009      	str	r0, [sp, #36]	; 0x24
 8006226:	9108      	str	r1, [sp, #32]
    // $GPVTG,096.5,T,083.5,M,0.0,N,0.0,K,D*22
    // $GPVTG,188.36,T,,M,0.820,N,1.519,K,A*3F
    char type[6];
    char c_true, c_magnetic, c_knots, c_kph, c_faa_mode;

    if (!minmea_scan(sentence, "tfcfcfcfc;c",
 8006228:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800622a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800622c:	3308      	adds	r3, #8
 800622e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8006230:	3210      	adds	r2, #16
 8006232:	9909      	ldr	r1, [sp, #36]	; 0x24
 8006234:	3118      	adds	r1, #24
 8006236:	ac0c      	add	r4, sp, #48	; 0x30
 8006238:	f10d 002b 	add.w	r0, sp, #43	; 0x2b
 800623c:	9007      	str	r0, [sp, #28]
 800623e:	a80b      	add	r0, sp, #44	; 0x2c
 8006240:	9006      	str	r0, [sp, #24]
 8006242:	9105      	str	r1, [sp, #20]
 8006244:	f10d 012d 	add.w	r1, sp, #45	; 0x2d
 8006248:	9104      	str	r1, [sp, #16]
 800624a:	9203      	str	r2, [sp, #12]
 800624c:	f10d 022e 	add.w	r2, sp, #46	; 0x2e
 8006250:	9202      	str	r2, [sp, #8]
 8006252:	9301      	str	r3, [sp, #4]
 8006254:	f10d 032f 	add.w	r3, sp, #47	; 0x2f
 8006258:	9300      	str	r3, [sp, #0]
 800625a:	462b      	mov	r3, r5
 800625c:	4622      	mov	r2, r4
 800625e:	491a      	ldr	r1, [pc, #104]	; (80062c8 <minmea_parse_vtg+0xa8>)
 8006260:	9808      	ldr	r0, [sp, #32]
 8006262:	f7ff f9cd 	bl	8005600 <minmea_scan>
 8006266:	4603      	mov	r3, r0
 8006268:	f083 0301 	eor.w	r3, r3, #1
 800626c:	b2db      	uxtb	r3, r3
 800626e:	2b00      	cmp	r3, #0
 8006270:	d001      	beq.n	8006276 <minmea_parse_vtg+0x56>
            &frame->speed_knots,
            &c_knots,
            &frame->speed_kph,
            &c_kph,
            &c_faa_mode))
        return false;
 8006272:	2300      	movs	r3, #0
 8006274:	e024      	b.n	80062c0 <minmea_parse_vtg+0xa0>
    if (strncmp(sentence +3, "VTG",3))
 8006276:	9b08      	ldr	r3, [sp, #32]
 8006278:	3303      	adds	r3, #3
 800627a:	2203      	movs	r2, #3
 800627c:	4913      	ldr	r1, [pc, #76]	; (80062cc <minmea_parse_vtg+0xac>)
 800627e:	4618      	mov	r0, r3
 8006280:	f000 fd10 	bl	8006ca4 <strncmp>
 8006284:	4603      	mov	r3, r0
 8006286:	2b00      	cmp	r3, #0
 8006288:	d001      	beq.n	800628e <minmea_parse_vtg+0x6e>
        return false;
 800628a:	2300      	movs	r3, #0
 800628c:	e018      	b.n	80062c0 <minmea_parse_vtg+0xa0>
    // check chars
    if (c_true != 'T' ||
 800628e:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
 8006292:	2b54      	cmp	r3, #84	; 0x54
 8006294:	d10b      	bne.n	80062ae <minmea_parse_vtg+0x8e>
        c_magnetic != 'M' ||
 8006296:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
    if (c_true != 'T' ||
 800629a:	2b4d      	cmp	r3, #77	; 0x4d
 800629c:	d107      	bne.n	80062ae <minmea_parse_vtg+0x8e>
        c_knots != 'N' ||
 800629e:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
        c_magnetic != 'M' ||
 80062a2:	2b4e      	cmp	r3, #78	; 0x4e
 80062a4:	d103      	bne.n	80062ae <minmea_parse_vtg+0x8e>
        c_kph != 'K')
 80062a6:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
        c_knots != 'N' ||
 80062aa:	2b4b      	cmp	r3, #75	; 0x4b
 80062ac:	d001      	beq.n	80062b2 <minmea_parse_vtg+0x92>
        return false;
 80062ae:	2300      	movs	r3, #0
 80062b0:	e006      	b.n	80062c0 <minmea_parse_vtg+0xa0>
    frame->faa_mode = (enum minmea_faa_mode)c_faa_mode;
 80062b2:	f89d 202b 	ldrb.w	r2, [sp, #43]	; 0x2b
 80062b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80062b8:	f883 2020 	strb.w	r2, [r3, #32]

    return true;
 80062bc:	2301      	movs	r3, #1
 80062be:	bf00      	nop
}
 80062c0:	4618      	mov	r0, r3
 80062c2:	b00f      	add	sp, #60	; 0x3c
 80062c4:	bd30      	pop	{r4, r5, pc}
 80062c6:	bf00      	nop
 80062c8:	08007110 	.word	0x08007110
 80062cc:	080070b8 	.word	0x080070b8

080062d0 <minmea_parse_zda>:

bool minmea_parse_zda(struct minmea_sentence_zda *frame, const char *sentence)
{
 80062d0:	b570      	push	{r4, r5, r6, lr}
 80062d2:	b08a      	sub	sp, #40	; 0x28
 80062d4:	9007      	str	r0, [sp, #28]
 80062d6:	9106      	str	r1, [sp, #24]
  // $GPZDA,201530.00,04,07,2002,00,00*60
  char type[6];

  if(!minmea_scan(sentence, "tTiiiii",
 80062d8:	9e07      	ldr	r6, [sp, #28]
 80062da:	9b07      	ldr	r3, [sp, #28]
 80062dc:	3310      	adds	r3, #16
 80062de:	9a07      	ldr	r2, [sp, #28]
 80062e0:	3214      	adds	r2, #20
 80062e2:	9907      	ldr	r1, [sp, #28]
 80062e4:	3118      	adds	r1, #24
 80062e6:	9807      	ldr	r0, [sp, #28]
 80062e8:	301c      	adds	r0, #28
 80062ea:	9c07      	ldr	r4, [sp, #28]
 80062ec:	3420      	adds	r4, #32
 80062ee:	ad08      	add	r5, sp, #32
 80062f0:	9404      	str	r4, [sp, #16]
 80062f2:	9003      	str	r0, [sp, #12]
 80062f4:	9102      	str	r1, [sp, #8]
 80062f6:	9201      	str	r2, [sp, #4]
 80062f8:	9300      	str	r3, [sp, #0]
 80062fa:	4633      	mov	r3, r6
 80062fc:	462a      	mov	r2, r5
 80062fe:	4917      	ldr	r1, [pc, #92]	; (800635c <minmea_parse_zda+0x8c>)
 8006300:	9806      	ldr	r0, [sp, #24]
 8006302:	f7ff f97d 	bl	8005600 <minmea_scan>
 8006306:	4603      	mov	r3, r0
 8006308:	f083 0301 	eor.w	r3, r3, #1
 800630c:	b2db      	uxtb	r3, r3
 800630e:	2b00      	cmp	r3, #0
 8006310:	d001      	beq.n	8006316 <minmea_parse_zda+0x46>
          &frame->date.day,
          &frame->date.month,
          &frame->date.year,
          &frame->hour_offset,
          &frame->minute_offset))
      return false;
 8006312:	2300      	movs	r3, #0
 8006314:	e01e      	b.n	8006354 <minmea_parse_zda+0x84>
  if (strncmp(sentence +3, "ZDA", 3))
 8006316:	9b06      	ldr	r3, [sp, #24]
 8006318:	3303      	adds	r3, #3
 800631a:	2203      	movs	r2, #3
 800631c:	4910      	ldr	r1, [pc, #64]	; (8006360 <minmea_parse_zda+0x90>)
 800631e:	4618      	mov	r0, r3
 8006320:	f000 fcc0 	bl	8006ca4 <strncmp>
 8006324:	4603      	mov	r3, r0
 8006326:	2b00      	cmp	r3, #0
 8006328:	d001      	beq.n	800632e <minmea_parse_zda+0x5e>
      return false;
 800632a:	2300      	movs	r3, #0
 800632c:	e012      	b.n	8006354 <minmea_parse_zda+0x84>

  // check offsets
  if (abs(frame->hour_offset) > 13 ||
 800632e:	9b07      	ldr	r3, [sp, #28]
 8006330:	69db      	ldr	r3, [r3, #28]
 8006332:	2b00      	cmp	r3, #0
 8006334:	bfb8      	it	lt
 8006336:	425b      	neglt	r3, r3
 8006338:	2b0d      	cmp	r3, #13
 800633a:	dc07      	bgt.n	800634c <minmea_parse_zda+0x7c>
      frame->minute_offset > 59 ||
 800633c:	9b07      	ldr	r3, [sp, #28]
 800633e:	6a1b      	ldr	r3, [r3, #32]
  if (abs(frame->hour_offset) > 13 ||
 8006340:	2b3b      	cmp	r3, #59	; 0x3b
 8006342:	dc03      	bgt.n	800634c <minmea_parse_zda+0x7c>
      frame->minute_offset < 0)
 8006344:	9b07      	ldr	r3, [sp, #28]
 8006346:	6a1b      	ldr	r3, [r3, #32]
      frame->minute_offset > 59 ||
 8006348:	2b00      	cmp	r3, #0
 800634a:	da01      	bge.n	8006350 <minmea_parse_zda+0x80>
      return false;
 800634c:	2300      	movs	r3, #0
 800634e:	e001      	b.n	8006354 <minmea_parse_zda+0x84>

  return true;
 8006350:	2301      	movs	r3, #1
 8006352:	bf00      	nop
}
 8006354:	4618      	mov	r0, r3
 8006356:	b00a      	add	sp, #40	; 0x28
 8006358:	bd70      	pop	{r4, r5, r6, pc}
 800635a:	bf00      	nop
 800635c:	0800711c 	.word	0x0800711c
 8006360:	080070bc 	.word	0x080070bc
	...

08006370 <chRegSetThreadName.lto_priv.1>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8006370:	b082      	sub	sp, #8
 8006372:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 8006374:	4b03      	ldr	r3, [pc, #12]	; (8006384 <chRegSetThreadName.lto_priv.1+0x14>)
 8006376:	68db      	ldr	r3, [r3, #12]
 8006378:	9a01      	ldr	r2, [sp, #4]
 800637a:	61da      	str	r2, [r3, #28]
#else
  (void)name;
#endif
}
 800637c:	bf00      	nop
 800637e:	b002      	add	sp, #8
 8006380:	4770      	bx	lr
 8006382:	bf00      	nop
 8006384:	20000d90 	.word	0x20000d90
	...

08006390 <minmea_rescale>:

/**
 * Rescale a fixed-point value to a different scale. Rounds towards zero.
 */
static inline int_least32_t minmea_rescale(struct minmea_float *f, int_least32_t new_scale)
{
 8006390:	b082      	sub	sp, #8
 8006392:	9001      	str	r0, [sp, #4]
 8006394:	9100      	str	r1, [sp, #0]
    if (f->scale == 0)
 8006396:	9b01      	ldr	r3, [sp, #4]
 8006398:	685b      	ldr	r3, [r3, #4]
 800639a:	2b00      	cmp	r3, #0
 800639c:	d101      	bne.n	80063a2 <minmea_rescale+0x12>
        return 0;
 800639e:	2300      	movs	r3, #0
 80063a0:	e037      	b.n	8006412 <minmea_rescale+0x82>
    if (f->scale == new_scale)
 80063a2:	9b01      	ldr	r3, [sp, #4]
 80063a4:	685b      	ldr	r3, [r3, #4]
 80063a6:	9a00      	ldr	r2, [sp, #0]
 80063a8:	429a      	cmp	r2, r3
 80063aa:	d102      	bne.n	80063b2 <minmea_rescale+0x22>
        return f->value;
 80063ac:	9b01      	ldr	r3, [sp, #4]
 80063ae:	681b      	ldr	r3, [r3, #0]
 80063b0:	e02f      	b.n	8006412 <minmea_rescale+0x82>
    if (f->scale > new_scale)
 80063b2:	9b01      	ldr	r3, [sp, #4]
 80063b4:	685b      	ldr	r3, [r3, #4]
 80063b6:	9a00      	ldr	r2, [sp, #0]
 80063b8:	429a      	cmp	r2, r3
 80063ba:	da21      	bge.n	8006400 <minmea_rescale+0x70>
        return (f->value + ((f->value > 0) - (f->value < 0)) * f->scale/new_scale/2) / (f->scale/new_scale);
 80063bc:	9b01      	ldr	r3, [sp, #4]
 80063be:	681a      	ldr	r2, [r3, #0]
 80063c0:	9b01      	ldr	r3, [sp, #4]
 80063c2:	681b      	ldr	r3, [r3, #0]
 80063c4:	2b00      	cmp	r3, #0
 80063c6:	bfcc      	ite	gt
 80063c8:	2301      	movgt	r3, #1
 80063ca:	2300      	movle	r3, #0
 80063cc:	b2db      	uxtb	r3, r3
 80063ce:	4619      	mov	r1, r3
 80063d0:	9b01      	ldr	r3, [sp, #4]
 80063d2:	681b      	ldr	r3, [r3, #0]
 80063d4:	0fdb      	lsrs	r3, r3, #31
 80063d6:	b2db      	uxtb	r3, r3
 80063d8:	1acb      	subs	r3, r1, r3
 80063da:	9901      	ldr	r1, [sp, #4]
 80063dc:	6849      	ldr	r1, [r1, #4]
 80063de:	fb03 f101 	mul.w	r1, r3, r1
 80063e2:	9b00      	ldr	r3, [sp, #0]
 80063e4:	fb91 f3f3 	sdiv	r3, r1, r3
 80063e8:	0fd9      	lsrs	r1, r3, #31
 80063ea:	440b      	add	r3, r1
 80063ec:	105b      	asrs	r3, r3, #1
 80063ee:	441a      	add	r2, r3
 80063f0:	9b01      	ldr	r3, [sp, #4]
 80063f2:	6859      	ldr	r1, [r3, #4]
 80063f4:	9b00      	ldr	r3, [sp, #0]
 80063f6:	fb91 f3f3 	sdiv	r3, r1, r3
 80063fa:	fb92 f3f3 	sdiv	r3, r2, r3
 80063fe:	e008      	b.n	8006412 <minmea_rescale+0x82>
    else
        return f->value * (new_scale/f->scale);
 8006400:	9b01      	ldr	r3, [sp, #4]
 8006402:	681b      	ldr	r3, [r3, #0]
 8006404:	9a01      	ldr	r2, [sp, #4]
 8006406:	6852      	ldr	r2, [r2, #4]
 8006408:	9900      	ldr	r1, [sp, #0]
 800640a:	fb91 f2f2 	sdiv	r2, r1, r2
 800640e:	fb02 f303 	mul.w	r3, r2, r3
}
 8006412:	4618      	mov	r0, r3
 8006414:	b002      	add	sp, #8
 8006416:	4770      	bx	lr
	...

08006420 <minmea_tofloat>:
/**
 * Convert a fixed-point value to a floating-point value.
 * Returns NaN for "unknown" values.
 */
static inline float minmea_tofloat(struct minmea_float *f)
{
 8006420:	b510      	push	{r4, lr}
 8006422:	b082      	sub	sp, #8
 8006424:	9001      	str	r0, [sp, #4]
    if (f->scale == 0)
 8006426:	9b01      	ldr	r3, [sp, #4]
 8006428:	685b      	ldr	r3, [r3, #4]
 800642a:	2b00      	cmp	r3, #0
 800642c:	d101      	bne.n	8006432 <minmea_tofloat+0x12>
        return NAN;
 800642e:	4b0b      	ldr	r3, [pc, #44]	; (800645c <minmea_tofloat+0x3c>)
 8006430:	e010      	b.n	8006454 <minmea_tofloat+0x34>
    return (float) f->value / (float) f->scale;
 8006432:	9b01      	ldr	r3, [sp, #4]
 8006434:	681b      	ldr	r3, [r3, #0]
 8006436:	4618      	mov	r0, r3
 8006438:	f7fa fc66 	bl	8000d08 <__aeabi_i2f>
 800643c:	4604      	mov	r4, r0
 800643e:	9b01      	ldr	r3, [sp, #4]
 8006440:	685b      	ldr	r3, [r3, #4]
 8006442:	4618      	mov	r0, r3
 8006444:	f7fa fc60 	bl	8000d08 <__aeabi_i2f>
 8006448:	4603      	mov	r3, r0
 800644a:	4619      	mov	r1, r3
 800644c:	4620      	mov	r0, r4
 800644e:	f7fa fd63 	bl	8000f18 <__aeabi_fdiv>
 8006452:	4603      	mov	r3, r0
}
 8006454:	4618      	mov	r0, r3
 8006456:	b002      	add	sp, #8
 8006458:	bd10      	pop	{r4, pc}
 800645a:	bf00      	nop
 800645c:	7fc00000 	.word	0x7fc00000

08006460 <minmea_tocoord>:
/**
 * Convert a raw coordinate to a floating point DD.DDD... value.
 * Returns NaN for "unknown" values.
 */
static inline float minmea_tocoord(struct minmea_float *f)
{
 8006460:	b530      	push	{r4, r5, lr}
 8006462:	b085      	sub	sp, #20
 8006464:	9001      	str	r0, [sp, #4]
    if (f->scale == 0)
 8006466:	9b01      	ldr	r3, [sp, #4]
 8006468:	685b      	ldr	r3, [r3, #4]
 800646a:	2b00      	cmp	r3, #0
 800646c:	d101      	bne.n	8006472 <minmea_tocoord+0x12>
        return NAN;
 800646e:	4b1c      	ldr	r3, [pc, #112]	; (80064e0 <minmea_tocoord+0x80>)
 8006470:	e032      	b.n	80064d8 <minmea_tocoord+0x78>
    int_least32_t degrees = f->value / (f->scale * 100);
 8006472:	9b01      	ldr	r3, [sp, #4]
 8006474:	681a      	ldr	r2, [r3, #0]
 8006476:	9b01      	ldr	r3, [sp, #4]
 8006478:	685b      	ldr	r3, [r3, #4]
 800647a:	2164      	movs	r1, #100	; 0x64
 800647c:	fb01 f303 	mul.w	r3, r1, r3
 8006480:	fb92 f3f3 	sdiv	r3, r2, r3
 8006484:	9303      	str	r3, [sp, #12]
    int_least32_t minutes = f->value % (f->scale * 100);
 8006486:	9b01      	ldr	r3, [sp, #4]
 8006488:	681b      	ldr	r3, [r3, #0]
 800648a:	9a01      	ldr	r2, [sp, #4]
 800648c:	6852      	ldr	r2, [r2, #4]
 800648e:	2164      	movs	r1, #100	; 0x64
 8006490:	fb01 f202 	mul.w	r2, r1, r2
 8006494:	fb93 f1f2 	sdiv	r1, r3, r2
 8006498:	fb01 f202 	mul.w	r2, r1, r2
 800649c:	1a9b      	subs	r3, r3, r2
 800649e:	9302      	str	r3, [sp, #8]
    return (float) degrees + (float) minutes / (60 * f->scale);
 80064a0:	9803      	ldr	r0, [sp, #12]
 80064a2:	f7fa fc31 	bl	8000d08 <__aeabi_i2f>
 80064a6:	4604      	mov	r4, r0
 80064a8:	9802      	ldr	r0, [sp, #8]
 80064aa:	f7fa fc2d 	bl	8000d08 <__aeabi_i2f>
 80064ae:	4605      	mov	r5, r0
 80064b0:	9b01      	ldr	r3, [sp, #4]
 80064b2:	685a      	ldr	r2, [r3, #4]
 80064b4:	4613      	mov	r3, r2
 80064b6:	011b      	lsls	r3, r3, #4
 80064b8:	1a9b      	subs	r3, r3, r2
 80064ba:	009b      	lsls	r3, r3, #2
 80064bc:	4618      	mov	r0, r3
 80064be:	f7fa fc23 	bl	8000d08 <__aeabi_i2f>
 80064c2:	4603      	mov	r3, r0
 80064c4:	4619      	mov	r1, r3
 80064c6:	4628      	mov	r0, r5
 80064c8:	f7fa fd26 	bl	8000f18 <__aeabi_fdiv>
 80064cc:	4603      	mov	r3, r0
 80064ce:	4619      	mov	r1, r3
 80064d0:	4620      	mov	r0, r4
 80064d2:	f7fa fb65 	bl	8000ba0 <__addsf3>
 80064d6:	4603      	mov	r3, r0
}
 80064d8:	4618      	mov	r0, r3
 80064da:	b005      	add	sp, #20
 80064dc:	bd30      	pop	{r4, r5, pc}
 80064de:	bf00      	nop
 80064e0:	7fc00000 	.word	0x7fc00000
	...

080064f0 <rxchar>:
#define INDENT_SPACES "  "

static char line[MINMEA_MAX_LENGTH];
static thread_reference_t trp;

void rxchar(UARTDriver *uartp, uint16_t c) {
 80064f0:	b500      	push	{lr}
 80064f2:	b085      	sub	sp, #20
 80064f4:	9001      	str	r0, [sp, #4]
 80064f6:	460b      	mov	r3, r1
 80064f8:	f8ad 3002 	strh.w	r3, [sp, #2]

  (void)uartp;
  char ch = (char)c;
 80064fc:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006500:	f88d 300f 	strb.w	r3, [sp, #15]
  static int k = 0;

  if (trp == NULL) {
 8006504:	4b1c      	ldr	r3, [pc, #112]	; (8006578 <rxchar+0x88>)
 8006506:	681b      	ldr	r3, [r3, #0]
 8006508:	2b00      	cmp	r3, #0
 800650a:	d103      	bne.n	8006514 <rxchar+0x24>
    k = 0;
 800650c:	4b1b      	ldr	r3, [pc, #108]	; (800657c <rxchar+0x8c>)
 800650e:	2200      	movs	r2, #0
 8006510:	601a      	str	r2, [r3, #0]
    return;
 8006512:	e02d      	b.n	8006570 <rxchar+0x80>
  }

  if (k == 0) {
 8006514:	4b19      	ldr	r3, [pc, #100]	; (800657c <rxchar+0x8c>)
 8006516:	681b      	ldr	r3, [r3, #0]
 8006518:	2b00      	cmp	r3, #0
 800651a:	d10d      	bne.n	8006538 <rxchar+0x48>
    if (ch == '$') {
 800651c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8006520:	2b24      	cmp	r3, #36	; 0x24
 8006522:	d125      	bne.n	8006570 <rxchar+0x80>
      line[k++] = ch;
 8006524:	4b15      	ldr	r3, [pc, #84]	; (800657c <rxchar+0x8c>)
 8006526:	681b      	ldr	r3, [r3, #0]
 8006528:	1c5a      	adds	r2, r3, #1
 800652a:	4914      	ldr	r1, [pc, #80]	; (800657c <rxchar+0x8c>)
 800652c:	600a      	str	r2, [r1, #0]
 800652e:	4914      	ldr	r1, [pc, #80]	; (8006580 <rxchar+0x90>)
 8006530:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8006534:	54ca      	strb	r2, [r1, r3]
 8006536:	e01b      	b.n	8006570 <rxchar+0x80>
    }
  } else {
    line[k++] = ch;
 8006538:	4b10      	ldr	r3, [pc, #64]	; (800657c <rxchar+0x8c>)
 800653a:	681b      	ldr	r3, [r3, #0]
 800653c:	1c5a      	adds	r2, r3, #1
 800653e:	490f      	ldr	r1, [pc, #60]	; (800657c <rxchar+0x8c>)
 8006540:	600a      	str	r2, [r1, #0]
 8006542:	490f      	ldr	r1, [pc, #60]	; (8006580 <rxchar+0x90>)
 8006544:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8006548:	54ca      	strb	r2, [r1, r3]

    if (ch == '\n') {
 800654a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800654e:	2b0a      	cmp	r3, #10
 8006550:	d10e      	bne.n	8006570 <rxchar+0x80>
      line[k++] = '\0';
 8006552:	4b0a      	ldr	r3, [pc, #40]	; (800657c <rxchar+0x8c>)
 8006554:	681b      	ldr	r3, [r3, #0]
 8006556:	1c5a      	adds	r2, r3, #1
 8006558:	4908      	ldr	r1, [pc, #32]	; (800657c <rxchar+0x8c>)
 800655a:	600a      	str	r2, [r1, #0]
 800655c:	4a08      	ldr	r2, [pc, #32]	; (8006580 <rxchar+0x90>)
 800655e:	2100      	movs	r1, #0
 8006560:	54d1      	strb	r1, [r2, r3]
      k = 0;
 8006562:	4b06      	ldr	r3, [pc, #24]	; (800657c <rxchar+0x8c>)
 8006564:	2200      	movs	r2, #0
 8006566:	601a      	str	r2, [r3, #0]

      chThdResumeI(&trp, 0);
 8006568:	2100      	movs	r1, #0
 800656a:	4803      	ldr	r0, [pc, #12]	; (8006578 <rxchar+0x88>)
 800656c:	f7fe f950 	bl	8004810 <chThdResumeI>
    }
  }

}
 8006570:	b005      	add	sp, #20
 8006572:	f85d fb04 	ldr.w	pc, [sp], #4
 8006576:	bf00      	nop
 8006578:	20000fd4 	.word	0x20000fd4
 800657c:	20000fd8 	.word	0x20000fd8
 8006580:	20000f84 	.word	0x20000f84
	...

08006590 <thdGps>:

UARTConfig uart1_cfg = {NULL, NULL, NULL, rxchar, NULL, NULL, 9600, 0, USART_CR2_STOP1_BITS, 0};

BaseSequentialStream *chp2 = (BaseSequentialStream*) &SD2;

THD_FUNCTION(thdGps, arg) {
 8006590:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006592:	b09f      	sub	sp, #124	; 0x7c
 8006594:	9007      	str	r0, [sp, #28]

  (void)arg;
  chRegSetThreadName("GPS Thread");
 8006596:	48ae      	ldr	r0, [pc, #696]	; (8006850 <thdGps+0x2c0>)
 8006598:	f7ff feea 	bl	8006370 <chRegSetThreadName.lto_priv.1>
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(7));
 800659c:	f240 3282 	movw	r2, #898	; 0x382
 80065a0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80065a4:	48ab      	ldr	r0, [pc, #684]	; (8006854 <thdGps+0x2c4>)
 80065a6:	f7fc f9cb 	bl	8002940 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 8, PAL_MODE_OUTPUT_PUSHPULL);
 80065aa:	2201      	movs	r2, #1
 80065ac:	f44f 7180 	mov.w	r1, #256	; 0x100
 80065b0:	48a8      	ldr	r0, [pc, #672]	; (8006854 <thdGps+0x2c4>)
 80065b2:	f7fc f9c5 	bl	8002940 <_pal_lld_setgroupmode>

  sdStart(&SD2, NULL);
 80065b6:	2100      	movs	r1, #0
 80065b8:	48a7      	ldr	r0, [pc, #668]	; (8006858 <thdGps+0x2c8>)
 80065ba:	f7fb fa99 	bl	8001af0 <sdStart>

  // RESET SEQUENCE
  palClearPad(GPIOA, 8);
 80065be:	4ba5      	ldr	r3, [pc, #660]	; (8006854 <thdGps+0x2c4>)
 80065c0:	f44f 7280 	mov.w	r2, #256	; 0x100
 80065c4:	835a      	strh	r2, [r3, #26]
  chThdSleepMilliseconds(100);
 80065c6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80065ca:	f7fe f8f9 	bl	80047c0 <chThdSleep>
  palSetPad(GPIOA, 8);
 80065ce:	4ba1      	ldr	r3, [pc, #644]	; (8006854 <thdGps+0x2c4>)
 80065d0:	f44f 7280 	mov.w	r2, #256	; 0x100
 80065d4:	831a      	strh	r2, [r3, #24]
  chThdSleepMilliseconds(1000);
 80065d6:	f242 7010 	movw	r0, #10000	; 0x2710
 80065da:	f7fe f8f1 	bl	80047c0 <chThdSleep>
  palClearPad(GPIOA, 8);
 80065de:	4b9d      	ldr	r3, [pc, #628]	; (8006854 <thdGps+0x2c4>)
 80065e0:	f44f 7280 	mov.w	r2, #256	; 0x100
 80065e4:	835a      	strh	r2, [r3, #26]
  chThdSleepMilliseconds(2000);
 80065e6:	f644 6020 	movw	r0, #20000	; 0x4e20
 80065ea:	f7fe f8e9 	bl	80047c0 <chThdSleep>
  palSetPad(GPIOA, 8);
 80065ee:	4b99      	ldr	r3, [pc, #612]	; (8006854 <thdGps+0x2c4>)
 80065f0:	f44f 7280 	mov.w	r2, #256	; 0x100
 80065f4:	831a      	strh	r2, [r3, #24]

  while (TRUE) {
    int i;

    trp = (thread_reference_t) NULL;
 80065f6:	4b99      	ldr	r3, [pc, #612]	; (800685c <thdGps+0x2cc>)
 80065f8:	2200      	movs	r2, #0
 80065fa:	601a      	str	r2, [r3, #0]
    uartStart(&UARTD1, &uart1_cfg);
 80065fc:	4998      	ldr	r1, [pc, #608]	; (8006860 <thdGps+0x2d0>)
 80065fe:	4899      	ldr	r0, [pc, #612]	; (8006864 <thdGps+0x2d4>)
 8006600:	f7fb fb06 	bl	8001c10 <uartStart>
    chThdSuspendS(&trp);
 8006604:	4895      	ldr	r0, [pc, #596]	; (800685c <thdGps+0x2cc>)
 8006606:	f7fe f8eb 	bl	80047e0 <chThdSuspendS>

    trp = (thread_reference_t) NULL;
 800660a:	4b94      	ldr	r3, [pc, #592]	; (800685c <thdGps+0x2cc>)
 800660c:	2200      	movs	r2, #0
 800660e:	601a      	str	r2, [r3, #0]
    uartStop(&UARTD1);
 8006610:	4894      	ldr	r0, [pc, #592]	; (8006864 <thdGps+0x2d4>)
 8006612:	f7fb fb15 	bl	8001c40 <uartStop>

    chprintf(chp2, "RECEIVED: \"%s\"\n\r", line);
 8006616:	4b94      	ldr	r3, [pc, #592]	; (8006868 <thdGps+0x2d8>)
 8006618:	681b      	ldr	r3, [r3, #0]
 800661a:	4a94      	ldr	r2, [pc, #592]	; (800686c <thdGps+0x2dc>)
 800661c:	4994      	ldr	r1, [pc, #592]	; (8006870 <thdGps+0x2e0>)
 800661e:	4618      	mov	r0, r3
 8006620:	f7fe feee 	bl	8005400 <chprintf>

    switch (minmea_sentence_id(line, true)) {
 8006624:	2101      	movs	r1, #1
 8006626:	4891      	ldr	r0, [pc, #580]	; (800686c <thdGps+0x2dc>)
 8006628:	f7ff fb72 	bl	8005d10 <minmea_sentence_id>
 800662c:	4603      	mov	r3, r0
 800662e:	3301      	adds	r3, #1
 8006630:	2b09      	cmp	r3, #9
 8006632:	f200 821b 	bhi.w	8006a6c <thdGps+0x4dc>
 8006636:	a201      	add	r2, pc, #4	; (adr r2, 800663c <thdGps+0xac>)
 8006638:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800663c:	08006a5f 	.word	0x08006a5f
 8006640:	08006a6d 	.word	0x08006a6d
 8006644:	08006665 	.word	0x08006665
 8006648:	08006747 	.word	0x08006747
 800664c:	08006a6d 	.word	0x08006a6d
 8006650:	08006a25 	.word	0x08006a25
 8006654:	08006775 	.word	0x08006775
 8006658:	0800689d 	.word	0x0800689d
 800665c:	08006931 	.word	0x08006931
 8006660:	080069d7 	.word	0x080069d7
      case MINMEA_SENTENCE_RMC: {
        struct minmea_sentence_rmc frame;
        if (minmea_parse_rmc(&frame, line)) {
 8006664:	ab09      	add	r3, sp, #36	; 0x24
 8006666:	4981      	ldr	r1, [pc, #516]	; (800686c <thdGps+0x2dc>)
 8006668:	4618      	mov	r0, r3
 800666a:	f7ff fbe9 	bl	8005e40 <minmea_parse_rmc>
 800666e:	4603      	mov	r3, r0
 8006670:	2b00      	cmp	r3, #0
 8006672:	d061      	beq.n	8006738 <thdGps+0x1a8>
          chprintf(
 8006674:	4b7c      	ldr	r3, [pc, #496]	; (8006868 <thdGps+0x2d8>)
 8006676:	681c      	ldr	r4, [r3, #0]
 8006678:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 800667a:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 800667c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800667e:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8006680:	9912      	ldr	r1, [sp, #72]	; 0x48
 8006682:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8006684:	9003      	str	r0, [sp, #12]
 8006686:	9102      	str	r1, [sp, #8]
 8006688:	9201      	str	r2, [sp, #4]
 800668a:	9300      	str	r3, [sp, #0]
 800668c:	4633      	mov	r3, r6
 800668e:	462a      	mov	r2, r5
 8006690:	4978      	ldr	r1, [pc, #480]	; (8006874 <thdGps+0x2e4>)
 8006692:	4620      	mov	r0, r4
 8006694:	f7fe feb4 	bl	8005400 <chprintf>
              chp2,
              INDENT_SPACES "$xxRMC: raw coordinates and speed: (%ld/%ld,%ld/%ld) %ld/%ld\n",
              frame.latitude.value, frame.latitude.scale, frame.longitude.value,
              frame.longitude.scale, frame.speed.value, frame.speed.scale);
          chprintf(
 8006698:	4b73      	ldr	r3, [pc, #460]	; (8006868 <thdGps+0x2d8>)
 800669a:	681c      	ldr	r4, [r3, #0]
 800669c:	ab09      	add	r3, sp, #36	; 0x24
 800669e:	3314      	adds	r3, #20
 80066a0:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80066a4:	4618      	mov	r0, r3
 80066a6:	f7ff fe73 	bl	8006390 <minmea_rescale>
 80066aa:	4605      	mov	r5, r0
 80066ac:	ab09      	add	r3, sp, #36	; 0x24
 80066ae:	331c      	adds	r3, #28
 80066b0:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80066b4:	4618      	mov	r0, r3
 80066b6:	f7ff fe6b 	bl	8006390 <minmea_rescale>
 80066ba:	4606      	mov	r6, r0
 80066bc:	ab09      	add	r3, sp, #36	; 0x24
 80066be:	3324      	adds	r3, #36	; 0x24
 80066c0:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80066c4:	4618      	mov	r0, r3
 80066c6:	f7ff fe63 	bl	8006390 <minmea_rescale>
 80066ca:	4603      	mov	r3, r0
 80066cc:	9300      	str	r3, [sp, #0]
 80066ce:	4633      	mov	r3, r6
 80066d0:	462a      	mov	r2, r5
 80066d2:	4969      	ldr	r1, [pc, #420]	; (8006878 <thdGps+0x2e8>)
 80066d4:	4620      	mov	r0, r4
 80066d6:	f7fe fe93 	bl	8005400 <chprintf>
              chp2,
              INDENT_SPACES "$xxRMC fixed-point coordinates and speed scaled to three decimal places: (%ld,%ld) %ld\n",
              minmea_rescale(&frame.latitude, 1000),
              minmea_rescale(&frame.longitude, 1000),
              minmea_rescale(&frame.speed, 1000));
          chprintf(
 80066da:	4b63      	ldr	r3, [pc, #396]	; (8006868 <thdGps+0x2d8>)
 80066dc:	681b      	ldr	r3, [r3, #0]
 80066de:	9306      	str	r3, [sp, #24]
              chp2,
              INDENT_SPACES "$xxRMC floating point degree coordinates and speed: (%f,%f) %f\n",
              minmea_tocoord(&frame.latitude), minmea_tocoord(&frame.longitude),
 80066e0:	ab09      	add	r3, sp, #36	; 0x24
 80066e2:	3314      	adds	r3, #20
 80066e4:	4618      	mov	r0, r3
 80066e6:	f7ff febb 	bl	8006460 <minmea_tocoord>
 80066ea:	4603      	mov	r3, r0
          chprintf(
 80066ec:	4618      	mov	r0, r3
 80066ee:	f7fa f9f9 	bl	8000ae4 <__aeabi_f2d>
 80066f2:	4606      	mov	r6, r0
 80066f4:	460f      	mov	r7, r1
              minmea_tocoord(&frame.latitude), minmea_tocoord(&frame.longitude),
 80066f6:	ab09      	add	r3, sp, #36	; 0x24
 80066f8:	331c      	adds	r3, #28
 80066fa:	4618      	mov	r0, r3
 80066fc:	f7ff feb0 	bl	8006460 <minmea_tocoord>
 8006700:	4603      	mov	r3, r0
          chprintf(
 8006702:	4618      	mov	r0, r3
 8006704:	f7fa f9ee 	bl	8000ae4 <__aeabi_f2d>
 8006708:	4604      	mov	r4, r0
 800670a:	460d      	mov	r5, r1
              minmea_tofloat(&frame.speed));
 800670c:	ab09      	add	r3, sp, #36	; 0x24
 800670e:	3324      	adds	r3, #36	; 0x24
 8006710:	4618      	mov	r0, r3
 8006712:	f7ff fe85 	bl	8006420 <minmea_tofloat>
 8006716:	4603      	mov	r3, r0
          chprintf(
 8006718:	4618      	mov	r0, r3
 800671a:	f7fa f9e3 	bl	8000ae4 <__aeabi_f2d>
 800671e:	4602      	mov	r2, r0
 8006720:	460b      	mov	r3, r1
 8006722:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8006726:	e9cd 4500 	strd	r4, r5, [sp]
 800672a:	4632      	mov	r2, r6
 800672c:	463b      	mov	r3, r7
 800672e:	4953      	ldr	r1, [pc, #332]	; (800687c <thdGps+0x2ec>)
 8006730:	9806      	ldr	r0, [sp, #24]
 8006732:	f7fe fe65 	bl	8005400 <chprintf>
        }
        else {
          chprintf(chp2, INDENT_SPACES "$xxRMC sentence is not parsed\n");
        }
      }
        break;
 8006736:	e199      	b.n	8006a6c <thdGps+0x4dc>
          chprintf(chp2, INDENT_SPACES "$xxRMC sentence is not parsed\n");
 8006738:	4b4b      	ldr	r3, [pc, #300]	; (8006868 <thdGps+0x2d8>)
 800673a:	681b      	ldr	r3, [r3, #0]
 800673c:	4950      	ldr	r1, [pc, #320]	; (8006880 <thdGps+0x2f0>)
 800673e:	4618      	mov	r0, r3
 8006740:	f7fe fe5e 	bl	8005400 <chprintf>
        break;
 8006744:	e192      	b.n	8006a6c <thdGps+0x4dc>

      case MINMEA_SENTENCE_GGA: {
        struct minmea_sentence_gga frame;
        if (minmea_parse_gga(&frame, line)) {
 8006746:	ab09      	add	r3, sp, #36	; 0x24
 8006748:	4948      	ldr	r1, [pc, #288]	; (800686c <thdGps+0x2dc>)
 800674a:	4618      	mov	r0, r3
 800674c:	f7ff fbe0 	bl	8005f10 <minmea_parse_gga>
 8006750:	4603      	mov	r3, r0
 8006752:	2b00      	cmp	r3, #0
 8006754:	d007      	beq.n	8006766 <thdGps+0x1d6>
          chprintf(chp2, INDENT_SPACES "$xxGGA: fix quality: %d\n",
 8006756:	4b44      	ldr	r3, [pc, #272]	; (8006868 <thdGps+0x2d8>)
 8006758:	681b      	ldr	r3, [r3, #0]
 800675a:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800675c:	4949      	ldr	r1, [pc, #292]	; (8006884 <thdGps+0x2f4>)
 800675e:	4618      	mov	r0, r3
 8006760:	f7fe fe4e 	bl	8005400 <chprintf>
        }
        else {
          chprintf(chp2, INDENT_SPACES "$xxGGA sentence is not parsed\n");
        }
      }
        break;
 8006764:	e182      	b.n	8006a6c <thdGps+0x4dc>
          chprintf(chp2, INDENT_SPACES "$xxGGA sentence is not parsed\n");
 8006766:	4b40      	ldr	r3, [pc, #256]	; (8006868 <thdGps+0x2d8>)
 8006768:	681b      	ldr	r3, [r3, #0]
 800676a:	4947      	ldr	r1, [pc, #284]	; (8006888 <thdGps+0x2f8>)
 800676c:	4618      	mov	r0, r3
 800676e:	f7fe fe47 	bl	8005400 <chprintf>
        break;
 8006772:	e17b      	b.n	8006a6c <thdGps+0x4dc>

      case MINMEA_SENTENCE_GST: {
        struct minmea_sentence_gst frame;
        if (minmea_parse_gst(&frame, line)) {
 8006774:	ab09      	add	r3, sp, #36	; 0x24
 8006776:	493d      	ldr	r1, [pc, #244]	; (800686c <thdGps+0x2dc>)
 8006778:	4618      	mov	r0, r3
 800677a:	f7ff fc81 	bl	8006080 <minmea_parse_gst>
 800677e:	4603      	mov	r3, r0
 8006780:	2b00      	cmp	r3, #0
 8006782:	d05e      	beq.n	8006842 <thdGps+0x2b2>
          chprintf(
 8006784:	4b38      	ldr	r3, [pc, #224]	; (8006868 <thdGps+0x2d8>)
 8006786:	681c      	ldr	r4, [r3, #0]
 8006788:	9d15      	ldr	r5, [sp, #84]	; 0x54
 800678a:	9e16      	ldr	r6, [sp, #88]	; 0x58
 800678c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800678e:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8006790:	9919      	ldr	r1, [sp, #100]	; 0x64
 8006792:	981a      	ldr	r0, [sp, #104]	; 0x68
 8006794:	9003      	str	r0, [sp, #12]
 8006796:	9102      	str	r1, [sp, #8]
 8006798:	9201      	str	r2, [sp, #4]
 800679a:	9300      	str	r3, [sp, #0]
 800679c:	4633      	mov	r3, r6
 800679e:	462a      	mov	r2, r5
 80067a0:	493a      	ldr	r1, [pc, #232]	; (800688c <thdGps+0x2fc>)
 80067a2:	4620      	mov	r0, r4
 80067a4:	f7fe fe2c 	bl	8005400 <chprintf>
              frame.latitude_error_deviation.scale,
              frame.longitude_error_deviation.value,
              frame.longitude_error_deviation.scale,
              frame.altitude_error_deviation.value,
              frame.altitude_error_deviation.scale);
          chprintf(
 80067a8:	4b2f      	ldr	r3, [pc, #188]	; (8006868 <thdGps+0x2d8>)
 80067aa:	681c      	ldr	r4, [r3, #0]
 80067ac:	ab09      	add	r3, sp, #36	; 0x24
 80067ae:	3330      	adds	r3, #48	; 0x30
 80067b0:	210a      	movs	r1, #10
 80067b2:	4618      	mov	r0, r3
 80067b4:	f7ff fdec 	bl	8006390 <minmea_rescale>
 80067b8:	4605      	mov	r5, r0
 80067ba:	ab09      	add	r3, sp, #36	; 0x24
 80067bc:	3338      	adds	r3, #56	; 0x38
 80067be:	210a      	movs	r1, #10
 80067c0:	4618      	mov	r0, r3
 80067c2:	f7ff fde5 	bl	8006390 <minmea_rescale>
 80067c6:	4606      	mov	r6, r0
 80067c8:	ab09      	add	r3, sp, #36	; 0x24
 80067ca:	3340      	adds	r3, #64	; 0x40
 80067cc:	210a      	movs	r1, #10
 80067ce:	4618      	mov	r0, r3
 80067d0:	f7ff fdde 	bl	8006390 <minmea_rescale>
 80067d4:	4603      	mov	r3, r0
 80067d6:	9300      	str	r3, [sp, #0]
 80067d8:	4633      	mov	r3, r6
 80067da:	462a      	mov	r2, r5
 80067dc:	492c      	ldr	r1, [pc, #176]	; (8006890 <thdGps+0x300>)
 80067de:	4620      	mov	r0, r4
 80067e0:	f7fe fe0e 	bl	8005400 <chprintf>
              INDENT_SPACES "$xxGST fixed point latitude,longitude and altitude error deviation"
              " scaled to one decimal place: (%ld,%ld,%ld)\n",
              minmea_rescale(&frame.latitude_error_deviation, 10),
              minmea_rescale(&frame.longitude_error_deviation, 10),
              minmea_rescale(&frame.altitude_error_deviation, 10));
          chprintf(
 80067e4:	4b20      	ldr	r3, [pc, #128]	; (8006868 <thdGps+0x2d8>)
 80067e6:	681b      	ldr	r3, [r3, #0]
 80067e8:	9306      	str	r3, [sp, #24]
              chp2,
              INDENT_SPACES "$xxGST floating point degree latitude, longitude and altitude error deviation: (%f,%f,%f)",
              minmea_tofloat(&frame.latitude_error_deviation),
 80067ea:	ab09      	add	r3, sp, #36	; 0x24
 80067ec:	3330      	adds	r3, #48	; 0x30
 80067ee:	4618      	mov	r0, r3
 80067f0:	f7ff fe16 	bl	8006420 <minmea_tofloat>
 80067f4:	4603      	mov	r3, r0
          chprintf(
 80067f6:	4618      	mov	r0, r3
 80067f8:	f7fa f974 	bl	8000ae4 <__aeabi_f2d>
 80067fc:	4606      	mov	r6, r0
 80067fe:	460f      	mov	r7, r1
              minmea_tofloat(&frame.longitude_error_deviation),
 8006800:	ab09      	add	r3, sp, #36	; 0x24
 8006802:	3338      	adds	r3, #56	; 0x38
 8006804:	4618      	mov	r0, r3
 8006806:	f7ff fe0b 	bl	8006420 <minmea_tofloat>
 800680a:	4603      	mov	r3, r0
          chprintf(
 800680c:	4618      	mov	r0, r3
 800680e:	f7fa f969 	bl	8000ae4 <__aeabi_f2d>
 8006812:	4604      	mov	r4, r0
 8006814:	460d      	mov	r5, r1
              minmea_tofloat(&frame.altitude_error_deviation));
 8006816:	ab09      	add	r3, sp, #36	; 0x24
 8006818:	3340      	adds	r3, #64	; 0x40
 800681a:	4618      	mov	r0, r3
 800681c:	f7ff fe00 	bl	8006420 <minmea_tofloat>
 8006820:	4603      	mov	r3, r0
          chprintf(
 8006822:	4618      	mov	r0, r3
 8006824:	f7fa f95e 	bl	8000ae4 <__aeabi_f2d>
 8006828:	4602      	mov	r2, r0
 800682a:	460b      	mov	r3, r1
 800682c:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8006830:	e9cd 4500 	strd	r4, r5, [sp]
 8006834:	4632      	mov	r2, r6
 8006836:	463b      	mov	r3, r7
 8006838:	4916      	ldr	r1, [pc, #88]	; (8006894 <thdGps+0x304>)
 800683a:	9806      	ldr	r0, [sp, #24]
 800683c:	f7fe fde0 	bl	8005400 <chprintf>
        }
        else {
          chprintf(chp2, INDENT_SPACES "$xxGST sentence is not parsed\n");
        }
      }
        break;
 8006840:	e114      	b.n	8006a6c <thdGps+0x4dc>
          chprintf(chp2, INDENT_SPACES "$xxGST sentence is not parsed\n");
 8006842:	4b09      	ldr	r3, [pc, #36]	; (8006868 <thdGps+0x2d8>)
 8006844:	681b      	ldr	r3, [r3, #0]
 8006846:	4914      	ldr	r1, [pc, #80]	; (8006898 <thdGps+0x308>)
 8006848:	4618      	mov	r0, r3
 800684a:	f7fe fdd9 	bl	8005400 <chprintf>
        break;
 800684e:	e10d      	b.n	8006a6c <thdGps+0x4dc>
 8006850:	08007124 	.word	0x08007124
 8006854:	40020000 	.word	0x40020000
 8006858:	20000cdc 	.word	0x20000cdc
 800685c:	20000fd4 	.word	0x20000fd4
 8006860:	20000800 	.word	0x20000800
 8006864:	20000d5c 	.word	0x20000d5c
 8006868:	20000824 	.word	0x20000824
 800686c:	20000f84 	.word	0x20000f84
 8006870:	08007130 	.word	0x08007130
 8006874:	08007144 	.word	0x08007144
 8006878:	08007184 	.word	0x08007184
 800687c:	080071e0 	.word	0x080071e0
 8006880:	08007224 	.word	0x08007224
 8006884:	08007248 	.word	0x08007248
 8006888:	08007264 	.word	0x08007264
 800688c:	08007288 	.word	0x08007288
 8006890:	080072e4 	.word	0x080072e4
 8006894:	08007358 	.word	0x08007358
 8006898:	080073b4 	.word	0x080073b4

      case MINMEA_SENTENCE_GSV: {
        struct minmea_sentence_gsv frame;
        if (minmea_parse_gsv(&frame, line)) {
 800689c:	ab09      	add	r3, sp, #36	; 0x24
 800689e:	4975      	ldr	r1, [pc, #468]	; (8006a74 <thdGps+0x4e4>)
 80068a0:	4618      	mov	r0, r3
 80068a2:	f7ff fc2d 	bl	8006100 <minmea_parse_gsv>
 80068a6:	4603      	mov	r3, r0
 80068a8:	2b00      	cmp	r3, #0
 80068aa:	d03a      	beq.n	8006922 <thdGps+0x392>
          chprintf(chp2, INDENT_SPACES "$xxGSV: message %d of %d\n", frame.msg_nr,
 80068ac:	4b72      	ldr	r3, [pc, #456]	; (8006a78 <thdGps+0x4e8>)
 80068ae:	6818      	ldr	r0, [r3, #0]
 80068b0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80068b2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80068b4:	4971      	ldr	r1, [pc, #452]	; (8006a7c <thdGps+0x4ec>)
 80068b6:	f7fe fda3 	bl	8005400 <chprintf>
                   frame.total_msgs);
          chprintf(chp2, INDENT_SPACES "$xxGSV: sattelites in view: %d\n",
 80068ba:	4b6f      	ldr	r3, [pc, #444]	; (8006a78 <thdGps+0x4e8>)
 80068bc:	681b      	ldr	r3, [r3, #0]
 80068be:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80068c0:	496f      	ldr	r1, [pc, #444]	; (8006a80 <thdGps+0x4f0>)
 80068c2:	4618      	mov	r0, r3
 80068c4:	f7fe fd9c 	bl	8005400 <chprintf>
                   frame.total_sats);
          for (i = 0; i < 4; i++)
 80068c8:	2300      	movs	r3, #0
 80068ca:	931d      	str	r3, [sp, #116]	; 0x74
 80068cc:	e025      	b.n	800691a <thdGps+0x38a>
            chprintf(
 80068ce:	4b6a      	ldr	r3, [pc, #424]	; (8006a78 <thdGps+0x4e8>)
 80068d0:	6818      	ldr	r0, [r3, #0]
 80068d2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80068d4:	011b      	lsls	r3, r3, #4
 80068d6:	3378      	adds	r3, #120	; 0x78
 80068d8:	446b      	add	r3, sp
 80068da:	3b48      	subs	r3, #72	; 0x48
 80068dc:	6819      	ldr	r1, [r3, #0]
 80068de:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80068e0:	011b      	lsls	r3, r3, #4
 80068e2:	3378      	adds	r3, #120	; 0x78
 80068e4:	446b      	add	r3, sp
 80068e6:	3b44      	subs	r3, #68	; 0x44
 80068e8:	681c      	ldr	r4, [r3, #0]
 80068ea:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80068ec:	3301      	adds	r3, #1
 80068ee:	011b      	lsls	r3, r3, #4
 80068f0:	3378      	adds	r3, #120	; 0x78
 80068f2:	446b      	add	r3, sp
 80068f4:	3b50      	subs	r3, #80	; 0x50
 80068f6:	681b      	ldr	r3, [r3, #0]
 80068f8:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 80068fa:	3201      	adds	r2, #1
 80068fc:	0112      	lsls	r2, r2, #4
 80068fe:	3278      	adds	r2, #120	; 0x78
 8006900:	446a      	add	r2, sp
 8006902:	3a4c      	subs	r2, #76	; 0x4c
 8006904:	6812      	ldr	r2, [r2, #0]
 8006906:	9201      	str	r2, [sp, #4]
 8006908:	9300      	str	r3, [sp, #0]
 800690a:	4623      	mov	r3, r4
 800690c:	460a      	mov	r2, r1
 800690e:	495d      	ldr	r1, [pc, #372]	; (8006a84 <thdGps+0x4f4>)
 8006910:	f7fe fd76 	bl	8005400 <chprintf>
          for (i = 0; i < 4; i++)
 8006914:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8006916:	3301      	adds	r3, #1
 8006918:	931d      	str	r3, [sp, #116]	; 0x74
 800691a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 800691c:	2b03      	cmp	r3, #3
 800691e:	ddd6      	ble.n	80068ce <thdGps+0x33e>
        }
        else {
          chprintf(chp2, INDENT_SPACES "$xxGSV sentence is not parsed\n");
        }
      }
        break;
 8006920:	e0a4      	b.n	8006a6c <thdGps+0x4dc>
          chprintf(chp2, INDENT_SPACES "$xxGSV sentence is not parsed\n");
 8006922:	4b55      	ldr	r3, [pc, #340]	; (8006a78 <thdGps+0x4e8>)
 8006924:	681b      	ldr	r3, [r3, #0]
 8006926:	4958      	ldr	r1, [pc, #352]	; (8006a88 <thdGps+0x4f8>)
 8006928:	4618      	mov	r0, r3
 800692a:	f7fe fd69 	bl	8005400 <chprintf>
        break;
 800692e:	e09d      	b.n	8006a6c <thdGps+0x4dc>

      case MINMEA_SENTENCE_VTG: {
        struct minmea_sentence_vtg frame;
        if (minmea_parse_vtg(&frame, line)) {
 8006930:	ab09      	add	r3, sp, #36	; 0x24
 8006932:	4950      	ldr	r1, [pc, #320]	; (8006a74 <thdGps+0x4e4>)
 8006934:	4618      	mov	r0, r3
 8006936:	f7ff fc73 	bl	8006220 <minmea_parse_vtg>
 800693a:	4603      	mov	r3, r0
 800693c:	2b00      	cmp	r3, #0
 800693e:	d043      	beq.n	80069c8 <thdGps+0x438>
          chprintf(chp2, INDENT_SPACES "$xxVTG: true track degrees = %f\n",
 8006940:	4b4d      	ldr	r3, [pc, #308]	; (8006a78 <thdGps+0x4e8>)
 8006942:	681c      	ldr	r4, [r3, #0]
                   minmea_tofloat(&frame.true_track_degrees));
 8006944:	ab09      	add	r3, sp, #36	; 0x24
 8006946:	4618      	mov	r0, r3
 8006948:	f7ff fd6a 	bl	8006420 <minmea_tofloat>
 800694c:	4603      	mov	r3, r0
          chprintf(chp2, INDENT_SPACES "$xxVTG: true track degrees = %f\n",
 800694e:	4618      	mov	r0, r3
 8006950:	f7fa f8c8 	bl	8000ae4 <__aeabi_f2d>
 8006954:	4602      	mov	r2, r0
 8006956:	460b      	mov	r3, r1
 8006958:	494c      	ldr	r1, [pc, #304]	; (8006a8c <thdGps+0x4fc>)
 800695a:	4620      	mov	r0, r4
 800695c:	f7fe fd50 	bl	8005400 <chprintf>
          chprintf(chp2, INDENT_SPACES "        magnetic track degrees = %f\n",
 8006960:	4b45      	ldr	r3, [pc, #276]	; (8006a78 <thdGps+0x4e8>)
 8006962:	681c      	ldr	r4, [r3, #0]
                   minmea_tofloat(&frame.magnetic_track_degrees));
 8006964:	ab09      	add	r3, sp, #36	; 0x24
 8006966:	3308      	adds	r3, #8
 8006968:	4618      	mov	r0, r3
 800696a:	f7ff fd59 	bl	8006420 <minmea_tofloat>
 800696e:	4603      	mov	r3, r0
          chprintf(chp2, INDENT_SPACES "        magnetic track degrees = %f\n",
 8006970:	4618      	mov	r0, r3
 8006972:	f7fa f8b7 	bl	8000ae4 <__aeabi_f2d>
 8006976:	4602      	mov	r2, r0
 8006978:	460b      	mov	r3, r1
 800697a:	4945      	ldr	r1, [pc, #276]	; (8006a90 <thdGps+0x500>)
 800697c:	4620      	mov	r0, r4
 800697e:	f7fe fd3f 	bl	8005400 <chprintf>
          chprintf(chp2, INDENT_SPACES "        speed knots = %f\n",
 8006982:	4b3d      	ldr	r3, [pc, #244]	; (8006a78 <thdGps+0x4e8>)
 8006984:	681c      	ldr	r4, [r3, #0]
                   minmea_tofloat(&frame.speed_knots));
 8006986:	ab09      	add	r3, sp, #36	; 0x24
 8006988:	3310      	adds	r3, #16
 800698a:	4618      	mov	r0, r3
 800698c:	f7ff fd48 	bl	8006420 <minmea_tofloat>
 8006990:	4603      	mov	r3, r0
          chprintf(chp2, INDENT_SPACES "        speed knots = %f\n",
 8006992:	4618      	mov	r0, r3
 8006994:	f7fa f8a6 	bl	8000ae4 <__aeabi_f2d>
 8006998:	4602      	mov	r2, r0
 800699a:	460b      	mov	r3, r1
 800699c:	493d      	ldr	r1, [pc, #244]	; (8006a94 <thdGps+0x504>)
 800699e:	4620      	mov	r0, r4
 80069a0:	f7fe fd2e 	bl	8005400 <chprintf>
          chprintf(chp2, INDENT_SPACES "        speed kph = %f\n",
 80069a4:	4b34      	ldr	r3, [pc, #208]	; (8006a78 <thdGps+0x4e8>)
 80069a6:	681c      	ldr	r4, [r3, #0]
                   minmea_tofloat(&frame.speed_kph));
 80069a8:	ab09      	add	r3, sp, #36	; 0x24
 80069aa:	3318      	adds	r3, #24
 80069ac:	4618      	mov	r0, r3
 80069ae:	f7ff fd37 	bl	8006420 <minmea_tofloat>
 80069b2:	4603      	mov	r3, r0
          chprintf(chp2, INDENT_SPACES "        speed kph = %f\n",
 80069b4:	4618      	mov	r0, r3
 80069b6:	f7fa f895 	bl	8000ae4 <__aeabi_f2d>
 80069ba:	4602      	mov	r2, r0
 80069bc:	460b      	mov	r3, r1
 80069be:	4936      	ldr	r1, [pc, #216]	; (8006a98 <thdGps+0x508>)
 80069c0:	4620      	mov	r0, r4
 80069c2:	f7fe fd1d 	bl	8005400 <chprintf>
        }
        else {
          chprintf(chp2, INDENT_SPACES "$xxVTG sentence is not parsed\n");
        }
      }
        break;
 80069c6:	e051      	b.n	8006a6c <thdGps+0x4dc>
          chprintf(chp2, INDENT_SPACES "$xxVTG sentence is not parsed\n");
 80069c8:	4b2b      	ldr	r3, [pc, #172]	; (8006a78 <thdGps+0x4e8>)
 80069ca:	681b      	ldr	r3, [r3, #0]
 80069cc:	4933      	ldr	r1, [pc, #204]	; (8006a9c <thdGps+0x50c>)
 80069ce:	4618      	mov	r0, r3
 80069d0:	f7fe fd16 	bl	8005400 <chprintf>
        break;
 80069d4:	e04a      	b.n	8006a6c <thdGps+0x4dc>

      case MINMEA_SENTENCE_ZDA: {
        struct minmea_sentence_zda frame;
        if (minmea_parse_zda(&frame, line)) {
 80069d6:	ab09      	add	r3, sp, #36	; 0x24
 80069d8:	4926      	ldr	r1, [pc, #152]	; (8006a74 <thdGps+0x4e4>)
 80069da:	4618      	mov	r0, r3
 80069dc:	f7ff fc78 	bl	80062d0 <minmea_parse_zda>
 80069e0:	4603      	mov	r3, r0
 80069e2:	2b00      	cmp	r3, #0
 80069e4:	d017      	beq.n	8006a16 <thdGps+0x486>
          chprintf(chp2,
 80069e6:	4b24      	ldr	r3, [pc, #144]	; (8006a78 <thdGps+0x4e8>)
 80069e8:	681e      	ldr	r6, [r3, #0]
 80069ea:	9f09      	ldr	r7, [sp, #36]	; 0x24
 80069ec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80069ee:	9306      	str	r3, [sp, #24]
 80069f0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80069f2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80069f4:	990e      	ldr	r1, [sp, #56]	; 0x38
 80069f6:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80069f8:	9c10      	ldr	r4, [sp, #64]	; 0x40
 80069fa:	9d11      	ldr	r5, [sp, #68]	; 0x44
 80069fc:	9505      	str	r5, [sp, #20]
 80069fe:	9404      	str	r4, [sp, #16]
 8006a00:	9003      	str	r0, [sp, #12]
 8006a02:	9102      	str	r1, [sp, #8]
 8006a04:	9201      	str	r2, [sp, #4]
 8006a06:	9300      	str	r3, [sp, #0]
 8006a08:	9b06      	ldr	r3, [sp, #24]
 8006a0a:	463a      	mov	r2, r7
 8006a0c:	4924      	ldr	r1, [pc, #144]	; (8006aa0 <thdGps+0x510>)
 8006a0e:	4630      	mov	r0, r6
 8006a10:	f7fe fcf6 	bl	8005400 <chprintf>
        }
        else {
          chprintf(chp2, INDENT_SPACES "$xxZDA sentence is not parsed\n");
        }
      }
        break;
 8006a14:	e02a      	b.n	8006a6c <thdGps+0x4dc>
          chprintf(chp2, INDENT_SPACES "$xxZDA sentence is not parsed\n");
 8006a16:	4b18      	ldr	r3, [pc, #96]	; (8006a78 <thdGps+0x4e8>)
 8006a18:	681b      	ldr	r3, [r3, #0]
 8006a1a:	4922      	ldr	r1, [pc, #136]	; (8006aa4 <thdGps+0x514>)
 8006a1c:	4618      	mov	r0, r3
 8006a1e:	f7fe fcef 	bl	8005400 <chprintf>
        break;
 8006a22:	e023      	b.n	8006a6c <thdGps+0x4dc>
      case MINMEA_SENTENCE_GLL: {
        struct minmea_sentence_gll frame;
        if (minmea_parse_gll(&frame, line)) {
 8006a24:	ab09      	add	r3, sp, #36	; 0x24
 8006a26:	4913      	ldr	r1, [pc, #76]	; (8006a74 <thdGps+0x4e4>)
 8006a28:	4618      	mov	r0, r3
 8006a2a:	f7ff fae1 	bl	8005ff0 <minmea_parse_gll>
 8006a2e:	4603      	mov	r3, r0
 8006a30:	2b00      	cmp	r3, #0
 8006a32:	d00d      	beq.n	8006a50 <thdGps+0x4c0>
          chprintf(
 8006a34:	4b10      	ldr	r3, [pc, #64]	; (8006a78 <thdGps+0x4e8>)
 8006a36:	6818      	ldr	r0, [r3, #0]
 8006a38:	9909      	ldr	r1, [sp, #36]	; 0x24
 8006a3a:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8006a3c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8006a3e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8006a40:	9201      	str	r2, [sp, #4]
 8006a42:	9300      	str	r3, [sp, #0]
 8006a44:	4623      	mov	r3, r4
 8006a46:	460a      	mov	r2, r1
 8006a48:	4917      	ldr	r1, [pc, #92]	; (8006aa8 <thdGps+0x518>)
 8006a4a:	f7fe fcd9 	bl	8005400 <chprintf>

        else {
          chprintf(chp2, INDENT_SPACES "$xxGLL sentence is not parsed\n");
        }
      }
        break;
 8006a4e:	e00d      	b.n	8006a6c <thdGps+0x4dc>
          chprintf(chp2, INDENT_SPACES "$xxGLL sentence is not parsed\n");
 8006a50:	4b09      	ldr	r3, [pc, #36]	; (8006a78 <thdGps+0x4e8>)
 8006a52:	681b      	ldr	r3, [r3, #0]
 8006a54:	4915      	ldr	r1, [pc, #84]	; (8006aac <thdGps+0x51c>)
 8006a56:	4618      	mov	r0, r3
 8006a58:	f7fe fcd2 	bl	8005400 <chprintf>
        break;
 8006a5c:	e006      	b.n	8006a6c <thdGps+0x4dc>

      case MINMEA_INVALID: {
        chprintf(chp2, INDENT_SPACES "$xxxxx sentence is not valid\n");
 8006a5e:	4b06      	ldr	r3, [pc, #24]	; (8006a78 <thdGps+0x4e8>)
 8006a60:	681b      	ldr	r3, [r3, #0]
 8006a62:	4913      	ldr	r1, [pc, #76]	; (8006ab0 <thdGps+0x520>)
 8006a64:	4618      	mov	r0, r3
 8006a66:	f7fe fccb 	bl	8005400 <chprintf>
      }
        break;
 8006a6a:	bf00      	nop

      default: {
      }
    }
    chThdSleepMilliseconds(2);
 8006a6c:	2014      	movs	r0, #20
 8006a6e:	f7fd fea7 	bl	80047c0 <chThdSleep>
  while (TRUE) {
 8006a72:	e5c0      	b.n	80065f6 <thdGps+0x66>
 8006a74:	20000f84 	.word	0x20000f84
 8006a78:	20000824 	.word	0x20000824
 8006a7c:	080073d8 	.word	0x080073d8
 8006a80:	080073f4 	.word	0x080073f4
 8006a84:	08007418 	.word	0x08007418
 8006a88:	08007458 	.word	0x08007458
 8006a8c:	0800747c 	.word	0x0800747c
 8006a90:	080074a0 	.word	0x080074a0
 8006a94:	080074c8 	.word	0x080074c8
 8006a98:	080074e4 	.word	0x080074e4
 8006a9c:	08007500 	.word	0x08007500
 8006aa0:	08007524 	.word	0x08007524
 8006aa4:	08007554 	.word	0x08007554
 8006aa8:	08007578 	.word	0x08007578
 8006aac:	080075bc 	.word	0x080075bc
 8006ab0:	080075e0 	.word	0x080075e0
	...

08006ac0 <chRegSetThreadName.lto_priv.2>:
static inline void chRegSetThreadName(const char *name) {
 8006ac0:	b082      	sub	sp, #8
 8006ac2:	9001      	str	r0, [sp, #4]
  __sch_get_currthread()->name = name;
 8006ac4:	4b03      	ldr	r3, [pc, #12]	; (8006ad4 <chRegSetThreadName.lto_priv.2+0x14>)
 8006ac6:	68db      	ldr	r3, [r3, #12]
 8006ac8:	9a01      	ldr	r2, [sp, #4]
 8006aca:	61da      	str	r2, [r3, #28]
}
 8006acc:	bf00      	nop
 8006ace:	b002      	add	sp, #8
 8006ad0:	4770      	bx	lr
 8006ad2:	bf00      	nop
 8006ad4:	20000d90 	.word	0x20000d90
	...

08006ae0 <thdBlinker>:
 }

 */

static THD_WORKING_AREA(waBlinker, 256);
 static THD_FUNCTION(thdBlinker, arg){
 8006ae0:	b500      	push	{lr}
 8006ae2:	b083      	sub	sp, #12
 8006ae4:	9001      	str	r0, [sp, #4]
 (void) arg;
 chRegSetThreadName("Blinker");
 8006ae6:	4804      	ldr	r0, [pc, #16]	; (8006af8 <thdBlinker+0x18>)
 8006ae8:	f7ff ffea 	bl	8006ac0 <chRegSetThreadName.lto_priv.2>
 while(TRUE){
 chThdSleepMilliseconds(50);
 8006aec:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8006af0:	f7fd fe66 	bl	80047c0 <chThdSleep>
 8006af4:	e7fa      	b.n	8006aec <thdBlinker+0xc>
 8006af6:	bf00      	nop
 8006af8:	08007600 	.word	0x08007600
 8006afc:	00000000 	.word	0x00000000

08006b00 <main>:
 }
}

static THD_WORKING_AREA(waGps, 1024);

int main(void) {
 8006b00:	b500      	push	{lr}
 8006b02:	b083      	sub	sp, #12
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */

  halInit();
 8006b04:	f7fa fafc 	bl	8001100 <halInit>
  chSysInit();
 8006b08:	f7fc fe32 	bl	8003770 <chSysInit>
  /*
   * Shell manager initialization.
   */
  //shellInit();

  chThdCreateStatic(waBlinker, sizeof(waBlinker), NORMALPRIO - 1, thdBlinker, NULL);
 8006b0c:	2300      	movs	r3, #0
 8006b0e:	9300      	str	r3, [sp, #0]
 8006b10:	4b0a      	ldr	r3, [pc, #40]	; (8006b3c <main+0x3c>)
 8006b12:	227f      	movs	r2, #127	; 0x7f
 8006b14:	f44f 71f8 	mov.w	r1, #496	; 0x1f0
 8006b18:	4809      	ldr	r0, [pc, #36]	; (8006b40 <main+0x40>)
 8006b1a:	f7fd fdc1 	bl	80046a0 <chThdCreateStatic>
  chThdCreateStatic(waGps, sizeof(waGps), NORMALPRIO + 1, thdGps, NULL);
 8006b1e:	2300      	movs	r3, #0
 8006b20:	9300      	str	r3, [sp, #0]
 8006b22:	4b08      	ldr	r3, [pc, #32]	; (8006b44 <main+0x44>)
 8006b24:	2281      	movs	r2, #129	; 0x81
 8006b26:	f44f 619e 	mov.w	r1, #1264	; 0x4f0
 8006b2a:	4807      	ldr	r0, [pc, #28]	; (8006b48 <main+0x48>)
 8006b2c:	f7fd fdb8 	bl	80046a0 <chThdCreateStatic>
     "shell", NORMALPRIO + 1,
     shellThread, (void *)&shell_cfg1);
     chThdWait(tpShell);
     Waiting termination.             */

    chThdSleepMilliseconds(200);
 8006b30:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8006b34:	f7fd fe44 	bl	80047c0 <chThdSleep>
 8006b38:	e7fa      	b.n	8006b30 <main+0x30>
 8006b3a:	bf00      	nop
 8006b3c:	08006ae1 	.word	0x08006ae1
 8006b40:	20000fe0 	.word	0x20000fe0
 8006b44:	08006591 	.word	0x08006591
 8006b48:	200011d0 	.word	0x200011d0

08006b4c <_strtol_l.part.0>:
 8006b4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006b50:	4681      	mov	r9, r0
 8006b52:	4845      	ldr	r0, [pc, #276]	; (8006c68 <_strtol_l.part.0+0x11c>)
 8006b54:	468e      	mov	lr, r1
 8006b56:	4675      	mov	r5, lr
 8006b58:	f81e cb01 	ldrb.w	ip, [lr], #1
 8006b5c:	f810 400c 	ldrb.w	r4, [r0, ip]
 8006b60:	f014 0408 	ands.w	r4, r4, #8
 8006b64:	d1f7      	bne.n	8006b56 <_strtol_l.part.0+0xa>
 8006b66:	f1bc 0f2d 	cmp.w	ip, #45	; 0x2d
 8006b6a:	46e3      	mov	fp, ip
 8006b6c:	d054      	beq.n	8006c18 <_strtol_l.part.0+0xcc>
 8006b6e:	f1bc 0f2b 	cmp.w	ip, #43	; 0x2b
 8006b72:	bf08      	it	eq
 8006b74:	f89e b000 	ldrbeq.w	fp, [lr]
 8006b78:	f06f 4800 	mvn.w	r8, #2147483648	; 0x80000000
 8006b7c:	bf08      	it	eq
 8006b7e:	f105 0e02 	addeq.w	lr, r5, #2
 8006b82:	b11b      	cbz	r3, 8006b8c <_strtol_l.part.0+0x40>
 8006b84:	2b10      	cmp	r3, #16
 8006b86:	d04f      	beq.n	8006c28 <_strtol_l.part.0+0xdc>
 8006b88:	461f      	mov	r7, r3
 8006b8a:	e004      	b.n	8006b96 <_strtol_l.part.0+0x4a>
 8006b8c:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
 8006b90:	d055      	beq.n	8006c3e <_strtol_l.part.0+0xf2>
 8006b92:	230a      	movs	r3, #10
 8006b94:	461f      	mov	r7, r3
 8006b96:	2500      	movs	r5, #0
 8006b98:	fbb8 f6f7 	udiv	r6, r8, r7
 8006b9c:	4628      	mov	r0, r5
 8006b9e:	fb07 8a16 	mls	sl, r7, r6, r8
 8006ba2:	e007      	b.n	8006bb4 <_strtol_l.part.0+0x68>
 8006ba4:	4286      	cmp	r6, r0
 8006ba6:	d315      	bcc.n	8006bd4 <_strtol_l.part.0+0x88>
 8006ba8:	d029      	beq.n	8006bfe <_strtol_l.part.0+0xb2>
 8006baa:	fb07 c000 	mla	r0, r7, r0, ip
 8006bae:	2501      	movs	r5, #1
 8006bb0:	f81e bb01 	ldrb.w	fp, [lr], #1
 8006bb4:	f1ab 0c30 	sub.w	ip, fp, #48	; 0x30
 8006bb8:	f1bc 0f09 	cmp.w	ip, #9
 8006bbc:	d906      	bls.n	8006bcc <_strtol_l.part.0+0x80>
 8006bbe:	f1ab 0c41 	sub.w	ip, fp, #65	; 0x41
 8006bc2:	f1bc 0f19 	cmp.w	ip, #25
 8006bc6:	d808      	bhi.n	8006bda <_strtol_l.part.0+0x8e>
 8006bc8:	f1ab 0c37 	sub.w	ip, fp, #55	; 0x37
 8006bcc:	4563      	cmp	r3, ip
 8006bce:	dd0d      	ble.n	8006bec <_strtol_l.part.0+0xa0>
 8006bd0:	2d00      	cmp	r5, #0
 8006bd2:	dae7      	bge.n	8006ba4 <_strtol_l.part.0+0x58>
 8006bd4:	f04f 35ff 	mov.w	r5, #4294967295
 8006bd8:	e7ea      	b.n	8006bb0 <_strtol_l.part.0+0x64>
 8006bda:	f1ab 0c61 	sub.w	ip, fp, #97	; 0x61
 8006bde:	f1bc 0f19 	cmp.w	ip, #25
 8006be2:	d803      	bhi.n	8006bec <_strtol_l.part.0+0xa0>
 8006be4:	f1ab 0c57 	sub.w	ip, fp, #87	; 0x57
 8006be8:	4563      	cmp	r3, ip
 8006bea:	dcf1      	bgt.n	8006bd0 <_strtol_l.part.0+0x84>
 8006bec:	2d00      	cmp	r5, #0
 8006bee:	db0b      	blt.n	8006c08 <_strtol_l.part.0+0xbc>
 8006bf0:	b104      	cbz	r4, 8006bf4 <_strtol_l.part.0+0xa8>
 8006bf2:	4240      	negs	r0, r0
 8006bf4:	b10a      	cbz	r2, 8006bfa <_strtol_l.part.0+0xae>
 8006bf6:	bb95      	cbnz	r5, 8006c5e <_strtol_l.part.0+0x112>
 8006bf8:	6011      	str	r1, [r2, #0]
 8006bfa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006bfe:	45e2      	cmp	sl, ip
 8006c00:	dad3      	bge.n	8006baa <_strtol_l.part.0+0x5e>
 8006c02:	f04f 35ff 	mov.w	r5, #4294967295
 8006c06:	e7d3      	b.n	8006bb0 <_strtol_l.part.0+0x64>
 8006c08:	2322      	movs	r3, #34	; 0x22
 8006c0a:	f8c9 3000 	str.w	r3, [r9]
 8006c0e:	b31a      	cbz	r2, 8006c58 <_strtol_l.part.0+0x10c>
 8006c10:	f10e 31ff 	add.w	r1, lr, #4294967295
 8006c14:	4640      	mov	r0, r8
 8006c16:	e7ef      	b.n	8006bf8 <_strtol_l.part.0+0xac>
 8006c18:	f89e b000 	ldrb.w	fp, [lr]
 8006c1c:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
 8006c20:	f105 0e02 	add.w	lr, r5, #2
 8006c24:	2401      	movs	r4, #1
 8006c26:	e7ac      	b.n	8006b82 <_strtol_l.part.0+0x36>
 8006c28:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
 8006c2c:	d1ac      	bne.n	8006b88 <_strtol_l.part.0+0x3c>
 8006c2e:	f89e 0000 	ldrb.w	r0, [lr]
 8006c32:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 8006c36:	2858      	cmp	r0, #88	; 0x58
 8006c38:	d007      	beq.n	8006c4a <_strtol_l.part.0+0xfe>
 8006c3a:	461f      	mov	r7, r3
 8006c3c:	e7ab      	b.n	8006b96 <_strtol_l.part.0+0x4a>
 8006c3e:	f89e 3000 	ldrb.w	r3, [lr]
 8006c42:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8006c46:	2b58      	cmp	r3, #88	; 0x58
 8006c48:	d10b      	bne.n	8006c62 <_strtol_l.part.0+0x116>
 8006c4a:	2710      	movs	r7, #16
 8006c4c:	f89e b001 	ldrb.w	fp, [lr, #1]
 8006c50:	463b      	mov	r3, r7
 8006c52:	f10e 0e02 	add.w	lr, lr, #2
 8006c56:	e79e      	b.n	8006b96 <_strtol_l.part.0+0x4a>
 8006c58:	4640      	mov	r0, r8
 8006c5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006c5e:	4680      	mov	r8, r0
 8006c60:	e7d6      	b.n	8006c10 <_strtol_l.part.0+0xc4>
 8006c62:	2308      	movs	r3, #8
 8006c64:	461f      	mov	r7, r3
 8006c66:	e796      	b.n	8006b96 <_strtol_l.part.0+0x4a>
 8006c68:	08007609 	.word	0x08007609

08006c6c <strtol>:
 8006c6c:	2a01      	cmp	r2, #1
 8006c6e:	d009      	beq.n	8006c84 <strtol+0x18>
 8006c70:	2a24      	cmp	r2, #36	; 0x24
 8006c72:	4613      	mov	r3, r2
 8006c74:	d806      	bhi.n	8006c84 <strtol+0x18>
 8006c76:	4a07      	ldr	r2, [pc, #28]	; (8006c94 <strtol+0x28>)
 8006c78:	4684      	mov	ip, r0
 8006c7a:	6810      	ldr	r0, [r2, #0]
 8006c7c:	460a      	mov	r2, r1
 8006c7e:	4661      	mov	r1, ip
 8006c80:	f7ff bf64 	b.w	8006b4c <_strtol_l.part.0>
 8006c84:	b510      	push	{r4, lr}
 8006c86:	f000 f807 	bl	8006c98 <__errno>
 8006c8a:	2316      	movs	r3, #22
 8006c8c:	6003      	str	r3, [r0, #0]
 8006c8e:	2000      	movs	r0, #0
 8006c90:	bd10      	pop	{r4, pc}
 8006c92:	bf00      	nop
 8006c94:	20000828 	.word	0x20000828

08006c98 <__errno>:
 8006c98:	4b01      	ldr	r3, [pc, #4]	; (8006ca0 <__errno+0x8>)
 8006c9a:	6818      	ldr	r0, [r3, #0]
 8006c9c:	4770      	bx	lr
 8006c9e:	bf00      	nop
 8006ca0:	20000828 	.word	0x20000828

08006ca4 <strncmp>:
 8006ca4:	b3a2      	cbz	r2, 8006d10 <strncmp+0x6c>
 8006ca6:	b530      	push	{r4, r5, lr}
 8006ca8:	ea40 0401 	orr.w	r4, r0, r1
 8006cac:	07a4      	lsls	r4, r4, #30
 8006cae:	4684      	mov	ip, r0
 8006cb0:	460b      	mov	r3, r1
 8006cb2:	d02a      	beq.n	8006d0a <strncmp+0x66>
 8006cb4:	f89c 0000 	ldrb.w	r0, [ip]
 8006cb8:	780c      	ldrb	r4, [r1, #0]
 8006cba:	4284      	cmp	r4, r0
 8006cbc:	d12f      	bne.n	8006d1e <strncmp+0x7a>
 8006cbe:	2a01      	cmp	r2, #1
 8006cc0:	d00d      	beq.n	8006cde <strncmp+0x3a>
 8006cc2:	46e6      	mov	lr, ip
 8006cc4:	b160      	cbz	r0, 8006ce0 <strncmp+0x3c>
 8006cc6:	f81e 0f01 	ldrb.w	r0, [lr, #1]!
 8006cca:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8006cce:	ea6f 030e 	mvn.w	r3, lr
 8006cd2:	42a0      	cmp	r0, r4
 8006cd4:	4413      	add	r3, r2
 8006cd6:	d122      	bne.n	8006d1e <strncmp+0x7a>
 8006cd8:	eb1c 0303 	adds.w	r3, ip, r3
 8006cdc:	d1f2      	bne.n	8006cc4 <strncmp+0x20>
 8006cde:	2000      	movs	r0, #0
 8006ce0:	bd30      	pop	{r4, r5, pc}
 8006ce2:	6804      	ldr	r4, [r0, #0]
 8006ce4:	4619      	mov	r1, r3
 8006ce6:	f853 5b04 	ldr.w	r5, [r3], #4
 8006cea:	f1a4 3e01 	sub.w	lr, r4, #16843009	; 0x1010101
 8006cee:	42ac      	cmp	r4, r5
 8006cf0:	4684      	mov	ip, r0
 8006cf2:	ea2e 0e04 	bic.w	lr, lr, r4
 8006cf6:	f100 0004 	add.w	r0, r0, #4
 8006cfa:	d10b      	bne.n	8006d14 <strncmp+0x70>
 8006cfc:	3a04      	subs	r2, #4
 8006cfe:	4684      	mov	ip, r0
 8006d00:	4619      	mov	r1, r3
 8006d02:	d0ec      	beq.n	8006cde <strncmp+0x3a>
 8006d04:	f01e 3f80 	tst.w	lr, #2155905152	; 0x80808080
 8006d08:	d1e9      	bne.n	8006cde <strncmp+0x3a>
 8006d0a:	2a03      	cmp	r2, #3
 8006d0c:	d8e9      	bhi.n	8006ce2 <strncmp+0x3e>
 8006d0e:	e7d1      	b.n	8006cb4 <strncmp+0x10>
 8006d10:	4610      	mov	r0, r2
 8006d12:	4770      	bx	lr
 8006d14:	f89c 0000 	ldrb.w	r0, [ip]
 8006d18:	780c      	ldrb	r4, [r1, #0]
 8006d1a:	42a0      	cmp	r0, r4
 8006d1c:	d0d1      	beq.n	8006cc2 <strncmp+0x1e>
 8006d1e:	1b00      	subs	r0, r0, r4
 8006d20:	bd30      	pop	{r4, r5, pc}
 8006d22:	bf00      	nop
